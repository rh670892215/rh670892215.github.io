<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Kafka | bank blog</title><meta name="author" content="bank"><meta name="copyright" content="bank"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="article">
<meta property="og:title" content="Kafka">
<meta property="og:url" content="http://example.com/2023/05/16/kafka/index.html">
<meta property="og:site_name" content="bank blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-05-16T12:56:38.544Z">
<meta property="article:modified_time" content="2023-07-30T06:13:07.816Z">
<meta property="article:author" content="bank">
<meta property="article:tag" content="mq">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/05/16/kafka/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kafka',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-30 14:13:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="bank blog"><span class="site-name">bank blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Kafka</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-16T12:56:38.544Z" title="发表于 2023-05-16 20:56:38">2023-05-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-30T06:13:07.816Z" title="更新于 2023-07-30 14:13:07">2023-07-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Kafka"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer"/>

<span id="more"></span>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="exporter-version" content="Evernote Mac 9.5.27 (467686)" />
    <meta name="author" content="R。" />
    <meta name="created" content="2023-01-29 02:42:55 +0000" />
    <meta name="source" content="yinxiang.superNote" />
    <meta name="updated" content="2023-02-20 09:30:43 +0000" />
    <title>kafka</title>
</head>

<body>
    <h1>基本概念</h1>
    <h3>功能：</h3>
    <ol>
        <li>
            <div>消息系统：系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性，消息顺行保障及回溯消费；</div>
        </li>
        <li>
            <div>存储系统：消息持久化磁盘，降低数据丢失风险；</div>
        </li>
        <li>
            <div>流式处理平台：为每个流行的落实处理框架提供可靠的数据来源，提供玩这个的落实处理类库；</div>
        </li>
    </ol>
    <div><br /></div>
    <h3>基本概念：</h3><img src="/kafka.resources/65F5CE49-53BD-4563-9A0E-5430A7EA3EED.png" height="1532" width="1845" />
    <ul>
        <li>
            <div>Topic：抽象的虚拟概念，一个集群可以有多个topic，一个生产者将一条消息发送到一个topic，一个消费者订阅一个topic拉取消息；</div>
        </li>
        <li>
            <div>broker：<span style="font-size: 14px;">一个Kafka集群有多个broker，<span
                        style="font-family: Helvetica Neue, Helvetica, sans-serif;"><span
                            style="color: rgba(0, 0, 0, 0.75);">一个Topic有N个Partition，一个集群有N个Broker，那么每个Broker都会存储一个这个Topic的Partition。如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition；</span></span></span>
            </div>
        </li>
        <li>
            <div>producer：消息生产者，指定消息发送的topic，一般写入的消息通过轮询将消息写入各partition，也可以设定消息key值将消息吸入固定分区；（写入分区越均匀Kafka性能越好）</div>
        </li>
        <li>
            <div>consumer：消息消费者；</div>
        </li>
        <li>
            <div>partition：物理概念，一个topic对应一个或多个partition，同一个partition内的消息是有序的；</div>
        </li>
        <li>
            <div>
                replication：一个partition有多个replication副本，每个broker存储成百上千个不同主题和分区的副本，存储内容分成两种：master副本和follower副本，所有内容的写入和消费都会经过master，follower不处理客户端请求，只同步master内容进行复制，master死掉后从follower中选取新的mater；
            </div>
        </li>
        <li>
            <div>offset：偏移量是一种元数据，是不断递增的整数。在消息写入时Kafka会把它添加到消息里。在分区内偏移量是唯一的。消费过程中会把最后读取的偏移量存储在Kafka中，消费者关闭便宜量不丢失，重启继续消费。
            </div>
        </li>
    </ul>
    <div>tips：</div>
    <ol>
        <li>
            <div>kafka保证分区内有序，而不是主题有序；</div>
        </li>
        <li>
            <div>一个topic可以横跨多个broker；</div>
        </li>
        <li>
            <div>每一条消息发送到broker前，会根据分区选择存储到哪个具体的分区；</div>
        </li>
    </ol><img src="/kafka.resources/1EE44434-732C-4FA0-8951-41FECB372191.png" height="600" width="922" />
    <div><br /></div>
    <ul>
        <li>
            <div>AR：分区中所有副本；</div>
        </li>
        <li>
            <div>ISR：所有与leader副本保持一定程度同步的副本；</div>
        </li>
        <li>
            <div>OSR：与leader副本同步滞后过多的副本；</div>
        </li>
    </ul>
    <div><br /></div>
    <div>HW：high watermark</div>
    <p>LEO：log end offset</p><img src="/kafka.resources/62939383-E857-4D12-B203-405C1A8CBE45.png" height="394"
        width="916" />
    <div>exp：</div>
    <table
        style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:726px;"
        width="726px">
        <colgroup>
            <col style="width: 536px;" />
            <col style="width: 190px;" />
        </colgroup>
        <tbody>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/89EA7722-5DA0-4364-804F-F97CEBF57BF7.png" height="406" width="780" />
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div><br /></div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/DEF12B67-A549-4FB6-B95B-9B9948E08710.png" height="748" width="1344" />
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div><br /></div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/35C011D3-6775-49FD-8F64-7A031E994E36.png" height="243" width="462" />
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>此时只能消费到HW前的消息，即0～3</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/07397027-2DC6-48F8-A708-8B1B291868FB.png" height="744" width="1508" />
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div><br /></div>
                </td>
            </tr>
        </tbody>
    </table>
    <div><br /></div>
    <h1>生产者</h1>
    <h3>生产逻辑需要具备的步骤：</h3>
    <ol>
        <li>
            <div>配置生产者客户端及创建相应的生产者实例；</div>
        </li>
        <li>
            <div>构建待发送的消息；</div>
        </li>
        <li>
            <div>发送消息；</div>
        </li>
        <li>
            <div>关闭生产者实例；</div>
        </li>
    </ol>
    <div><br /></div>
    <div>生产者是线程安全的美可以在多线程的环境中复用；</div>
    <div><br /></div>
    <h3>生产者客户端参数配置：</h3>
    <table
        style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:747px;"
        width="747px">
        <colgroup>
            <col style="width: 190px;" />
            <col style="width: 190px;" />
            <col style="width: 367px;" />
        </colgroup>
        <tbody>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>name</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>含义</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>用途</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>topic</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>主题</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div><br /></div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>partition</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>分区</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div><br /></div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>header</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>消息头部</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>设定一些与应用相关的信息</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>key</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>键</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>指定消息的键，不仅是消息的附加信息，还可以用来计算分区好让消息发往特定的分区，有key的消息支持日志压缩</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>value</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>值</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>消息体</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>timestamp</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>时间戳</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>CreateTime（消息创建时间）</div>
                    <div>LogAppendTime（消息追加到日志时间）</div>
                </td>
            </tr>
        </tbody>
    </table>
    <div><br /></div>
    <p>必须参数：</p>
    <ul>
        <li>
            <p>bootstrap.servers：指定生产者客户端连接Kafka集群所需的broker地址清单（host1:port1
                host2:port2），并非需要所有的broker地址，生产者或从给定的broker里查找其他broker信息，一般建议给定两个地址，一个宕机了还可以使用另一个；</p>
        </li>
        <li>
            <p>key.serializer、value.serializer：key和value需要序列化，使用该参数指定序列化操作的序列化器；</p>
        </li>
        <li>
            <p>client-id：设定KafkaProducer对应的客户端id，默认是“”，若不设置，自动分配“producer-1”“producer-2”；</p>
        </li>
    </ul>
    <p><br /></p>
    <div><br /></div>
    <h3>消息发送：</h3>
    <div>必填项：topic、value</div>
    <div>三种消息发送方式：发后即忘、同步、异步</div>
    <div><br /></div>
    <div>消息在通过send()发往broker的过程中，可能需要经过拦截器、序列化器、分区器；（若没有指定partition，则需要根据key计算partition的值）</div>
    <div><br /></div>
    <h3>分区器：</h3>
    <ol>
        <li>
            <div>Key不为空的时候回采用MurmurHash2算法计算hash值，根据hash值计算分区号，相同key的消息会被写入相同分区；</div>
        </li>
        <li>
            <div>key是null的时候，消息会以轮询的方式发往topic内的各个可用分区；</div>
        </li>
    </ol>
    <div>可以根据需要自定义分区器；</div>
    <div><br /></div>
    <h3>拦截器：</h3>
    <ul>
        <li>
            <div>生产者在消息序列化和计算分区前会调用生产者拦截器的onSend()方法对消息进行相应的定制化操作；</div>
        </li>
        <li>
            <div>生产者在消息被应答之前或消息发送失败时调用生产者拦截器的onAcknowledgement()方法，优先于用户设定的Callback之前执行；</div>
        </li>
        <li>
            <div>可以指定拦截器的执行顺序，形成一条拦截链，若其中一个拦截器执行失败，则下一个拦截器会接着从上一个执行成功的拦截器继续执行；</div>
        </li>
    </ul>
    <div><br /></div>
    <div><br /></div>
    <h2>原理分析</h2><img src="/kafka.resources/33209826-17BB-44C5-9124-3F58191A266E.png" height="1290" width="1514" />
    <div>RecordAccumulator：</div>
    <div>
        缓存待发送的消息，缓存的大小通过参数buffer.memory配置，默认是32MB，为每个partition都维护一个双端队列，同时为了防止频繁的内存创建和释放，内部维护一个BufferPool，针对特定大小的ButeBuffer进行管理，这个特定大小通过参数batch.size设置，默认是16kb，ProducerBatch的大小与batch.size关系密切，新来一条消息先从双端队列尾部取出一个ProducerBatch，若剩余空间足够则直接写入，若不够则比较需要的空间是否小于batch.size，若小于申请batch.size大小的空间，后续复用，否则直接申请需要的大小，不可复用；
    </div>
    <div><br /></div>
    <div>Sender：</div>
    <div>Sender线程中缓存消息的封装转换如下</div>
    <div>&lt;分区，Deque&lt;ProducerBatch&gt;&gt;</div>
    <div>&lt;Node，List&lt;ProducerBatch&gt;&gt;</div>
    <div>&lt;Node，Request&gt;</div>
    <div>Map&lt;Nodeid，Deque&lt;Request&gt;&gt;</div>
    <div><br /></div>
    <div>元数据更新：</div>
    <div>
        元数据指集群中有哪些topic，这些topic有哪些partition，每个partition都leader副本分配在那个节点上，follower副本分配在那些节点上，哪些副本在AR、ISR等集合中，集群中有哪些节点，控制器节点又是哪一个等信息；
    </div>
    <div>当客户端中没有需要使用的元数据信息时或超过metadata.max.age.ms时间没有更新元数据时（默认5min），集群会选择负载最低的节点进行元数据的更新；</div>
    <div><br /></div>
    <h2>重要的生产者参数</h2>
    <table
        style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:686px;"
        width="686px">
        <colgroup>
            <col style="width: 122px;" />
            <col style="width: 190px;" />
            <col style="width: 374px;" />
        </colgroup>
        <tbody>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>name</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>功能</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>备注</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>acks</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>指定分区中必须要有多少副本收到这条消息</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <ul>
                        <li>
                            <div>acks=1，生产者发送消息后，只要分区的leader副本成功写入消息就会收到来自服务端的成功响应；</div>
                        </li>
                        <li>
                            <div>acks=0，生产者发送消息后不需要等待任何服务端的响应；</div>
                        </li>
                        <li>
                            <div>acks=-1或acks=all，生产者发送消息后，需要等待ISR中所有副本都成功写入消息后才能收到来自服务端的成功响应；</div>
                        </li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>max.request.size</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>限制生产者客户端能发送消息的最大值</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>默认1MB，不建议盲目增大该值，尤其是对Kafka整体脉络没有足够把控的时候；</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>retires&amp;retry.backoff.ms</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>配置生产者重试的次数</div>
                    <div>设定两次重试间的时间间隔</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>默认是0</div>
                    <div>默认是100</div>
                    <p>一般需要保证消息顺序的场合建议吧参数max.in.flight.request.per.connection设置成1，而不是那acks配置成0</p>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>compression.type</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>指定消息的压缩方式</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>默认值是“none”，即不压缩</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>connectios.max.idle.ms</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>指定多久之后关闭限制的连接</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>默认值是9min</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>linger.ms</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>指定生产者发送ProducerBatch之前等待更多消息加入ProducerBatch的时间</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>默认值是0，增大这个参数会增加消息的延迟，同时能提升一定的吞吐量，类似TCp协议中的Nagle算法</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>receive.buffer.bytes</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>设置Socket接收消息缓冲区的大小</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>默认值32KB</div>
                    <p>设置成-1时使用系统默认值</p>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>send.buffer.bytes</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>设置Socket发送消息缓冲区的大小</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>默认值128KB</div>
                    <p>设置成-1时使用系统默认值</p>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>request.timeout.ms</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>配置Producer等待请求响应的最长时间</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>默认值是30000ms</div>
                </td>
            </tr>
        </tbody>
    </table><img src="/kafka.resources/61851D2D-5109-4F54-9FB8-67C13D80CC4B.png" height="184" width="916" /><img
        src="/kafka.resources/EDF27A99-C8FF-4588-9C16-6D15F36B8999.png" height="790" width="918" />
    <div><br /></div>
    <h1>消费者</h1>
    <div>每个消费者都属于一个消费者组，当消息被发布到topic中，只会投递给订阅它的每个消费者组中的一个消费者；</div><img
        src="/kafka.resources/ECE046B8-F046-4ECD-99C8-ED8A4E8B6E8B.png" height="508" width="904" />
    <ul>
        <li>
            <div>消费组是一个逻辑上的概念，它将旗下的消费者归为一类，每一个消费者只隶属于一个消费组。每一个消费组都会有一个固定的名称，消费者在进行消费前需要指定其所属消费组的名称，这个可以通过消费者客户端参数 group
                .id 来配置，默认值为空宇符串。</div>
        </li>
        <li>
            <p>消费者并非逻辑上的概念，它是实际的应用实例，它可以是一个钱程，也可以是一个进程。同一个消费组内的消费者既可以部署在同一 台机器上，也可以部署在不同的机器上。</p>
        </li>
    </ul>
    <div>一个分区只能被同一个消费者组中的一个消费者消费；</div>
    <div><br /></div>
    <h2>消费逻辑需要具备的步骤：</h2>
    <ol>
        <li>
            <div>配置消费者客户端参数及创建相应的消费者实例；</div>
        </li>
        <li>
            <div>订阅topic；</div>
        </li>
        <li>
            <div>拉取消息并消费；</div>
        </li>
        <li>
            <div>提交消费位移；</div>
        </li>
        <li>
            <div>关闭消费者实例；</div>
        </li>
    </ol>
    <div><br /></div>
    <div>必须参数：</div>
    <ol>
        <li>
            <div>bootstrap.servers：与producer中的相同，指定连接Kafka集群所需的broker地址清单；</div>
        </li>
        <li>
            <div>group.id：消费者隶属的消费者组的名称，默认值是“”；</div>
        </li>
        <li>
            <p>key.deserializer、value.deserializer：指定key、value的反序列化操作的反序列化器；</p>
        </li>
        <li>
            <p>client.id：设定consumer对应的客户端id，默认值是“consumer-1”、“consumer-2”；</p>
        </li>
    </ol>
    <p><br /></p>
    <div>消费者前后两次订阅了不同的主题，那么消费者以最后一次的为准；</div>
    <div>消费者使用正则表达式的方式订阅，在之后的过程中，如果有人又创建了新的主题，并且主题的名字与正则表达式相匹配，那么这个消费者就可以消费到新添加的主题中的消息；</div>
    <div><br /></div>
    <p>消费者的三种订阅方式：</p>
    <ol>
        <li>
            <p>集合订阅；subscribe(Collection)</p>
        </li>
        <li>
            <p>正则表达式订阅；subscribe(Pattern)</p>
        </li>
        <li>
            <p>指定分区订阅；assign(Collection)</p>
        </li>
    </ol>
    <div><br /></div>
    <h2>消息消费</h2>
    <div>Kafka使用poll方法轮询消息，可以设置超时时间poll(Duration)</div>
    <div>消息类型ConsumerRecord结构：</div><img src="/kafka.resources/8E10AD43-32FA-410A-B62C-116E8D61704F.png" height="686"
        width="828" />
    <div>poll方法还涉及涉及消费位移、消费者协调器、组协调器、消费者的选举、分区分配的分发、再均衡的逻辑、心跳等内容；</div>
    <div><br /></div>
    <h2>消息提交</h2>
    <div>为了每次调用poll拉取消息时，返回的是还没有被消费的消息集，所以需要记录上一次消费的消费位移，消费位移存储在Kafka内部的主题__consumer_offsets中，这里把消费位移存储起来的操作叫做“提交”；
    </div><img src="/kafka.resources/7095C427-8D2C-4060-8D67-019B569FFB79.png" height="448" width="958" />
    <div>提交的位移并不是x，而是x+1；</div>
    <div><br /></div>
    <h3>自动提交</h3>
    <div>自动提交是每隔一段固定时间，（默认5s）消费者提交目前的消费位移，（开关enable.auto.commit）消息消费后的自动提交可能会导致重复消费或消息丢失；</div>
    <ul>
        <li>
            <div>重复消费：假设刚刚提交完一次消费位移，然后拉取一批消息进行消费，在下一次自动提交消费位移之前，消费者崩溃了，那么又得从上一次位移提交的地方重新开始消费，这样便发生了重复消费的现象（对于再均衡的情况同样适用）
            </div>
        </li>
        <li>
            <div>消息丢失：如下图，拉取线程 A 不断地拉取消息并存入本地缓存，比如在 BlockingQueue 中，另一个处理线程 B 从缓存中读取消息并进行相应的逻辑处理。假设目前进行到了第 y+1次拉取，以及第 m
                次位移提交的时候，也就是 x+6 之前的位移己经确认提交了，处理线程 B 却还正在消费 x + 3的消息 。 此时如果处理线程 B 发生了异常，待其恢复之后会从第 m 此位移提交处，也就是 x+6
                的位置开始拉取消息，那么 x+3 至 x+6 之间的消息就没有得到相应的处理，这样便发生消息丢失的现象 。</div>
        </li>
    </ul><img src="/kafka.resources/BD49344C-CF8B-43C9-A62B-5D47532C6BCD.png" height="700" width="1192" />
    <div><br /></div>
    <h3>手动提交</h3>
    <div>手动提交分成同步提交和异步提交，</div>
    <div>同步提交：commitSync()，无参commitSync的会根据poll()方法拉取的最新位移来进行提交，会阻塞消费者线程直至提交完成，commitSync还可以指定offset进行更细粒度的提交；</div>
    <div>
        异步提交：commitAsync()，提交时消费者线程不会阻塞，提交成功后会回调参数中指定的OffsetCommitCallback中的onComplete()方法；为了避免重复消费，可以设置一个递增的序号来维护异步提交的顺序，每次位移提交之后就增加序号相对应的值。在遇到位移提交失败需要重试的时候，可以检查所提交的位移和序号的值的大小，如果前者小于后者，则说明有更大的位移己经提交了，不需要再进行本次重试：如果两者相同，则说明可以进行重试提交。除非程序编码错误，否则不会出现前者大于后者的情况
        。</div>
    <div><br /></div>
    <h2>指定位移消费</h2>
    <div>当有消费者查找不到所记录的消费位移时，会根据auto.offset.reset参数决定从何开始消费，latest表示从分区的末尾开始消费，earliest表示从分区的起始处开始消费；</div>
    <div><br /></div>
    <div>
        使用seek()方法可以通过参数partition制定分区，通过offset参数指定从分区的那个位置开始消费，在执行seek方法之前需要先执行一次poll方法，等到分配到分区之后才可以重置消费位置，通过assignment()方法可以获取消费者所分配到的分区信息；
    </div>
    <div>通过beginningOffsets()方法可以获取分区的开头，endOffsets()方法可以获取分区的结尾；</div>
    <div><br /></div>
    <h2>再均衡</h2>
    <div>再均衡是指分区的所属权从一个消费者转移到另一个消费者的行为；</div>
    <div>在再均衡发生期间的这一小段时间 内，消费组会变得不可用 。另外，当一个分区被重新分配给另一个消费者时， 消费者当前的状态也会丢失。比如消费者消费完某个分区中的一部分消息时还没有来得及提交消费位移就发生了再均衡操作 ，
        之后这个分区又被分配给了消费组内的另一个消费者，原来被消费完的那部分消息又被重新消费一遍，也就是发生了重复消费；</div>
    <p>为了避免重复消费，可以使用以下两个方法：</p>
    <ol>
        <li>
            <p>void onPartitionsRevoked(Collection&lt;TopicPartition&gt;
                partitions)这个方法会在再均衡开始之前和消费者停止读取消息之后被调用。可以通过这个回调方法来处理消费位移的提交，
                以此来避免一些不必要的重复消费现象的发生。参数partitions表示再均衡前所分配到的分区。</p>
        </li>
        <li>
            <p>void onPartitionsAssigned(Collection&lt;TopicPartition&gt; partitions)这个方法会在重新分配分区之后和消费者开始读取消费之前被调用 。参数
                partition表示再均衡后所分配到的分区 。</p>
        </li>
    </ol>
    <p><br /></p>
    <h2>消费者拦截器</h2>
    <div>与生产者拦截器类似，在消费者消费到信息或再提交消费位移时可以进行一些定制化的操作；</div>
    <div>KafkaConsumer会在 poll()方法返回之前调用拦截器的 onConsume()方法来对消息进行相应的定制化操作，比如修改返回的消息内容、按照某种规则过滤消息；</div>
    <div>KafkaConsumer会在提交完消费位移之后调用拦截器的 onCommit()方法，可以使用这个方法来记录跟踪所提交的位移信息；</div>
    <div><br /></div>
    <h2>多线程实现</h2>
    <div>生产者是线程安全的，消费者不是，所以在调用消费者的公有方法时，内部会调用acquire()方法来检测当前是否只有一个线程在操作，调用release()，类似于加锁、解锁操作；</div>
    <div>多线程的实现方式如下；</div>
    <ul>
        <li>
            <div>线程封闭：一个线程对应一个KafkaConsumer实例，一个消费线程可以消费一个或多个分区中的消息，所有的消费线程都隶属于同一个消费组，这种实现的并发度受限于分区的实际个数；</div>
        </li>
    </ul><img src="/kafka.resources/9C0EFAF5-1667-46B5-AAF8-BC5422B2E4C1.png" height="460" width="1206" />
    <ul>
        <li>
            <div>多个消费者线程同时消费一个分区：通过assign()和seek()实现，可以打破原有的消费线程个数不能超过分区数的限制，但是对于唯一提交和顺序控制的处理会变得非常复杂；</div>
        </li>
        <li>
            <div>多线程处理消息：poll拉取消息很快，所以第一种方式的性能瓶颈在于消息的处理，可以将消息处理模块改成多线程的实现方式；</div>
        </li>
    </ul><img src="/kafka.resources/6B4D70C6-217B-4DE6-AC36-FFA739397F53.png" height="464" width="1166" />
    <div>第三种方式没法保证消息的顺序消费，因此可以增加一个共享变量offset记录偏移量，每一个处理消息的 RecordHandler 类在处理完消息之后都将对应的消费位移保存到共享变量 offsets 中，
        KafraConsumerThread 在每一次 poll（）方法之后都读取 offsets 中的内容并对其进行位移提交；（注意对offset的读写要加锁处理）</div><img
        src="/kafka.resources/A1F88056-6F1E-4198-BAD4-C1141694E5F9.png" height="592" width="1226" />
    <div>上述方式也可能导致消息的丢失，可以使用滑动窗口来将拉取到的消息暂存起来，多个消费线程可以拉取暂存的消息；</div><img
        src="/kafka.resources/BF0B859E-194A-4791-81E7-FADA7D522A5D.png" height="642" width="1134" />
    <div>和tcp的滑动窗口类似，当窗口一直悬停时需要设置超时时间，将消费失败的消息存储下来，方便后续进行分析；</div>
    <h2>重要的消费者参数</h2>
    <table
        style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:686px;"
        width="686px">
        <colgroup>
            <col style="width: 122px;" />
            <col style="width: 190px;" />
            <col style="width: 374px;" />
        </colgroup>
        <tbody>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>name</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>功能</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>备注</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>fetch.min.bytes</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>配置一次拉取请求(poll)中能从Kafka中拉取的最小数据量</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>默认值1B</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>fetch.max.bytes</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>配置一次拉取请求(poll)中能从Kafka中拉取的最大数据量</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>默认值50MB</div>
                    <div>如果在第一个非空分区中拉取的第一条消息大于该值，那么该消息将仍然返回，以确保消费者继续工作</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>fetch.max.wait.ms</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>指定Kafka的等待时间</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>默认500ms</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>Max.partition.fetch.bytes</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>配置每个分区里返回给Consumer的最大数据量</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>默认值1MB</div>
                    <div>这个参数与fetch.max.bytes参数相似，只不过前者用来限制一次拉取中每个分区的消息大小，而后者用来限制一次拉取中整体消息的大小。</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>max.poll.records</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>配置Consumer一次拉取请求中拉取的最大消息数</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>默认500条</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>connections.max.idle.ms</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>指定在多久之后关闭限制的连接</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>默认值9min</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>exclude.internal.topics</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>指定 Kafka 中的内部主题（__consumer_offsets、 __transaction_state o）是否可以向消费者公开</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>true：只能使用 subscribe(Collection）的方式而不能使用 subscribe(Pattern）的方式来订阅内部主题；</div>
                    <p>false：没有限制；</p>
                    <div><br /></div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>receive.buffer.bytes</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>设置 Socket 接收消息缓冲区（SO_RECBUF）的大小</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>默认值64KB</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>send.buffer.bytes</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>设置 Socket 发送消息缓冲区（SO_SNDBUF）的大小</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>默认值128KB</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>request.timeout.ms</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>配置 Consumer 等待请求响应的最长时间</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>默认值30000ms</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>metadata.max.age.ms</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>配置元数据的过期时间</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>默认值5min</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>reconnect.backoff.ms</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>配置尝试重新连接指定主机之前的等待时间（也称为退避时间），避免频繁连接主机</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>默认值50ms</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>retry.backoff. ms</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>配置尝试重新发送失败的请求到指定的主题分区之前的等待（退避）时间，避免在某些故障情况下频繁地重复发送</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>默认值100ms</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <p>isolation.level</p>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>配置消费者的事务隔离级别</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <p> read committed ：消费者就会忽略事务未提交的消息，即只能消费到 LSO ( LastStableOffset）的位置，</p>
                    <p>“read_uncommitted ：（默认值）可以消费到 HW (High Watermark ）处的位置。</p>
                </td>
            </tr>
        </tbody>
    </table><img src="/kafka.resources/B6DB4058-13AC-4838-AA00-7CA3EE24242D.png" height="938" width="1496" /><img
        src="/kafka.resources/0DF376E6-6DC5-4FB1-B149-2FE9D03FFF41.png" height="1032" width="1494" />
    <div><br /></div>
    <h1>主题与分区</h1>
    <div><br /></div>
    <div>使用kafka-topics.sh脚本创建主题的指令格式：</div>
    <div>kafka- topics.sh - -zookeeper &lt;String : hosts&gt; -create -- topic [String: topic] --partitions &lt;Integer:
        # of partitions&gt; replication-factor &lt;Integer : replication factor&gt;</div>
    <div><br /></div>
    <div>在创建主题时，如果使用了replica-assignment参数，那么就按照指定的方案来进行分区副本的创建；</div>
    <div>如果没有使用replica-assignment参数，那么就需要按照内部的逻辑来计算分配方案了 。</div>
    <div>使用kafka-topics.sh脚本创建主题时的内部分配逻辑按照机架信息划分成两种策略 ： </div>
    <ul>
        <li>
            <div>未指定机架信息： 如果集群中所有的broker节点都没有配置broker.rack参数，或者使用disable-rack-aware参数来创建主题，那么采用的就是未指定机架信息的分配策略；</div>
        </li>
        <li>
            <div>指定机架信息：</div>
        </li>
    </ul>
    <div><br /></div>
    <div>分区分配算法：（源码）</div>
    <div>startIndex和nextReplicaShift是随机产生的，范围是0～brokerArray.length</div><img
        src="/kafka.resources/24ADA023-B14F-4043-B4FA-B9D0DF56AE10.png" height="1098" width="1760" /><img
        src="/kafka.resources/21F3F49C-58E4-426A-82DD-C59D0CB0AEA1.png" height="312" width="1702" />
    <div><br /></div>
    <h2>主题相关命令</h2>
    <div>查看所有主题：</div><img src="/kafka.resources/321D722D-59E8-4501-8B00-B5DAB07D2F75.png" height="394" width="1860" />
    <div><br /></div>
    <div>查看主题详细信息：</div><img src="/kafka.resources/C3D9D158-1B8C-4F01-803E-071D605DB043.png" height="746"
        width="1846" />
    <div>topics-with-overrides参数：找出所有包含覆盖配置的主题，只会列出包含了与集群不一样配置的topic；</div>
    <div>under-replicated-partitions参数、unavailable-partitions：找出有问题的分区；</div>
    <div><br /></div>
    <div>修改主题：</div>
    <div>修改分区数（只支持增加分区，不支持减少分区）</div>
    <div>kafka-topics.sh（旧）</div><img src="/kafka.resources/02137ECF-4A0F-49A9-A526-3BDC8DD5B2A4.png" height="316"
        width="1856" />
    <div><br /></div>
    <div>kafka-configs.sh（新）</div>
    <p>查看相关 describe</p>
    <p>exp：查看主题topic-config配置</p><img src="/kafka.resources/9DD5CB22-5068-4885-9CF8-813EEB4622FE.png" height="148"
        width="1848" /><img src="/kafka.resources/C8194AA6-6EDF-40F0-A96B-F1A89795E1B7.png" height="416" width="1852" />
    <div><br /></div>
    <div>修改相关 alter</div>
    <div>add-condig：配置的增、改</div>
    <div>delete-config：配置的删除</div><img src="/kafka.resources/EFA5A3E9-2D06-43EC-82F5-2FD25B056555.png" height="274"
        width="1978" />
    <div><br /></div>
    <div>与主题相关的所有配置参数在broker层面都有对应参数，若没有修改过主题的任何参数，那么就会使用broker端端对应参数作为其默认值；</div><img
        src="/kafka.resources/C85DF180-0E61-4F9A-A087-D7784FB21355.png" height="208" width="596" /><img
        src="/kafka.resources/4FB39312-217E-493C-8D89-9DF86528E0A8.png" height="692" width="598" /><img
        src="/kafka.resources/42478D1F-5B7B-4357-81F3-BC421547E7DF.png" height="308" width="597" />
    <div><br /></div>
    <h2>分区、副本相关内容</h2>
    <div><br /></div>
    <h3>优先副本</h3>
    <div>优先副本是指在 AR 集合列表中的第一个副本 ，理想情况下优先副本就是该分区的leader副本；</div>
    <div>优先副本的选举是指通过一定的方式促使优先副本选举为 leader 副本，以此来促进集群的负载均衡 ， 这一行为也可以称为“分区平衡” 。</div>
    <div><br /></div>
    <h3>分区重分配</h3>
    <div>执行kafka-reassign-partitions.sh脚本</div>
    <div>步骤：</div>
    <ol>
        <li>
            <div>创建一个包含主题清单的JSON文件；</div>
        </li>
        <li>
            <div>根据主题清单和broker节点清单生成一份重分配方案；（也可以手动制定重分配方案）</div>
        </li>
        <li>
            <div>根据这份方案执行重分配动作；</div>
        </li>
    </ol>
    <div>（注：应降低重分配的粒度，分成多个小批次执行，将负面的影响降到最低；若需要将某个broker下线，在执行分区重分配前最好先关闭或重启broker）</div>
    <div><br /></div>
    <h3>复制限流</h3>
    <ul>
        <li>
            <div>kafka-config.sh：可以灵活配置四个参数，但比较繁琐</div>
        </li>
        <li>
            <div>kafka-reassign-partitions.sh：原理与上条一致，参数少，建议使用这种</div>
        </li>
    </ul><img src="/kafka.resources/AAF4E802-F10B-494F-871A-4E3E521AF8C5.png" height="182" width="1848" />
    <ul>
        <li>
            <div>kafka-config.sh可配置的四个参数</div>
        </li>
    </ul>
    <div>follower.replication.throttled.rate设置follower副本复制速度</div>
    <div>leader.replication.throttled.rate设置leader副本传输的速度</div>
    <div>leader.replication.throttled.replicas配置被限制速度的主题对应的leader副本列表</div>
    <div>follower.replication.throttled.replicas配置被限制速度的主题对应的follower副本列表</div>
    <div><br /></div>
    <div><br /></div>
    <h3>修改副本因子</h3>
    <table
        style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:564px;"
        width="564px">
        <colgroup>
            <col style="width: 300px;" />
            <col style="width: 264px;" />
        </colgroup>
        <tbody>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>修改前的project.json</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>修改后的project.json</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/D9796569-7EEE-4F60-948F-7D8A26C606B8.png" height="740" width="688" />
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/92055585-0E6B-452C-A0F1-22FCE1386C8D.png" height="886" width="704" />
                </td>
            </tr>
        </tbody>
    </table>
    <p><br /></p>
    <div><br /></div>
    <h3>性能相关</h3>
    <div>性能测试工具：</div>
    <ul>
        <li>
            <div>kafka-producer-perf-test.sh</div>
        </li>
        <li>
            <div>kafka-consumer-perf-test.sh</div>
        </li>
    </ul><img src="/kafka.resources/77991428-5C96-4875-B7CB-0E16453B36CD.png" height="216" width="1892" />
    <div>其中throughput用来进行限流控制，当设定的值效益0时不限流，当设定的值大于0时，当发送的吞吐量大于该值时就会被阻塞一段时间；</div>
    <div><br /></div>
    <div>注意：并不是分区越多吞吐量也就越高，当分区数超过默一个临界值的时候吞吐量会不升反降；</div>
    <table
        style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:1146px;"
        width="1146px">
        <colgroup>
            <col style="width: 353px;" />
            <col style="width: 793px;" />
        </colgroup>
        <tbody>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>生产者</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>消费者</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/C4218845-D5E7-4861-A998-730756FF24CD.png" height="510" width="1106" />
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/A3F22BB8-E1F3-4FAB-9858-7D5D457FC8D2.png" height="514" width="1096" />
                </td>
            </tr>
        </tbody>
    </table>
    <div><br /></div>
    <div>注意：每新增一个分区会占用一个文件描述符，当文件描述符超过上限的时候kafka会奔溃；</div>
    <div>查看文件描述符上限的指令：ulimit -Sn（软限制）、ulimit -Hn（硬限制）</div>
    <div>修改文件描述符上限的指令：ulimit -n xxx</div>
    <div><br /></div>
    <div>小建议：可以将分区数设定为集群中 broker 的倍数，即假定集群中有 3 个 broker 节点，可以设定分区数为 3 、 6 、 9 等 ， 至于倍数的选定可以参考预估的吞吐量</div>
    <div><br /></div>
    <div><br /></div>
    <div><br /></div>
    <h1>日志存储</h1>
    <div>日志文件关系</div><img src="/kafka.resources/2BCFFB4D-9E2E-49EA-A039-B7785773BCF0.png" height="922" width="1522" />
    <h2>日志文件</h2>
    <h3>V0版本日志</h3>
    <table
        style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:753px;"
        width="753px">
        <colgroup>
            <col style="width: 422px;" />
            <col style="width: 117px;" />
            <col style="width: 214px;" />
        </colgroup>
        <tbody>
            <tr>
                <td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"
                    rowspan="8"><img src="/kafka.resources/1F30D057-DEEC-42A0-B03E-7DF305B7C78C.png" height="1254"
                        width="1008" />
                    <div><br /></div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>字段名称</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>字段解释</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>crc32</div>
                    <div>（4B）</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>crc32校验值，校验范围时magic至value之间</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>magic</div>
                    <div>（1B）</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>消息格式版本号，此时是0</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>attributes</div>
                    <div>（1B）</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>消息的属性，共1个字节，低三位表示压缩类型：0-&gt;NONE、1-&gt;GZIP、2-&gt;SNAPPY、3-&gt;LZ4</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>key length</div>
                    <div>（4B）</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>消息的key长度，若是-1，则表示没有设置key</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>key</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>可以为空</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>value length</div>
                    <div>（4B）</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>实际消息体长度，若是-1，则消息是空</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>value</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>消息体，可以为空</div>
                </td>
            </tr>
        </tbody>
    </table>
    <h3>v1版本日志</h3><img src="/kafka.resources/C14320A5-18CC-421E-8F99-AB61CC41E1FB.png" height="1240" width="904" />
    <div><br /></div>
    <h3>消息压缩</h3><img src="/kafka.resources/F80F9D45-F4FF-46AA-8C48-73FB181A1268.png" height="898" width="792" /><img
        src="/kafka.resources/30EBDB0F-8FE3-4EBF-B4C1-A42FFBC4056B.png" height="696" width="724" />
    <div>外层消息保存了内层消息中最后一条消息的绝对位移，即外层消息的1030是内层消息offset=5的消息的偏移量；</div>
    <div><br /></div>
    <div>外层消息的 time stamp 设置为 ：</div>
    <ul>
        <li>
            <p>如果 time stamp 类型是 CreateTime，那么设置的是 内层消息中最大的时间戳。</p>
        </li>
        <li>
            <p>如果 time stamp 类型是 LogAppendTime，那么设置的是 Kafka 服务器当前的时间戳 。</p>
        </li>
    </ul>
    <p>内层消息的 time stamp 设置为 ：</p>
    <ul>
        <li>
            <p>如果外层消息的time stamp类型是 CreateTime，那么设置的是生产者创建消息时的时间戳。</p>
        </li>
    </ul>
    <ul>
        <li>
            <p>如果外层消息的time stamp类型是 LogAppendTime，那么所有内层消息的时间戳都会被忽略。</p>
        </li>
    </ul>
    <div><br /></div>
    <div>Varints模型：使用一个或多个字节来序列化整数的一种方法；（小端字节序，即最小的字节放在前面）</div>
    <div>Varints中的每个字节都有一个位于最高位的 msb 位（ most significant bit ），除最后一个字节外，其余 msb 位都设置为 1 ， 最后一个字节的 msb 位为
        0。这个msb位表示其后的字节是否和当前字节一起来表示一个整数；</div>
    <div>数字300:</div>
    <div>1010 1100 0000 0010</div>
    <div>010 1100 000 0010（去掉msb位）</div>
    <div>000 0010 010 1100（翻转）</div>
    <div>0000 0001 0010 1100 -&gt; 300</div>
    <div><br /></div>
    <h3 />
    <h3>v2版本日志</h3>
    <table
        style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:963px;"
        width="963px">
        <colgroup>
            <col style="width: 417px;" />
            <col style="width: 137px;" />
            <col style="width: 409px;" />
        </colgroup>
        <tbody>
            <tr>
                <td style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;"
                    rowspan="17"><img src="/kafka.resources/566BE485-52B4-43CE-95C9-7F7F29214D01.png" height="1360"
                        width="1272" />
                    <div><br /></div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>字段名称</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>字段含义</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>length</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>消息总长度</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>attributes</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>弃用，占据1B的大小，以备未来的格式扩展</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>timestamp delta</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>时间戳增量，保存与RecordBatch的其实时间戳的差值</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>offset delta</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>位移增量，保存与RecordBatch起始位移的差值</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>headers</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>用来支持应用级别的扩展</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>first offset</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>当前RecordBatch的起始位移</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>length</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>从partition leader epoch字段开始到末尾的长度</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>magic</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>消息格式的版本号</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>attributes</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>消息属性，注意这里占用了两个字节 。 低 3 位表示压缩格式，可以参考v0和v1；第 4 位表示时间戳类型；第 5 位表示此 RecordBatch 是否处于事务中，0表示非事务，1表示事务
                        。第6位表示是否是控制消息 （ ControlBatch ），0表示非控制消息，而1表示是控制消息，控制消息用来支持事务功能</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>last offset delta</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>RecordBatch中最后一个Record的offset与first offset的差值</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>first timestamp</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>RecordBatch中第一条Record的时间戳</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>max timestamp</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>RecordBatch中最大的时间戳</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>producer id</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>PID用来支持幂等事务</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>producer epoch</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>用来支持幂等事务</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>first sequence</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>用来支持幂等事务</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>records count</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>RecordBatch中Record的个数</div>
                </td>
            </tr>
        </tbody>
    </table>
    <div><br /></div>
    <h2>日志索引</h2>
    <div>kafka使用稀疏索引，并通过MappedByteBuffer将索引文件映射到内存中，偏移量索引文件和时间戳索引文件都是严格递增的，在查找时使用二分查找；</div>
    <div><br /></div>
    <div>日志分段文件切分条件：</div>
    <ol>
        <li>
            <div>当前日志分段文件的大小超过了broker端参数log.segment.bytes配置的值。log.segment.bytes参数的默认值为 1073741824 ，即 1GB；</div>
        </li>
        <li>
            <div>当前日志分段中消息的最大时间戳与当前系统的时间戳的差值大于 log.roll .ms或 log.roll.hours 参数配置的值。如果同时配置了 log.roll.ms 和 log.roll.hours
                参数，那么 log.roll.ms 的优先级高 。 默认情况下，只配置了 log.roll.hours 参数，其值为 168,即 7 天；</div>
        </li>
        <li>
            <div>偏移量索引文件或时间戳索引文件的大小达到 broker 端参数log.index.size .max.bytes配置的值。log.index.size .max.bytes的默认值为 10485760 ，即
                l0MB </div>
        </li>
        <li>
            <div>追加的消息的偏移量与当前日志分段的偏移量之间的差值大于 Integr.MAX_VALUE,即要追加的消息的偏移量不能转变为相对偏移量（ offset - baseOffset &gt; 
                Integr.MAX_VALUE）</div>
        </li>
    </ol>
    <div><br /></div>
    <h2>偏移量索引</h2>
    <ol>
        <li>
            <div>relativeOffset：相对偏移量，表示消息相对于baseOffset的偏移量，占用4个字节，当前索引文件的文件名即为baseOffset的值；</div>
        </li>
        <li>
            <div>position：物理地址，也就是消息在日志分段文件中对应的物理位置，占用4个字节；</div>
        </li>
    </ol><img src="/kafka.resources/CFBC5751-0477-4964-80BF-CA72539C7FA7.png" height="158" width="576" />
    <div>索引偏移量示意图：</div><img src="/kafka.resources/BD83528F-D003-4D65-9C3A-A475DEB57D9E.png" height="930"
        width="1270" />
    <div><br /></div>
    <h2>时间戳索引</h2>
    <ol>
        <li>
            <div>timestamp：当前日志分段的最大时间戳；</div>
        </li>
        <li>
            <div>relativeOffset：时间戳对应的消息的相对偏移量；</div>
        </li>
    </ol><img src="/kafka.resources/653848E0-D12C-4DF9-B755-9D0E7AC3999D.png" height="140" width="534" />
    <div>时间戳索引示意图：</div><img src="/kafka.resources/43A84336-C52A-4E08-8039-8697EA0CC4C5.png" height="1126"
        width="1420" />
    <div><br /></div>
    <div><br /></div>
    <div><br /></div>
    <h2>日志清理</h2>
    <div>两种方式：日志删除、日志压缩</div>
    <h3>日志删除</h3>
    <div>日志分段的保留策略：</div>
    <ol>
        <li>
            <div>基于时间</div>
        </li>
        <li>
            <div>基于日志大小</div>
        </li>
        <li>
            <div>基于日志起始偏移量</div>
        </li>
    </ol>
    <div><br /></div>
    <div>基于时间</div><img src="/kafka.resources/4A6C37DF-97C1-4172-AC43-733A800BD978.png" height="454" width="784" />
    <div>查询日志分段文件所对应的时间戳索引文件，查找时间戳索引文件中最后一条索引项，获取日志分段文件的最大时间戳的值，比较这个值与log.retention.ms等过期时间设定值；</div>
    <div>删除步骤：</div>
    <ol>
        <li>
            <div>先切分出一个新的日志分段作为activeSegment；（当所有日志分段都过期时）</div>
        </li>
        <li>
            <div>删除日志分段时，首先从log对象中所维护日志分段的跳跃表中移出待删除的日志分段；</div>
        </li>
        <li>
            <div>然后将日志分段对应的所有文件添加“.delete”后缀；</div>
        </li>
        <li>
            <div>最后交给一个一“delete-file”命名的延迟任务来删除这些文件；</div>
        </li>
    </ol>
    <div><br /></div>
    <div><br /></div>
    <div>基于日志大小</div><img src="/kafka.resources/C98A9625-7D20-4179-9191-900688BE2E74.png" height="474" width="812" />
    <div>log.retention.bytes配置log中所有文件都总大小，默认-1，即无穷大；</div>
    <div>log.segment.bytes配置单个日志文件大小，默认是1GB；</div>
    <div><br /></div>
    <div>基于日志起始偏移量</div><img src="/kafka.resources/C4C0D263-557D-4FF0-8601-F2C78FFE722C.png" height="400" width="856" />
    <div>判断依据：某日志分段的下一日志分段的其实偏移量baseOffset是否小于等于logStartOffset，若是，则可以删除此日志分段；</div>
    <div><br /></div>
    <h2>日志压缩</h2><img src="/kafka.resources/EB57891F-1BFF-4515-9827-7F8EC2D9C843.png" height="908" width="1454" />
    <div>（这里流程暂未搞懂）</div>
    <div><br /></div>
    <h2>磁盘存储</h2>
    <div>kafka采用文件追加的方式来写入消息，且不允许修改已写入的消息；</div>
    <div><br /></div>
    <div>页缓存：</div>
    <div>把磁盘中的数据缓存到内存中，把对磁盘的访问变成对内存的访问；</div>
    <div>当一个进程准备读取磁盘上的文件 内容时，操作系统会先查看待读取的数据所在的页( page ）是否在页缓存（ page cache ）中，如果存在（命中〉 则直接返回数据，从而避免了对物理磁盘的 I/O
        操作；如果没有命中，则操作系统会向磁盘发起读取请求并将读取的数据页存入页缓存，之后再将数据返回给进程 。</div>
    <div>kafka中大量使用的页缓存；</div>
    <div><br /></div>
    <div>零拷贝：通过DMA技术将文件在内核中进行复制；</div><img src="/kafka.resources/E4665FD7-199C-4FF6-BDB3-B5E87015F33C.png" height="738"
        width="840" />
    <div>Kafka使用了零拷贝技术；</div>
    <div><br /></div>
    <div>磁盘IO流程：</div><img src="/kafka.resources/91FEB7ED-21C6-412E-A7A8-A50146F9948E.png" height="1518" width="1046" />
    <div><br /></div>
    <div>linux I/O调度策略：</div>
    <ol>
        <li>
            <div>NOOP：（No operation）实现了最简单的FIFO队列，所有I/O请求大致按照先来后到的顺序操作；</div>
        </li>
        <li>
            <div>CFQ：（completely fair queuing）按照I/O请求的地址进行排序，而不是按照先来后到的顺序进行响应；（以尽量少的磁盘旋转次数来满足尽可能多的I/O请求）</div>
        </li>
        <li>
            <div>
                DEADLINE：在CFQ的基础上，解决了I/O请求饿死的情况，除了CFQ本身具有的I/O排序队列，还为读I/O和写I/O提供了FIFO队列，读FIFO队列最大等待时间是500ms，写FIFO队列最大等待时间是5s； 
                                                             （优先级：FIFO(read) &gt; FIFO(write) &gt; CFQ）</div>
        </li>
        <li>
            <div>ANTICIPATORY：（适用于连续I/O请求）在DEADLINE的基础上，为每个读 I/O 都设置了 6ms 的等待时间窗口 。 如果在 6ms 内 OS 收到了相邻位置的读 νo 请求，就可以立即满足
                。 ANTICIPATORY 算法通过增加等待时间来获得更高的性能，假设一个块设备只有一个物理查找磁头（例如一个单独的 SATA
                硬盘），将多个随机的小写入流合并成一个大写入流（相当于将随机读写变顺序读写），通过这个原理来使用读取／写入的延时换取最大的读取／写入吞吐量</div>
        </li>
    </ol>
    <div><br /></div>
    <div><br /></div>
    <h1>深入服务端</h1>
    <h2>协议相关</h2>
    <div>请求体：kafka有43种协议，每种协议的request有相同的请求头RequestHeader</div><img
        src="/kafka.resources/AC402EEF-FEDC-48AF-8097-F5C19C60B58F.png" height="288" width="1474" />
    <div>协议请求头：</div><img src="/kafka.resources/60ED3748-A650-4B61-B7EF-E1E6A25A0F95.png" height="464" width="1846" />
    <div>响应体：</div><img src="/kafka.resources/C5B6B40E-6A0B-449E-91D5-EF7C363B7269.png" height="284" width="1466" />
    <div><br /></div>
    <h3>发送消息协议</h3>
    <div>ProduceRequest结构：</div><img src="/kafka.resources/D45E7865-2467-446A-A1EF-3128412F7159.png" height="896"
        width="1586" /><img src="/kafka.resources/DACFA44E-6D8B-4A38-87AA-563260FDA15E.png" height="902" width="1836" />
    <div><br /></div>
    <div>ProduceResponse结构：</div><img src="/kafka.resources/1E883562-5F79-4D36-8CAF-22E2CA528ABB.png" height="882"
        width="1474" />
    <div><br /></div><img src="/kafka.resources/3B731EA8-8E1C-402F-94BA-C6AC914183C7.png" height="1048" width="1838" />
    <div><br /></div>
    <h3>拉取消息协议</h3>
    <div>ResponseRequest：</div><img src="/kafka.resources/A8C77FD7-5E51-4B28-B565-85F76E3E257F.png" height="1122"
        width="1544" />
    <div><br /></div><img src="/kafka.resources/D9052EEF-139D-44C3-BABF-DE4CE7873C23.png" height="576"
        width="1474" /><img src="/kafka.resources/59FFB4C0-B2F0-408B-8AF2-1155C6E2538E.png" height="1478"
        width="1478" />
    <div><br /></div>
    <div>session_id和epoch确定一条拉取链路的fetch session，session建立或变更时发送全量FetchRequest；</div>
    <div>当session稳定时会发送增量式的FetchRequest请求；（里面的topic是空，因为topic域的内容已经缓存）</div>
    <div><br /></div>
    <div>FetchResponse结构：</div><img src="/kafka.resources/597597FF-B2A4-4826-9A27-78E32CF118B0.png" height="760"
        width="1220" />
    <div><br /></div>
    <div>综上，kafka消息的写入和拉取都是细化到每一个分区层级的；</div>
    <div>为了应对有大量分区副本需要及时同步的场景，kafka引入了session_id，将partition 、 fetch_offset 、log_start_ offset</div>
    <p>和max_bytes这几个固定的字段缓存起来；</p>
    <p><br /></p>
    <div><br /></div>
    <h2>时间轮</h2><img src="/kafka.resources/2B9C097F-C564-4CC7-BFE1-42604091DEF5.png" height="534" width="968" />
    <div>时间轮中的每个槽下面挂着一个双向链表TimerTaskList，当时间到达时触发链表中对应的事件；</div><img
        src="/kafka.resources/BF2EB8BB-7ECB-4E67-9DF9-B15454FA93F0.png" height="970" width="1080" />
    <div>如插入一个450ms的定时任务，先查到第三层的，400ms到了之后，再将该事件降级插入到第二层中，当440ms到达之后，再降级插入到第一层时间轮中；</div>
    <div><br /></div>
    <div>Kafka使用时间轮实现定时任务的插入和删除，使用DelayQueue来实现时间的推进；</div>
    <div>原因：</div>
    <p>试想一下， DelayQueue 中的第一个超时任务列表的 expiration 为 200ms ， 第二个超时任务为 840ms ， 这里获取 DelayQueue 的 队头只需要O(1 ）的时间 复杂度（获取之后
        DelayQueue 内部才会再次切换出新的队头）。如果采用每秒定时推进，那么获取第一个超时的任务列表时执行的 200 次推进中有 199 次属于“空推进”，而获取第二个超时任务时又需要执行 639 次“空推进” ，
        这样会无故空耗机器的性能资源，这里采用 DelayQueue 来辅助以少量空间换时间 ，从而做到了 “精准推进” 。 Kafka 中的定时器真可谓“知人善用” ， 用 TimjngWheel
        做最擅长的任务添加和删除操作，而用 DelayQueue 做最擅长的时间推进工作，两者相辅相成 。</p>
    <p><br /></p>
    <div><br /></div>
    <h2>延时操作</h2><img src="/kafka.resources/C7B2FDB9-A503-4469-A849-E0F451B5C373.png" height="692" width="1102" />
    <div>延时操作由超时事件或外部事件触发：</div>
    <ol>
        <li>
            <div>超时事件：等到超时时间之后触发第二次读取日志的操作；</div>
        </li>
        <li>
            <div>外部事件：</div>
        </li>
        <ol>
            <li>
                <div>follower副本延时拉取：外部事件是消息追加到了leader副本的本地日志文件中；</div>
            </li>
            <li>
                <div>消费者客户端的延时拉取：外部事件是HW的增长；</div>
            </li>
        </ol>
    </ol>
    <div><br /></div>
    <div><br /></div>
    <h2>控制器</h2>
    <div>kafka中会将一个broker选举成控制器，负责leader的重新选取和当ISR集合发生变化时通知所有broker更新元数据；</div><img
        src="/kafka.resources/1289D6B7-424E-4A18-8ABA-296A4EFB650A.png" height="1008" width="940" />
    <div>
        kafka的控制器使用单线程基于事件队列的模型，将每个事件都做一层封装，然后按照事件发生的先后顺序插入到LinkedBlockingQueue中，最后用一个专用的线程（ControllerEventThread）按照FIFO的原则顺序处理各个事件，这样不需要锁机制就可以在多线程间维护线程安全；
    </div>
    <div><br /></div>
    <div><br /></div>
    <h2>优雅的关闭</h2>
    <div>一般cpu的内存管理单元MMU的PAGE_SIZE是4096，也就是说ps命令的输出字符串长度限制在4096内；</div>
    <div><br /></div>
    <ol>
        <li>
            <div>获取 Kafka 的服务进程号PIDS。可以使用 Java 中的 jps 命令或使用 Linux 系统中的ps 命令来查看；</div>
        </li>
        <li>
            <div>使用 kill - s TERM $PIDS 或 kill -15 $PIDS 的方式来关闭进程，注意千万不要使用 kill -9的方式;</div>
        </li>
    </ol>
    <div><br /></div>
    <div>controlledShutdown动作执行步骤：</div><img src="/kafka.resources/E92F897D-7DEF-4312-B0C5-7F66699B35F9.png"
        height="734" width="1250" />
    <div>优点：</div>
    <ol>
        <li>
            <div>可以让消息完全同步到磁盘上，在下次服务上线时不必进行日志恢复的操作；</div>
        </li>
        <li>
            <div>关闭服务前会对其上的leader副本进行迁移，减少分区不可用时间；</div>
        </li>
    </ol>
    <div><br /></div>
    <div><br /></div>
    <h2>分区leader的选举</h2>
    <div>时机：分区上线、分区下线</div>
    <div>策略：按照AR集合中副本的顺序查找第一个存活的副本，并且这个副本在ISR集合中；</div>
    <div><br /></div>
    <div><br /></div><img src="/kafka.resources/4E3CEAFF-E268-45F3-87A6-4791D92FF7F7.png" height="454" width="1004" />
    <div>客户端连接kafka集群流程：</div>
    <ol>
        <li>
            <div>客户端 KafkaProducer2 与 bootstrap.servers 参数所指定的 Server 连接，井发送MetadataRequest 请求来获取集群的元数据信息 ；</div>
        </li>
        <li>
            <div>Server 在收到 MetadataRequest 请求之后，返回 MetadataResponse给KafkaProducer2,在MetadataResponse 中包含了集群的元数据信息；
            </div>
        </li>
        <li>
            <div>客户端 KafkaProducer2 收到的 MetadataResponse 之后解析出其中包含的集群元数据信息，然后与集群中的各个节点建立连接，之后就可以发送消息了。</div>
        </li>
    </ol>
    <div><br /></div>
    <div><br /></div>
    <div><br /></div>
    <h1>深入客户端</h1>
    <div><br /></div>
    <div>消费者客户端与订阅主题之间的分区分配策略：</div>
    <ul>
        <li>
            <div>RangeAssigner：按照消费者总数和分区总数进行整除运算来获得一个跨度，然后将分区按照跨度进行平均分配；</div>
        </li>
    </ul>
    <div>n=分区数/消费者数量</div>
    <div>m=分区数%消费者数量</div>
    <div>前m个消费者分配n+1个分区，后面的（消费者数量-m）个消费者每个分配n个分区</div>
    <div><br /></div>
    <ul>
        <li>
            <div>RoundRobinAssignor：将消费者组内所有消费者及消费者订阅的所有主题的分区按照字典序排序，然后通过轮询的方式将分区逐个分配给各个消费者</div>
        </li>
    </ul>
    <div>若同一个消费者组内的消费者订阅的信息是不同的，那么执行分区的时候就不是轮询分配，可能会导致分区分配不均匀</div>
    <div><br /></div>
    <ul>
        <li>
            <div>StickyAssignor：（1）分区的分配要尽可能均匀；（2）分区的分配尽可能与上次分配保持相同；（1）&gt;（2）</div>
        </li>
    </ul>
    <div><br /></div>
    <ul>
        <li>
            <div>自定义分区分配策略：实现org.apache.kafka.clients.consumer.internals.PartitionAssignor接口</div>
        </li>
    </ul>
    <div>可以通过自定义分区策略实现同一个消费者组内的任意消费者都可以消费订阅主题的所有分区，实现“组内广播”功能，但可能出现消息丢失或消息重复消费的情况，需要配合数据库，将所有消费者的消费偏移存储起来；</div>
    <div><br /></div>
    <h2>消费者协调器、组协调器</h2>
    <div>GroupCoorinator：服务端用于管理消费者组的组件</div>
    <div>ConsumerCoorinator：客户端中负责与GroupCoorinator交互的组件</div>
    <div><br /></div>
    <div>触发再均衡的操作：</div>
    <ol>
        <li>
            <div>有新的消费者加入消费者组；</div>
        </li>
        <li>
            <div>有消费者宕机下线；</div>
        </li>
        <li>
            <div>有消费者主动退出消费者组；</div>
        </li>
        <li>
            <div>消费者组所对应的GroupCoorinator节点发生了变更；</div>
        </li>
        <li>
            <div>消费者组所订阅的任一主题或者分区的分区数量发生变化；</div>
        </li>
    </ol>
    <div><br /></div>
    <div>第一阶段：</div>
    <div>
        消费者需要知道它所属的消费者组对应的GroupCoorinator所在的broker，并创建与该GroupCoorinator相互通信的网络连接；（若消费者保存了相关信息则可以直接进入第二阶段，否则需要发送请求FindCoorinatorRequest来查找，发送到负载最小的节点）
    </div>
    <div><br /></div>
    <div><br /></div>
    <div><br /></div><img src="/kafka.resources/E1285B6B-0392-474C-9340-7A9F89BDF70A.png" height="512" width="1522" />
    <div>coordinator_key是消费者组的名称，即groupID</div>
    <div><br /></div>
    <div>第二阶段：</div>
    <div>消费者会向GroupCoordinator发送JoinGroupRequest请求；</div>
    <table
        style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:963px;"
        width="963px">
        <colgroup>
            <col style="width: 170px;" />
            <col style="width: 793px;" />
        </colgroup>
        <tbody>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>JoinGroupRequest</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/15456D72-73D8-4E8D-8593-DC5FFE792979.png" height="728" width="1502" />
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>JoinGroupResponse</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/D643154A-56A3-44B4-A8F2-39CFD22B1B57.png" height="716" width="1476" />
                </td>
            </tr>
        </tbody>
    </table>
    <table
        style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:756px;"
        width="756px">
        <colgroup>
            <col style="width: 86px;" />
            <col style="width: 352px;" />
            <col style="width: 318px;" />
        </colgroup>
        <tbody>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>步骤</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>操作</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>备注</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>第一步</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/947F429F-1571-42C7-BDBE-6476E1EA3582.png" height="664" width="852" />
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div><br /></div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>第二步</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/2F552836-FFED-4E93-8FCF-A9A4169EB1F1.png" height="674" width="830" />
                    <div><br /></div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>消费者leader是随机选取的；</div>
                    <div><br /></div>
                    <p>根据各个消费者呈报的分配策略，选取出消费者支持最多的策略作为分区分配策略；</p>
                    <div><br /></div>
                    <div>GroupCoordinator传给leader的members中保存各个成员的信息，member_metadata中保存了确定的</div>
                    <div>protocol_name-&gt;protocol_metadata（分配策略）</div>
                    <div><br /></div>
                </td>
            </tr>
        </tbody>
    </table>
    <div>protocol_metadata：</div><img src="/kafka.resources/6D354BCE-3EC0-4EAA-81DF-F9778EB673A4.png" height="162"
        width="796" />
    <div><br /></div>
    <div><br /></div>
    <div>第三阶段</div>
    <div>leader消费者根据在第二阶段中选举出来的分区分配策略来实施具体的分区分配，leader通过GroupCoordinator这个“中间人”来分发选定的分区策略；</div><img
        src="/kafka.resources/44D80C40-9219-4288-B1D6-7B8C3DB16AC3.png" height="596" width="880" />
    <div><br /></div>
    <div><br /></div>
    <div>第四阶段</div>
    <div>正常消费之前，消费者还需要确定拉取消息的起始位置；</div>
    <div><br /></div>
    <h2>位移提交</h2>
    <div>位移提交的内容最终会保存在kafka的内部主题__consumer_offsets中，客户端的位移提交是通过请求OffsetCommitRequest实现的</div>
    <table
        style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:983px;"
        width="983px">
        <colgroup>
            <col style="width: 190px;" />
            <col style="width: 793px;" />
        </colgroup>
        <tbody>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>请求</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>结构</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>OffsetCommitRequest</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/0014E621-7E9C-4C7D-A9AE-C7F388DC73B5.png" height="904" width="1496" />
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>OffsetCommitResponse</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/2A5BF6C3-68BE-4F4B-BA60-0A31FD3343D1.png" height="918" width="1578" />
                </td>
            </tr>
        </tbody>
    </table>
    <div>最终提交的位移信息会按照消息的形势发送到__consumer_offsets，消息格式：</div>
    <table
        style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:585px;"
        width="585px">
        <colgroup>
            <col style="width: 82px;" />
            <col style="width: 503px;" />
        </colgroup>
        <tbody>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>key</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/508B4978-EB7C-4285-A1BB-D2E0684DCF43.png" height="474" width="466" />
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>value</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/68BB3CF5-4C83-4F98-9297-21B58AE6A84C.png" height="550" width="470" />
                </td>
            </tr>
        </tbody>
    </table>
    <div><br /></div>
    <div><br /></div>
    <h2>事务</h2>
    <ul>
        <li>
            <div>至少一次</div>
        </li>
        <li>
            <div>只多一次</div>
        </li>
        <li>
            <div>恰好一次</div>
        </li>
    </ul>
    <div><br /></div>
    <h3>幂等</h3>
    <div>PID：producer id</div>
    <div>sequence number：序列号</div>
    <div>对于每个PID，消息发送到的每一个分区都会被分配一个序列号，生产者每发送一条消息就会将&lt;PID，分区&gt;对应的序列号的值加一；</div>
    <div>broker 端会在内存中为每一对＜PID ，分区＞维护一个序列号。对于收到的每一条消息，只有当它的序列号的值（ SN new ）比 broker 端中维护的对应的序列号的值（ SN old ）大 1 （ 即 SN
        new= SN old + 1 ）时， broker 才会接收它 。 如果 SN new&lt; SN old + 1， 那么说明消息被重复写入 ，broker 可以直接将其丢弃 ；</div>
    <div>如果 SN new&gt; SN old + 1，那么说明中间有数据尚未写入， 出现了乱序 ，暗示可能有消息丢失，对应的生产者会抛出 OutOfOrderSequenceException异常；</div>
    <div><br /></div>
    <div><br /></div>
    <h3>事务</h3>
    <div>事务通过应用程序提供唯一的transactionalId来支持，transactionalId通过客户端参数transactional.id来显式设置；</div>
    <div>transactionalId与PID一一对应，PID由kafka内部分配，transactionalId由用户显式设置；</div>
    <div><br /></div>
    <div>生产者角度分析事务：</div>
    <ol>
        <li>
            <div>保证跨生产者会话的消息幂等发布：具有相同transactionalId的新生产者实例被创建且工作的时候，旧的具有相同transactionalId的生产者实例不再工作；</div>
        </li>
        <li>
            <div>保证跨生产者会话的事务恢复：当某个生产者实例宕机后，新的生产者实例可以保证任何未完成的事务要么提交要么终止；</div>
        </li>
    </ol>
    <div><br /></div>
    <div>消费者角度分析事务：</div>
    <div>事务能保证的语义相对较弱，因为消息可能被清理或人为的跳过；</div>
    <div><br /></div>
    <div>消费端参数isolation.level：</div>
    <ul>
        <li>
            <div>read_uncommitted：消费端应用可以消费到未提交的事务；</div>
        </li>
        <li>
            <div>read_committed：消费端应用不可以消费到未提交的事务；</div>
        </li>
    </ul>
    <div><br /></div>
    <div>ControlBatch：控制消息，专门标志一个事务的结束（COMMIT/ABORT）</div><img
        src="/kafka.resources/EB0040F5-EDBE-4533-8881-12AE79471432.png" height="490" width="1158" />
    <div><br /></div>
    <div>消费-转换-生产模型：</div><img src="/kafka.resources/1A6664F9-7522-4CE7-9E08-C49AEB8FDC7A.png" height="687"
        width="796" />
    <div>一、</div>
    <div>寻找TransactionCoordinator节点</div>
    <div>二、</div>
    <div>
        向TransactionCoordinator节点初始化transactionalID，TransactionCoordinator会将transactionalID和PID的关系以消息的形势保存在主题__transaction_state中，&lt;transaction_id,PID&gt;
    </div>
    <div>三、</div>
    <div>开启事务</div>
    <div>四、</div>
    <div style="padding-left:40px;">
        4.1：发送请求AddPartitionsToTxnRequest，让TransactionCoordinator将&lt;transactionID,TopicPartition&gt;的对应关系存储在主题__transaction_state中；
    </div>
    <div style="padding-left:40px;">4.2：生产者发送消息；</div>
    <div style="padding-left:40px;">
        4.3：生产者发送offsets和groupID到TransactionCoordinator节点，TransactionCoordinator节点通过groupID推导出在__consumer_offsets中的分区，并将这个分区保存在__transaction_state中；
    </div>
    <div style="padding-left:40px;">
        4.4：生产者发送TxnOffsetCommitRequest请求给GroupCoordinator，将本次事务中的消费位移信息offsets存储到主题__consumer_offsets中；</div>
    <div>五、</div>
    <div>提交事务或终止事务</div>
    <div style="padding-left:40px;">5.1：将PREPARE_COMMIT或PREPARE_ABORT写入主题__transaction_state；</div>
    <div style="padding-left:40px;">5.2：通过WriteTxnMarkersRequest请求将COMMIT或ABORT写入用户所使用的普通主题__consumer_offsets；</div>
    <div style="padding-left:40px;">5.3：将COMPLETE_COMMIT或COMPLETE_ABORT信息写入内部主题__transaction_state；</div>
    <div><br /></div>
    <div><br /></div>
    <div><br /></div>
    <h1>可靠性探究</h1>
    <div><br /></div>
    <div>失效副本判定：</div><img src="/kafka.resources/A5075815-B672-40EC-8E02-44EE3D3B51A9.png" height="1018" width="1076" />
    <div>
        follower副本将leader副本LEO之前的日志全部同步时，认为该followeer副本追赶上了leader副本，更新lastCaughtUpTimeMs标识，并通过定时任务检测lastCaughtUpTimeMs是否大于参数leader.replica.lag.time.max.ms；
    </div>
    <div><br /></div>
    <div><br /></div>
    <h2>LEO与HW</h2>
    <table
        style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:756px;"
        width="756px">
        <colgroup>
            <col style="width: 319px;" />
            <col style="width: 437px;" />
        </colgroup>
        <tbody>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/80D1F293-4364-44CD-B943-A13771A31C61.png" height="372" width="692" />
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/F166D8D0-AAE0-4098-A7CF-7CC2B29C3743.png" height="378" width="700" />
                    <div><br /></div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>起始状态，follower向leader拉取消息，拉取请求中带有自身的LEO</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>leader返回给follower相应的消息，带有自身的HW</div>
                    <p>HW算法是比较自身的LEO和leader传来的HW，取较小值做HW</p>
                    <div><br /></div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/23468A3A-1669-4A32-AA51-12FC056D10B8.png" height="372" width="702" />
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/075CDCA7-4563-486B-A107-01867E07F042.png" height="370" width="712" />
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div><br /></div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>此时HW=3</div>
                </td>
            </tr>
        </tbody>
    </table>
    <div>对于LEO，leader记录所有节点的LEO，follower只记录自身的LEO；</div>
    <div>对于HW，每个节点都只记录自身的HW；</div>
    <div><br /></div>
    <div><br /></div>
    <h2>Leader Epoch</h2>
    <div>问题一：数据丢失</div>
    <table
        style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:760px;"
        width="760px">
        <colgroup>
            <col style="width: 406px;" />
            <col style="width: 354px;" />
        </colgroup>
        <tbody>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/A082B6CB-0D1D-4986-8E05-7A55819820E6.png" height="342" width="952" />
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>leader：B 两条消息、HW=2</div>
                    <p>follower：A 两条消息，HW=1</p>
                    <p>follower的HW从1更新到2需要拉取一次消息</p>
                    <div><br /></div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/7E67A6BB-4597-4BE7-B13F-A9003E3C31B9.png" height="300" width="942" />
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>在follower将HW从1更新到2期间A重启</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/8AEF19AF-B220-4DC5-9208-F4C4D59FDBEA.png" height="332" width="888" />
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>此时B宕机，这样A就选举成新的leader，但此时HW是1，消息m2就丢失了</div>
                </td>
            </tr>
        </tbody>
    </table>
    <div>问题二：数据不一致</div>
    <table
        style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:758px;"
        width="758px">
        <colgroup>
            <col style="width: 407px;" />
            <col style="width: 351px;" />
        </colgroup>
        <tbody>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/2D868310-F5BE-4277-972E-6826C50B50E8.png" height="320" width="920" />
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>leader：A </div>
                    <p>follower：B </p>
                    <p>此时A、B全部宕机</p>
                    <div><br /></div>
                    <div><br /></div>
                    <div><br /></div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/195E0AAC-7A66-4CFE-93E3-8A0A833980A3.png" height="328" width="922" />
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>B先上线，选取成新的leader</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/2BC60489-B899-49B4-BF63-C8E43F3ACA52.png" height="306" width="922" />
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>B收到新的消息m3，此时A上线，两者HW一致，到消息不一致</div>
                </td>
            </tr>
        </tbody>
    </table>
    <div><br /></div>
    <div>leader epoch：leader的纪元信息，每当leader变更一次，leader epoch的值就会加1</div>
    <div>StartOffset：当前leader epoch下写入的第一条消息的偏移量</div>
    <div><br /></div>
    <div>数据丢失解决：</div>
    <table
        style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:758px;"
        width="758px">
        <colgroup>
            <col style="width: 393px;" />
            <col style="width: 365px;" />
        </colgroup>
        <tbody>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/EBDD2262-7788-484B-94D1-493AD3559C6D.png" height="398" width="990" />
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div><br /></div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/DEA1C8E0-9487-48FC-B3AE-F7154E99892B.png" height="448" width="920" />
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>A重启时，会向leader请求，查找当前leader epoch对应的start offset，也就是leader epoch A对应的LEO</div>
                    <div><br /></div>
                    <div><br /></div>
                    <div><br /></div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/004100B7-94A0-40C5-AF8D-9CE932AB09E9.png" height="432" width="924" />
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>此时A收到2后发现与当前的LEO相同，也就不需要截断日志了</div>
                </td>
            </tr>
        </tbody>
    </table>
    <div><br /></div>
    <div>数据不一致解决：</div>
    <table
        style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:760px;"
        width="760px">
        <colgroup>
            <col style="width: 427px;" />
            <col style="width: 333px;" />
        </colgroup>
        <tbody>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/21027BB4-8135-4D84-B461-9841E1C3A278.png" height="368" width="892" />
                    <div><br /></div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div><br /></div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/09682687-C2BF-4312-B392-29B3B17FC765.png" height="378" width="912" />
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>B写入消息m3，将LEO和HW更新至2，此时LeaderEpoch已经从LE0增至LE1了</div>
                    <div><br /></div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <img src="/kafka.resources/09828C59-9815-4F77-A732-4C7500199C7B.png" height="480" width="928" />
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>A 恢复过来成为 follower 并向 B 发送 OffsetsForLeaderEpochRequest 请求，此时 A</div>
                    <p>的 LeaderEpoch 为 LEO 。 B 根据 LEO 查询到对应的 offset 为 1 并返回给 A, A 就截断日志并删除了消息 m2</p>
                </td>
            </tr>
        </tbody>
    </table>
    <div><br /></div>
    <div><br /></div>
    <div><br /></div>
    <h2>为何不支持读写分离</h2>
    <div>kafka只支持主写主读有以下几个优点：</div>
    <ul>
        <li>
            <div>简化代码逻辑，减少出错的可能；</div>
        </li>
        <li>
            <div>将负载粒度细化均摊，与主写从读相比，不仅负载效能更好，而且对用户可控；</div>
        </li>
        <li>
            <div>没有延时的影响；</div>
        </li>
        <li>
            <div>在副本稳定的情况下，不会出现数据不一致的情况；</div>
        </li>
    </ul>
    <div><br /></div>
    <div>kafka优秀的架构设计可以做到很大程度上的负载均衡，</div><img src="/kafka.resources/BE526A56-14E2-444B-AE8A-1B93DCB67B49.png"
        height="750" width="1180" />
    <table
        style="--en-fitwindow:false;border-left:1px solid #d9d9d9;border-top:1px solid #d9d9d9;border-collapse:collapse;width:588px;"
        width="588px">
        <colgroup>
            <col style="width: 215px;" />
            <col style="width: 373px;" />
        </colgroup>
        <tbody>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div><b>可能造成负载不均衡的情况</b></div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div><b>解决办法</b></div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>broker端的分区分配不均</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>主题创建的时候尽可能使分区分配均衡</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>生产者写入消息不均</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>主写从读也无法解决</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>消费者消费消息不均</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>主写从读也无法解决</div>
                </td>
            </tr>
            <tr>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>leader副本切换不均</div>
                </td>
                <td
                    style="--en-typeInfo:{&quot;type&quot;:&quot;text&quot;,&quot;data&quot;:{}};border-right:1px solid #d9d9d9;border-bottom:1px solid #d9d9d9;padding:10px;">
                    <div>优先副本选举</div>
                </td>
            </tr>
        </tbody>
    </table>
    <div><br /></div>
    <div>kafka的日志同步机制：</div>
    <p>ISR模型 &amp; （f+1）个副本数的配置</p>
    <div>在 Kafka 中动态维护着一个 ISR 集合，处于 ISR 集合内的节点保持与 leader 相同的高水位（HW），只有位列其中的副本才有资格被选为新的leader，写入消息时只有等到所有 ISR
        集合中的副本都确认收到之后才能被认为已经提交；</div>
    <div>一个kafka分区的f+1个副本能够容忍最大f个节点失败；</div>
    <div><br /></div>
    <div><br /></div>
    <div><br /></div>
</body>

</html></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">bank</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/05/16/kafka/">http://example.com/2023/05/16/kafka/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">bank blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mq/">mq</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/19/golang%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%A1%A8/" title="golang实现跳表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">golang实现跳表</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/16/golang%E6%8C%87%E9%92%88/" title="golang指针讨论"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">golang指针讨论</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">bank</div><div class="author-info__description">行至水穷处,坐看云起时</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.0.1.</span> <span class="toc-text">功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.0.2.</span> <span class="toc-text">基本概念：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">生产者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.0.1.</span> <span class="toc-text">生产逻辑需要具备的步骤：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.0.2.</span> <span class="toc-text">生产者客户端参数配置：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.0.3.</span> <span class="toc-text">消息发送：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.0.4.</span> <span class="toc-text">分区器：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.0.5.</span> <span class="toc-text">拦截器：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.1.</span> <span class="toc-text">原理分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.2.</span> <span class="toc-text">重要的生产者参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.1.</span> <span class="toc-text">消费逻辑需要具备的步骤：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.2.</span> <span class="toc-text">消息消费</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.3.</span> <span class="toc-text">消息提交</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.3.1.</span> <span class="toc-text">自动提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.3.2.</span> <span class="toc-text">手动提交</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.4.</span> <span class="toc-text">指定位移消费</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.5.</span> <span class="toc-text">再均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.6.</span> <span class="toc-text">消费者拦截器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.7.</span> <span class="toc-text">多线程实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.8.</span> <span class="toc-text">重要的消费者参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">主题与分区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">4.1.</span> <span class="toc-text">主题相关命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">4.2.</span> <span class="toc-text">分区、副本相关内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.2.1.</span> <span class="toc-text">优先副本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.2.2.</span> <span class="toc-text">分区重分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.2.3.</span> <span class="toc-text">复制限流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.2.4.</span> <span class="toc-text">修改副本因子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.2.5.</span> <span class="toc-text">性能相关</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">日志存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.1.</span> <span class="toc-text">日志文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.1.1.</span> <span class="toc-text">V0版本日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.1.2.</span> <span class="toc-text">v1版本日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.1.3.</span> <span class="toc-text">消息压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.1.4.</span> <span class="toc-text">
    v2版本日志
    
        
            
            
            
        
        
            
                
                    
                
                
                    字段名称
                
                
                    字段含义
                
            
            
                
                    length
                
                
                    消息总长度
                
            
            
                
                    attributes
                
                
                    弃用，占据1B的大小，以备未来的格式扩展
                
            
            
                
                    timestamp delta
                
                
                    时间戳增量，保存与RecordBatch的其实时间戳的差值
                
            
            
                
                    offset delta
                
                
                    位移增量，保存与RecordBatch起始位移的差值
                
            
            
                
                    headers
                
                
                    用来支持应用级别的扩展
                
            
            
                
                    first offset
                
                
                    当前RecordBatch的起始位移
                
            
            
                
                    length
                
                
                    从partition leader epoch字段开始到末尾的长度
                
            
            
                
                    magic
                
                
                    消息格式的版本号
                
            
            
                
                    attributes
                
                
                    消息属性，注意这里占用了两个字节 。 低 3 位表示压缩格式，可以参考v0和v1；第 4 位表示时间戳类型；第 5 位表示此 RecordBatch 是否处于事务中，0表示非事务，1表示事务
                        。第6位表示是否是控制消息 （ ControlBatch ），0表示非控制消息，而1表示是控制消息，控制消息用来支持事务功能
                
            
            
                
                    last offset delta
                
                
                    RecordBatch中最后一个Record的offset与first offset的差值
                
            
            
                
                    first timestamp
                
                
                    RecordBatch中第一条Record的时间戳
                
            
            
                
                    max timestamp
                
                
                    RecordBatch中最大的时间戳
                
            
            
                
                    producer id
                
                
                    PID用来支持幂等事务
                
            
            
                
                    producer epoch
                
                
                    用来支持幂等事务
                
            
            
                
                    first sequence
                
                
                    用来支持幂等事务
                
            
            
                
                    records count
                
                
                    RecordBatch中Record的个数
                
            
        
    
    
    日志索引
    kafka使用稀疏索引，并通过MappedByteBuffer将索引文件映射到内存中，偏移量索引文件和时间戳索引文件都是严格递增的，在查找时使用二分查找；
    
    日志分段文件切分条件：
    
        
            当前日志分段文件的大小超过了broker端参数log.segment.bytes配置的值。log.segment.bytes参数的默认值为 1073741824 ，即 1GB；
        
        
            当前日志分段中消息的最大时间戳与当前系统的时间戳的差值大于 log.roll .ms或 log.roll.hours 参数配置的值。如果同时配置了 log.roll.ms 和 log.roll.hours
                参数，那么 log.roll.ms 的优先级高 。 默认情况下，只配置了 log.roll.hours 参数，其值为 168,即 7 天；
        
        
            偏移量索引文件或时间戳索引文件的大小达到 broker 端参数log.index.size .max.bytes配置的值。log.index.size .max.bytes的默认值为 10485760 ，即
                l0MB 
        
        
            追加的消息的偏移量与当前日志分段的偏移量之间的差值大于 Integr.MAX_VALUE,即要追加的消息的偏移量不能转变为相对偏移量（ offset - baseOffset &gt; 
                Integr.MAX_VALUE）
        
    
    
    偏移量索引
    
        
            relativeOffset：相对偏移量，表示消息相对于baseOffset的偏移量，占用4个字节，当前索引文件的文件名即为baseOffset的值；
        
        
            position：物理地址，也就是消息在日志分段文件中对应的物理位置，占用4个字节；
        
    
    索引偏移量示意图：
    
    时间戳索引
    
        
            timestamp：当前日志分段的最大时间戳；
        
        
            relativeOffset：时间戳对应的消息的相对偏移量；
        
    
    时间戳索引示意图：
    
    
    
    日志清理
    两种方式：日志删除、日志压缩
    日志删除
    日志分段的保留策略：
    
        
            基于时间
        
        
            基于日志大小
        
        
            基于日志起始偏移量
        
    
    
    基于时间
    查询日志分段文件所对应的时间戳索引文件，查找时间戳索引文件中最后一条索引项，获取日志分段文件的最大时间戳的值，比较这个值与log.retention.ms等过期时间设定值；
    删除步骤：
    
        
            先切分出一个新的日志分段作为activeSegment；（当所有日志分段都过期时）
        
        
            删除日志分段时，首先从log对象中所维护日志分段的跳跃表中移出待删除的日志分段；
        
        
            然后将日志分段对应的所有文件添加“.delete”后缀；
        
        
            最后交给一个一“delete-file”命名的延迟任务来删除这些文件；
        
    
    
    
    基于日志大小
    log.retention.bytes配置log中所有文件都总大小，默认-1，即无穷大；
    log.segment.bytes配置单个日志文件大小，默认是1GB；
    
    基于日志起始偏移量
    判断依据：某日志分段的下一日志分段的其实偏移量baseOffset是否小于等于logStartOffset，若是，则可以删除此日志分段；
    
    日志压缩
    （这里流程暂未搞懂）
    
    磁盘存储
    kafka采用文件追加的方式来写入消息，且不允许修改已写入的消息；
    
    页缓存：
    把磁盘中的数据缓存到内存中，把对磁盘的访问变成对内存的访问；
    当一个进程准备读取磁盘上的文件 内容时，操作系统会先查看待读取的数据所在的页( page ）是否在页缓存（ page cache ）中，如果存在（命中〉 则直接返回数据，从而避免了对物理磁盘的 I&#x2F;O
        操作；如果没有命中，则操作系统会向磁盘发起读取请求并将读取的数据页存入页缓存，之后再将数据返回给进程 。
    kafka中大量使用的页缓存；
    
    零拷贝：通过DMA技术将文件在内核中进行复制；
    Kafka使用了零拷贝技术；
    
    磁盘IO流程：
    
    linux I&#x2F;O调度策略：
    
        
            NOOP：（No operation）实现了最简单的FIFO队列，所有I&#x2F;O请求大致按照先来后到的顺序操作；
        
        
            CFQ：（completely fair queuing）按照I&#x2F;O请求的地址进行排序，而不是按照先来后到的顺序进行响应；（以尽量少的磁盘旋转次数来满足尽可能多的I&#x2F;O请求）
        
        
            
                DEADLINE：在CFQ的基础上，解决了I&#x2F;O请求饿死的情况，除了CFQ本身具有的I&#x2F;O排序队列，还为读I&#x2F;O和写I&#x2F;O提供了FIFO队列，读FIFO队列最大等待时间是500ms，写FIFO队列最大等待时间是5s； 
                                                             （优先级：FIFO(read) &gt; FIFO(write) &gt; CFQ）
        
        
            ANTICIPATORY：（适用于连续I&#x2F;O请求）在DEADLINE的基础上，为每个读 I&#x2F;O 都设置了 6ms 的等待时间窗口 。 如果在 6ms 内 OS 收到了相邻位置的读 νo 请求，就可以立即满足
                。 ANTICIPATORY 算法通过增加等待时间来获得更高的性能，假设一个块设备只有一个物理查找磁头（例如一个单独的 SATA
                硬盘），将多个随机的小写入流合并成一个大写入流（相当于将随机读写变顺序读写），通过这个原理来使用读取／写入的延时换取最大的读取／写入吞吐量
        
    
    
    
    深入服务端
    协议相关
    请求体：kafka有43种协议，每种协议的request有相同的请求头RequestHeader
    协议请求头：
    响应体：
    
    发送消息协议
    ProduceRequest结构：
    
    ProduceResponse结构：
    
    
    拉取消息协议
    ResponseRequest：
    
    
    session_id和epoch确定一条拉取链路的fetch session，session建立或变更时发送全量FetchRequest；
    当session稳定时会发送增量式的FetchRequest请求；（里面的topic是空，因为topic域的内容已经缓存）
    
    FetchResponse结构：
    
    综上，kafka消息的写入和拉取都是细化到每一个分区层级的；
    为了应对有大量分区副本需要及时同步的场景，kafka引入了session_id，将partition 、 fetch_offset 、log_start_ offset
    和max_bytes这几个固定的字段缓存起来；
    
    
    时间轮
    时间轮中的每个槽下面挂着一个双向链表TimerTaskList，当时间到达时触发链表中对应的事件；
    如插入一个450ms的定时任务，先查到第三层的，400ms到了之后，再将该事件降级插入到第二层中，当440ms到达之后，再降级插入到第一层时间轮中；
    
    Kafka使用时间轮实现定时任务的插入和删除，使用DelayQueue来实现时间的推进；
    原因：
    试想一下， DelayQueue 中的第一个超时任务列表的 expiration 为 200ms ， 第二个超时任务为 840ms ， 这里获取 DelayQueue 的 队头只需要O(1 ）的时间 复杂度（获取之后
        DelayQueue 内部才会再次切换出新的队头）。如果采用每秒定时推进，那么获取第一个超时的任务列表时执行的 200 次推进中有 199 次属于“空推进”，而获取第二个超时任务时又需要执行 639 次“空推进” ，
        这样会无故空耗机器的性能资源，这里采用 DelayQueue 来辅助以少量空间换时间 ，从而做到了 “精准推进” 。 Kafka 中的定时器真可谓“知人善用” ， 用 TimjngWheel
        做最擅长的任务添加和删除操作，而用 DelayQueue 做最擅长的时间推进工作，两者相辅相成 。
    
    
    延时操作
    延时操作由超时事件或外部事件触发：
    
        
            超时事件：等到超时时间之后触发第二次读取日志的操作；
        
        
            外部事件：
        
        
            
                follower副本延时拉取：外部事件是消息追加到了leader副本的本地日志文件中；
            
            
                消费者客户端的延时拉取：外部事件是HW的增长；
            
        
    
    
    
    控制器
    kafka中会将一个broker选举成控制器，负责leader的重新选取和当ISR集合发生变化时通知所有broker更新元数据；
    
        kafka的控制器使用单线程基于事件队列的模型，将每个事件都做一层封装，然后按照事件发生的先后顺序插入到LinkedBlockingQueue中，最后用一个专用的线程（ControllerEventThread）按照FIFO的原则顺序处理各个事件，这样不需要锁机制就可以在多线程间维护线程安全；
    
    
    
    优雅的关闭
    一般cpu的内存管理单元MMU的PAGE_SIZE是4096，也就是说ps命令的输出字符串长度限制在4096内；
    
    
        
            获取 Kafka 的服务进程号PIDS。可以使用 Java 中的 jps 命令或使用 Linux 系统中的ps 命令来查看；
        
        
            使用 kill - s TERM $PIDS 或 kill -15 $PIDS 的方式来关闭进程，注意千万不要使用 kill -9的方式;
        
    
    
    controlledShutdown动作执行步骤：
    优点：
    
        
            可以让消息完全同步到磁盘上，在下次服务上线时不必进行日志恢复的操作；
        
        
            关闭服务前会对其上的leader副本进行迁移，减少分区不可用时间；
        
    
    
    
    分区leader的选举
    时机：分区上线、分区下线
    策略：按照AR集合中副本的顺序查找第一个存活的副本，并且这个副本在ISR集合中；
    
    
    客户端连接kafka集群流程：
    
        
            客户端 KafkaProducer2 与 bootstrap.servers 参数所指定的 Server 连接，井发送MetadataRequest 请求来获取集群的元数据信息 ；
        
        
            Server 在收到 MetadataRequest 请求之后，返回 MetadataResponse给KafkaProducer2,在MetadataResponse 中包含了集群的元数据信息；
            
        
        
            客户端 KafkaProducer2 收到的 MetadataResponse 之后解析出其中包含的集群元数据信息，然后与集群中的各个节点建立连接，之后就可以发送消息了。
        
    
    
    
    
    深入客户端
    
    消费者客户端与订阅主题之间的分区分配策略：
    
        
            RangeAssigner：按照消费者总数和分区总数进行整除运算来获得一个跨度，然后将分区按照跨度进行平均分配；
        
    
    n&#x3D;分区数&#x2F;消费者数量
    m&#x3D;分区数%消费者数量
    前m个消费者分配n+1个分区，后面的（消费者数量-m）个消费者每个分配n个分区
    
    
        
            RoundRobinAssignor：将消费者组内所有消费者及消费者订阅的所有主题的分区按照字典序排序，然后通过轮询的方式将分区逐个分配给各个消费者
        
    
    若同一个消费者组内的消费者订阅的信息是不同的，那么执行分区的时候就不是轮询分配，可能会导致分区分配不均匀
    
    
        
            StickyAssignor：（1）分区的分配要尽可能均匀；（2）分区的分配尽可能与上次分配保持相同；（1）&gt;（2）
        
    
    
    
        
            自定义分区分配策略：实现org.apache.kafka.clients.consumer.internals.PartitionAssignor接口
        
    
    可以通过自定义分区策略实现同一个消费者组内的任意消费者都可以消费订阅主题的所有分区，实现“组内广播”功能，但可能出现消息丢失或消息重复消费的情况，需要配合数据库，将所有消费者的消费偏移存储起来；
    
    消费者协调器、组协调器
    GroupCoorinator：服务端用于管理消费者组的组件
    ConsumerCoorinator：客户端中负责与GroupCoorinator交互的组件
    
    触发再均衡的操作：
    
        
            有新的消费者加入消费者组；
        
        
            有消费者宕机下线；
        
        
            有消费者主动退出消费者组；
        
        
            消费者组所对应的GroupCoorinator节点发生了变更；
        
        
            消费者组所订阅的任一主题或者分区的分区数量发生变化；
        
    
    
    第一阶段：
    
        消费者需要知道它所属的消费者组对应的GroupCoorinator所在的broker，并创建与该GroupCoorinator相互通信的网络连接；（若消费者保存了相关信息则可以直接进入第二阶段，否则需要发送请求FindCoorinatorRequest来查找，发送到负载最小的节点）
    
    
    
    
    coordinator_key是消费者组的名称，即groupID
    
    第二阶段：
    消费者会向GroupCoordinator发送JoinGroupRequest请求；
    
        
            
            
        
        
            
                
                    JoinGroupRequest
                
                
                    
                
            
            
                
                    JoinGroupResponse
                
                
                    
                
            
        
    
    
        
            
            
            
        
        
            
                
                    步骤
                
                
                    操作
                
                
                    备注
                
            
            
                
                    第一步
                
                
                    
                
                
                    
                
            
            
                
                    第二步
                
                
                    
                    
                
                
                    消费者leader是随机选取的；
                    
                    根据各个消费者呈报的分配策略，选取出消费者支持最多的策略作为分区分配策略；
                    
                    GroupCoordinator传给leader的members中保存各个成员的信息，member_metadata中保存了确定的
                    protocol_name-&gt;protocol_metadata（分配策略）
                    
                
            
        
    
    protocol_metadata：
    
    
    第三阶段
    leader消费者根据在第二阶段中选举出来的分区分配策略来实施具体的分区分配，leader通过GroupCoordinator这个“中间人”来分发选定的分区策略；
    
    
    第四阶段
    正常消费之前，消费者还需要确定拉取消息的起始位置；
    
    位移提交
    位移提交的内容最终会保存在kafka的内部主题__consumer_offsets中，客户端的位移提交是通过请求OffsetCommitRequest实现的
    
        
            
            
        
        
            
                
                    请求
                
                
                    结构
                
            
            
                
                    OffsetCommitRequest
                
                
                    
                
            
            
                
                    OffsetCommitResponse
                
                
                    
                
            
        
    
    最终提交的位移信息会按照消息的形势发送到__consumer_offsets，消息格式：
    
        
            
            
        
        
            
                
                    key
                
                
                    
                
            
            
                
                    value
                
                
                    
                
            
        
    
    
    
    事务
    
        
            至少一次
        
        
            只多一次
        
        
            恰好一次
        
    
    
    幂等
    PID：producer id
    sequence number：序列号
    对于每个PID，消息发送到的每一个分区都会被分配一个序列号，生产者每发送一条消息就会将&lt;PID，分区&gt;对应的序列号的值加一；
    broker 端会在内存中为每一对＜PID ，分区＞维护一个序列号。对于收到的每一条消息，只有当它的序列号的值（ SN new ）比 broker 端中维护的对应的序列号的值（ SN old ）大 1 （ 即 SN
        new&#x3D; SN old + 1 ）时， broker 才会接收它 。 如果 SN new&lt; SN old + 1， 那么说明消息被重复写入 ，broker 可以直接将其丢弃 ；
    如果 SN new&gt; SN old + 1，那么说明中间有数据尚未写入， 出现了乱序 ，暗示可能有消息丢失，对应的生产者会抛出 OutOfOrderSequenceException异常；
    
    
    事务
    事务通过应用程序提供唯一的transactionalId来支持，transactionalId通过客户端参数transactional.id来显式设置；
    transactionalId与PID一一对应，PID由kafka内部分配，transactionalId由用户显式设置；
    
    生产者角度分析事务：
    
        
            保证跨生产者会话的消息幂等发布：具有相同transactionalId的新生产者实例被创建且工作的时候，旧的具有相同transactionalId的生产者实例不再工作；
        
        
            保证跨生产者会话的事务恢复：当某个生产者实例宕机后，新的生产者实例可以保证任何未完成的事务要么提交要么终止；
        
    
    
    消费者角度分析事务：
    事务能保证的语义相对较弱，因为消息可能被清理或人为的跳过；
    
    消费端参数isolation.level：
    
        
            read_uncommitted：消费端应用可以消费到未提交的事务；
        
        
            read_committed：消费端应用不可以消费到未提交的事务；
        
    
    
    ControlBatch：控制消息，专门标志一个事务的结束（COMMIT&#x2F;ABORT）
    
    消费-转换-生产模型：
    一、
    寻找TransactionCoordinator节点
    二、
    
        向TransactionCoordinator节点初始化transactionalID，TransactionCoordinator会将transactionalID和PID的关系以消息的形势保存在主题__transaction_state中，&lt;transaction_id,PID&gt;
    
    三、
    开启事务
    四、
    
        4.1：发送请求AddPartitionsToTxnRequest，让TransactionCoordinator将&lt;transactionID,TopicPartition&gt;的对应关系存储在主题__transaction_state中；
    
    4.2：生产者发送消息；
    
        4.3：生产者发送offsets和groupID到TransactionCoordinator节点，TransactionCoordinator节点通过groupID推导出在__consumer_offsets中的分区，并将这个分区保存在__transaction_state中；
    
    
        4.4：生产者发送TxnOffsetCommitRequest请求给GroupCoordinator，将本次事务中的消费位移信息offsets存储到主题__consumer_offsets中；
    五、
    提交事务或终止事务
    5.1：将PREPARE_COMMIT或PREPARE_ABORT写入主题__transaction_state；
    5.2：通过WriteTxnMarkersRequest请求将COMMIT或ABORT写入用户所使用的普通主题__consumer_offsets；
    5.3：将COMPLETE_COMMIT或COMPLETE_ABORT信息写入内部主题__transaction_state；
    
    
    
    可靠性探究
    
    失效副本判定：
    
        follower副本将leader副本LEO之前的日志全部同步时，认为该followeer副本追赶上了leader副本，更新lastCaughtUpTimeMs标识，并通过定时任务检测lastCaughtUpTimeMs是否大于参数leader.replica.lag.time.max.ms；
    
    
    
    LEO与HW
    
        
            
            
        
        
            
                
                    
                
                
                    
                    
                
            
            
                
                    起始状态，follower向leader拉取消息，拉取请求中带有自身的LEO
                
                
                    leader返回给follower相应的消息，带有自身的HW
                    HW算法是比较自身的LEO和leader传来的HW，取较小值做HW
                    
                
            
            
                
                    
                
                
                    
                
            
            
                
                    
                
                
                    此时HW&#x3D;3
                
            
        
    
    对于LEO，leader记录所有节点的LEO，follower只记录自身的LEO；
    对于HW，每个节点都只记录自身的HW；
    
    
    Leader Epoch
    问题一：数据丢失
    
        
            
            
        
        
            
                
                    
                
                
                    leader：B 两条消息、HW&#x3D;2
                    follower：A 两条消息，HW&#x3D;1
                    follower的HW从1更新到2需要拉取一次消息
                    
                
            
            
                
                    
                
                
                    在follower将HW从1更新到2期间A重启
                
            
            
                
                    
                
                
                    此时B宕机，这样A就选举成新的leader，但此时HW是1，消息m2就丢失了
                
            
        
    
    问题二：数据不一致
    
        
            
            
        
        
            
                
                    
                
                
                    leader：A 
                    follower：B 
                    此时A、B全部宕机
                    
                    
                    
                
            
            
                
                    
                
                
                    B先上线，选取成新的leader
                
            
            
                
                    
                
                
                    B收到新的消息m3，此时A上线，两者HW一致，到消息不一致
                
            
        
    
    
    leader epoch：leader的纪元信息，每当leader变更一次，leader epoch的值就会加1
    StartOffset：当前leader epoch下写入的第一条消息的偏移量
    
    数据丢失解决：
    
        
            
            
        
        
            
                
                    
                
                
                    
                
            
            
                
                    
                
                
                    A重启时，会向leader请求，查找当前leader epoch对应的start offset，也就是leader epoch A对应的LEO
                    
                    
                    
                
            
            
                
                    
                
                
                    此时A收到2后发现与当前的LEO相同，也就不需要截断日志了
                
            
        
    
    
    数据不一致解决：
    
        
            
            
        
        
            
                
                    
                    
                
                
                    
                
            
            
                
                    
                
                
                    B写入消息m3，将LEO和HW更新至2，此时LeaderEpoch已经从LE0增至LE1了
                    
                
            
            
                
                    
                
                
                    A 恢复过来成为 follower 并向 B 发送 OffsetsForLeaderEpochRequest 请求，此时 A
                    的 LeaderEpoch 为 LEO 。 B 根据 LEO 查询到对应的 offset 为 1 并返回给 A, A 就截断日志并删除了消息 m2
                
            
        
    
    
    
    
    为何不支持读写分离
    kafka只支持主写主读有以下几个优点：
    
        
            简化代码逻辑，减少出错的可能；
        
        
            将负载粒度细化均摊，与主写从读相比，不仅负载效能更好，而且对用户可控；
        
        
            没有延时的影响；
        
        
            在副本稳定的情况下，不会出现数据不一致的情况；
        
    
    
    kafka优秀的架构设计可以做到很大程度上的负载均衡，
    
        
            
            
        
        
            
                
                    可能造成负载不均衡的情况
                
                
                    解决办法
                
            
            
                
                    broker端的分区分配不均
                
                
                    主题创建的时候尽可能使分区分配均衡
                
            
            
                
                    生产者写入消息不均
                
                
                    主写从读也无法解决
                
            
            
                
                    消费者消费消息不均
                
                
                    主写从读也无法解决
                
            
            
                
                    leader副本切换不均
                
                
                    优先副本选举
                
            
        
    
    
    kafka的日志同步机制：
    ISR模型 &amp; （f+1）个副本数的配置
    在 Kafka 中动态维护着一个 ISR 集合，处于 ISR 集合内的节点保持与 leader 相同的高水位（HW），只有位列其中的副本才有资格被选为新的leader，写入消息时只有等到所有 ISR
        集合中的副本都确认收到之后才能被认为已经提交；
    一个kafka分区的f+1个副本能够容忍最大f个节点失败；
    
    
    
</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.1.5.</span> <span class="toc-text">v2版本日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.2.</span> <span class="toc-text">日志索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.3.</span> <span class="toc-text">偏移量索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.4.</span> <span class="toc-text">时间戳索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.5.</span> <span class="toc-text">日志清理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.5.1.</span> <span class="toc-text">日志删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.6.</span> <span class="toc-text">日志压缩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.7.</span> <span class="toc-text">磁盘存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">深入服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">6.1.</span> <span class="toc-text">协议相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.1.1.</span> <span class="toc-text">发送消息协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.1.2.</span> <span class="toc-text">拉取消息协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">6.2.</span> <span class="toc-text">时间轮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">6.3.</span> <span class="toc-text">延时操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">6.4.</span> <span class="toc-text">控制器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">6.5.</span> <span class="toc-text">优雅的关闭</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">6.6.</span> <span class="toc-text">分区leader的选举</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">深入客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">7.1.</span> <span class="toc-text">消费者协调器、组协调器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">7.2.</span> <span class="toc-text">位移提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">7.3.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">7.3.1.</span> <span class="toc-text">幂等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">7.3.2.</span> <span class="toc-text">事务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">可靠性探究</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">8.1.</span> <span class="toc-text">LEO与HW</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">8.2.</span> <span class="toc-text">Leader Epoch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">8.3.</span> <span class="toc-text">为何不支持读写分离</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/11/linux%E5%86%85%E6%A0%B8%E7%AD%96%E7%95%A5/" title="linux内核">linux内核</a><time datetime="2023-07-11T13:23:19.933Z" title="发表于 2023-07-11 21:23:19">2023-07-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/30/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl,%E4%BC%9A%E7%BB%8F%E5%8E%86%E5%93%AA%E4%BA%9B%E8%BF%87%E7%A8%8B/" title="在浏览器中输入url，会经历哪些过程">在浏览器中输入url，会经历哪些过程</a><time datetime="2023-06-30T11:34:23.924Z" title="发表于 2023-06-30 19:34:23">2023-06-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/06/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/" title="网络编程的一些思考">网络编程的一些思考</a><time datetime="2023-06-06T09:30:37.533Z" title="发表于 2023-06-06 17:30:37">2023-06-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/01/%E4%BD%BF%E7%94%A8LSM-tree%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%B0%8F%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" title="使用LSM-Tree实现自己的小型数据库">使用LSM-Tree实现自己的小型数据库</a><time datetime="2023-06-01T09:15:42.819Z" title="发表于 2023-06-01 17:15:42">2023-06-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/25/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/" title="代码整洁之道">代码整洁之道</a><time datetime="2023-05-25T05:41:19.579Z" title="发表于 2023-05-25 13:41:19">2023-05-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By bank</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>