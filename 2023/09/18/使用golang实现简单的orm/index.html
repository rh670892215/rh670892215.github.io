<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>使用golang实现简单的orm | bank blog</title><meta name="author" content="bank"><meta name="copyright" content="bank"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="article">
<meta property="og:title" content="使用golang实现简单的orm">
<meta property="og:url" content="http://example.com/2023/09/18/%E4%BD%BF%E7%94%A8golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84orm/index.html">
<meta property="og:site_name" content="bank blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-09-18T14:15:39.197Z">
<meta property="article:modified_time" content="2023-11-06T14:43:56.684Z">
<meta property="article:author" content="bank">
<meta property="article:tag" content="golang">
<meta property="article:tag" content="工程实践">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/09/18/%E4%BD%BF%E7%94%A8golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84orm/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '使用golang实现简单的orm',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-06 22:43:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="bank blog"><span class="site-name">bank blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">使用golang实现简单的orm</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-18T14:15:39.197Z" title="发表于 2023-09-18 22:15:39">2023-09-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-06T14:43:56.684Z" title="更新于 2023-11-06 22:43:56">2023-11-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/golang/">golang</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/golang/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/">工程实践</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="使用golang实现简单的orm"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer"/>

<span id="more"></span>
<h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tell Me and I Forget;</span><br><span class="line">Teach Me and I May Remember; </span><br><span class="line">Involve Me and I Learn.</span><br><span class="line">                            ——Benjamin Franklin</span><br></pre></td></tr></table></figure>
<p>之前只是使用过<code>gorm</code>对其底层的实现并不了解，在学习了大佬的<a target="_blank" rel="noopener" href="https://geektutu.com/post/geeorm.html">博客</a>后，为了加深理解，这里进行复现总结，实现一个简单的orm，本文的项目取名<code>GemmaORM</code>。<br>本文完整代码见：<a target="_blank" rel="noopener" href="https://github.com/rh670892215/GemmaORM">GemmaORM</a><br>先来看一下GemmaORM的使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span> <span class="string">`gemmaorm:&quot;PRIMARY KEY&quot;`</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	engine, err := NewEngine(<span class="string">&quot;sqlite3&quot;</span>, <span class="string">&quot;bank.db&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> engine.Close()</span><br><span class="line"></span><br><span class="line">	s := engine.NewSession()</span><br><span class="line">	s.Model(&amp;User&#123;&#125;).CreateTable()</span><br><span class="line">	s.Insert(&amp;User&#123;<span class="string">&quot;bank&quot;</span>, <span class="number">25</span>&#125;)</span><br><span class="line">	<span class="keyword">var</span> res []User</span><br><span class="line">	s.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;emma&quot;</span>).Find(&amp;res)</span><br><span class="line">	s.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;bank&quot;</span>).Update(<span class="string">&quot;age&quot;</span>, <span class="number">26</span>)</span><br><span class="line">	s.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;bank&quot;</span>).Update(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;age&quot;</span>: <span class="number">27</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤如下：</p>
<ol>
<li>新建<code>engine</code>，传入数据库类型和名字，建立与DB的连接；</li>
<li>新建<code>session</code>，建立一个与DB交互的回话；</li>
<li>建立<code>session</code>中表结构与DB的映射关系；（通过传入预先定义好的struct进行解析）</li>
<li>链式调用，与DB中的表进行交互；</li>
</ol>
<p><code>GemmaORM</code>支持如下几种sql：</p>
<ul>
<li>DML（数据定义语言）：select、update、delete、where、limit、order by</li>
<li>DDL（数据操作语言）：create table、drop table</li>
<li>DCL（数据控制语言）：begin、commit、rollback</li>
</ul>
<p>本文目前只作为自己的学习总结，只实现了几种基本的sql语句，复杂的<code>join</code>等语句暂未实现。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>下面来看下<code>GemmaORM</code>的实现。<br>GemmaORM的整体结构如下：<br><img src="/%E4%BD%BF%E7%94%A8golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84orm.resources/gemmaorm.png" alt="gemmaorm"><br>其中，各个模块功能如下：</p>
<ul>
<li>engine：<code>GemmaORM</code>与用户交互的入口，负责交互前的准备工作和交互后的收尾工作；</li>
<li>session：实现与数据库的交互，对外暴露DML、DDL、DCL相关接口；</li>
<li>schema：负责对象和表结构的转换，存储表结构的相关信息；</li>
<li>dialect：封装各个数据库间的差异部分，如数据类型映射等；</li>
<li>clause：实现具体的sql子句，如select、where、update、limit等；</li>
</ul>
<p>结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── GemmaORM_test.go</span><br><span class="line">├── clause</span><br><span class="line">│   ├── clause.go</span><br><span class="line">│   ├── clause_test.go</span><br><span class="line">│   └── generator.go</span><br><span class="line">├── dialect</span><br><span class="line">│   ├── dialect.go</span><br><span class="line">│   └── sqlite3.go</span><br><span class="line">├── engine.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── log</span><br><span class="line">│   └── log.go</span><br><span class="line">├── schema</span><br><span class="line">│   ├── schema.go</span><br><span class="line">│   └── schema_test.go</span><br><span class="line">└── session</span><br><span class="line">    ├── hook.go</span><br><span class="line">    ├── hook_test.go</span><br><span class="line">    ├── raw.go</span><br><span class="line">    ├── raw_test.go</span><br><span class="line">    ├── record.go</span><br><span class="line">    ├── record_test.go</span><br><span class="line">    ├── table.go</span><br><span class="line">    └── transaction.go</span><br></pre></td></tr></table></figure>

<p>下面分模块来进行实现。（本文后续使用的数据库均是sqlite3）</p>
<h2 id="dialect"><a href="#dialect" class="headerlink" title="dialect"></a>dialect</h2><p>golang中的数据类型和sqlite3中的数据类型并不是一一匹配的，因此需要将golang中的数据类型转换成sqlite3中的数据类型，如golang中的int、int8、int16等类型均对应sqlite3中的integer类型。<br>为了封装各个数据库之间的差异，抽象Dialect接口，不同的数据库实现自己的方法，本文的Dialect接口定义了如下两个方法：</p>
<ul>
<li>DataType(value reflect.Value) string</li>
<li>TableExist(tableName string) (string, []interface{})</li>
</ul>
<p>DataType：数据类型转换；<br>TableExist判断表是否存在；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dialect 封装底层数据库的差异</span></span><br><span class="line"><span class="keyword">type</span> Dialect <span class="keyword">interface</span> &#123;</span><br><span class="line">	DataType(value reflect.Value) <span class="type">string</span></span><br><span class="line">	TableExist(tableName <span class="type">string</span>) (<span class="type">string</span>, []<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dialectMap <span class="keyword">map</span>[<span class="type">string</span>]Dialect</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterDialect 注册数据库类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterDialect</span><span class="params">(name <span class="type">string</span>, dialect Dialect)</span></span> &#123;</span><br><span class="line">	once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		dialectMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]Dialect)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	dialectMap[name] = dialect</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetDialect 根据数据库类型获取Dialect</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDialect</span><span class="params">(name <span class="type">string</span>)</span></span> (Dialect, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> dialectMap == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res, ok := dialectMap[name]</span><br><span class="line">	<span class="keyword">return</span> res, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义RegisterDialect方法，用来注册数据库类型，GetDialect用来根据数据库类型获取具体的Dialect；<br>同时使用单例模式在内存中维护数据库类型和具体Dialect的映射；</p>
<p>对于sqlite3中两种方法的具体实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sqlite3 sqlite3数据库</span></span><br><span class="line"><span class="keyword">type</span> Sqlite3 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	RegisterDialect(<span class="string">&quot;sqlite3&quot;</span>, &amp;Sqlite3&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DataType 实现DataType接口，golang类型映射成sqlite3中的类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Sqlite3)</span></span> DataType(value reflect.Value) <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> value.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.Bool:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;bool&quot;</span></span><br><span class="line">	<span class="keyword">case</span> reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32,</span><br><span class="line">		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uintptr:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">	<span class="keyword">case</span> reflect.Int64, reflect.Uint64:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;bigint&quot;</span></span><br><span class="line">	<span class="keyword">case</span> reflect.Float32, reflect.Float64:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;real&quot;</span></span><br><span class="line">	<span class="keyword">case</span> reflect.String:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;text&quot;</span></span><br><span class="line">	<span class="keyword">case</span> reflect.Array, reflect.Slice:</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;blob&quot;</span></span><br><span class="line">	<span class="keyword">case</span> reflect.Struct:</span><br><span class="line">		<span class="keyword">if</span> _, ok := value.Interface().(time.Time); ok &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;datetime&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TableExist 输出判断表是否存在的sql</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Sqlite3)</span></span> TableExist(tableName <span class="type">string</span>) (<span class="type">string</span>, []<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	vars := []<span class="keyword">interface</span>&#123;&#125;&#123;tableName&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;SELECT name FROM sqlite_master WHERE type=&#x27;table&#x27; and name = ?&quot;</span>, vars</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续若需要添加不同的功能可以在Dialect接口中直接进行添加。</p>
<h2 id="schema"><a href="#schema" class="headerlink" title="schema"></a>schema</h2><p>这部分需要建立对象和表的转换，对于一张表，需要关注以下信息：</p>
<ol>
<li>表名；</li>
<li>字段名、字段类型；</li>
<li>字段约束；</li>
</ol>
<p>字段定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Field 表结构字段定义</span></span><br><span class="line"><span class="keyword">type</span> Field <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type <span class="type">string</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Tag  <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Schema 表结构</span></span><br><span class="line"><span class="keyword">type</span> Schema <span class="keyword">struct</span> &#123;</span><br><span class="line">	Model      <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	Name       <span class="type">string</span></span><br><span class="line">	Fields     []*Field</span><br><span class="line">	FiledMap   <span class="keyword">map</span>[<span class="type">string</span>]*Field</span><br><span class="line">	FieldNames []<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parse 根据model解析表结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(model <span class="keyword">interface</span>&#123;&#125;, dialect dialect.Dialect)</span></span> *Schema &#123;</span><br><span class="line">	modelType := reflect.Indirect(reflect.ValueOf(model)).Type()</span><br><span class="line">	schema := &amp;Schema&#123;</span><br><span class="line">		Model:    model,</span><br><span class="line">		Name:     modelType.Name(),</span><br><span class="line">		FiledMap: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*Field),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; modelType.NumField(); i++ &#123;</span><br><span class="line">		<span class="comment">// 若字段是匿名字段或不可导出，则不进行解析</span></span><br><span class="line">		<span class="keyword">if</span> modelType.Field(i).Anonymous || !modelType.Field(i).IsExported() &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		filedName := modelType.Field(i).Name</span><br><span class="line">		filedType := modelType.Field(i).Type</span><br><span class="line">		fieldTag := modelType.Field(i).Tag.Get(<span class="string">&quot;gemmaorm&quot;</span>)</span><br><span class="line"></span><br><span class="line">		field := &amp;Field&#123;</span><br><span class="line">			Name: filedName,</span><br><span class="line">			Type: dialect.DataType(reflect.New(filedType)),</span><br><span class="line">			Tag:  fieldTag,</span><br><span class="line">		&#125;</span><br><span class="line">		schema.FiledMap[filedName] = field</span><br><span class="line">		schema.Fields = <span class="built_in">append</span>(schema.Fields, field)</span><br><span class="line">		schema.FieldNames = <span class="built_in">append</span>(schema.FieldNames, filedName)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> schema</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetFieldByName 根据字段名获取field</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Schema)</span></span> GetFieldByName(name <span class="type">string</span>) *Field &#123;</span><br><span class="line">	<span class="keyword">return</span> s.FiledMap[name]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RecordValues 将dest中各字段的值打平，如User&#123;&quot;bank&quot;,25&#125; -&gt; []interface&#123;&#125;&#123;&quot;bank&quot;,25&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Schema)</span></span> RecordValues(dest <span class="keyword">interface</span>&#123;&#125;) []<span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	value := reflect.Indirect(reflect.ValueOf(dest))</span><br><span class="line">	<span class="keyword">var</span> res []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, field := <span class="keyword">range</span> s.Fields &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, value.FieldByName(field.Name).Interface())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们需要将结构体解析成<code>Schema</code>，也就是<code>Parse</code>函数：<br>入参接收任意类型的struct，即用interface{}承接，同时需要传入屏蔽底层数据库差异的<code>Dialect</code>接口；<br>这里的核心就是通过reflect机制，首先通过<code>reflect.Indirect(reflect.ValueOf(model)).Type()</code>获取<code>model</code>类型，接着逐个遍历字段，进行解析，同时屏蔽掉不可导出字段和匿名字段，最后填充<code>Schema</code>。</p>
<p>由于希望支持通过传入对象进行<code>insert</code>，为了适配后面insert的sql方法需要将结构体的字段打平，输出slice，对这部分不理解的同学可以阅读完后面具体的sql方法后再来看这里。注意这里输出slice的字段顺序要与解析后的表结构<code>Schema</code>中存储的Field顺序一致。（需要保证column name和value匹配）</p>
<h2 id="clause"><a href="#clause" class="headerlink" title="clause"></a>clause</h2><p>sql语句一般由很多个子句(clause)构成，这部分我们将sql语句拆分成多个子句，用来支撑上层调用的语句组合。</p>
<h3 id="对外暴露接口"><a href="#对外暴露接口" class="headerlink" title="对外暴露接口"></a>对外暴露接口</h3><p>将sql语句拆分成如下子句：</p>
<ul>
<li>INSERT</li>
<li>DELETE</li>
<li>UPDATE</li>
<li>SELECT</li>
<li>WHERE</li>
<li>LIMIT</li>
<li>ORDER</li>
<li>VALUE</li>
<li>COUNT</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AtomType sql拆分后的子句类型</span></span><br><span class="line"><span class="keyword">type</span> AtomType <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	INSERT = <span class="literal">iota</span></span><br><span class="line">	DELETE</span><br><span class="line">	UPDATE</span><br><span class="line">	SELECT</span><br><span class="line">	WHERE</span><br><span class="line">	LIMIT</span><br><span class="line">	ORDER</span><br><span class="line">	VALUE</span><br><span class="line">	COUNT</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clause sql子句</span></span><br><span class="line"><span class="keyword">type</span> Clause <span class="keyword">struct</span> &#123;</span><br><span class="line">	sql     <span class="keyword">map</span>[AtomType]<span class="type">string</span></span><br><span class="line">	sqlVars <span class="keyword">map</span>[AtomType][]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clause)</span></span> Set(typ AtomType, vars ...<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	<span class="keyword">if</span> c.sqlVars == <span class="literal">nil</span> || c.sql == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.sql = <span class="built_in">make</span>(<span class="keyword">map</span>[AtomType]<span class="type">string</span>)</span><br><span class="line">		c.sqlVars = <span class="built_in">make</span>(<span class="keyword">map</span>[AtomType][]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	sql, sqlVars := generatorMap[typ](vars...)</span><br><span class="line">	c.sql[typ] = sql</span><br><span class="line">	c.sqlVars[typ] = sqlVars</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clause)</span></span> Build(names ...AtomType) (<span class="type">string</span>, []<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	<span class="keyword">var</span> resSqlVars []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> sqlArr []<span class="type">string</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, name := <span class="keyword">range</span> names &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := c.sql[name]; !ok &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		sql := c.sql[name]</span><br><span class="line">		sqlVars := c.sqlVars[name]</span><br><span class="line">		sqlArr = <span class="built_in">append</span>(sqlArr, sql)</span><br><span class="line">		resSqlVars = <span class="built_in">append</span>(resSqlVars, sqlVars...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resSql := strings.Join(sqlArr, <span class="string">&quot; &quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> resSql, resSqlVars</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Clause中有两个字段：</p>
<ul>
<li>sql：不同类型子句的sql语句；</li>
<li>sqlVars：不同类型子句的参数；</li>
</ul>
<p>如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> &quot;bank&quot; <span class="keyword">order</span> <span class="keyword">by</span> age limit <span class="number">1</span>；</span><br><span class="line"></span><br><span class="line">「<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>」 「<span class="keyword">where</span> name <span class="operator">=</span> &quot;bank&quot;」 「<span class="keyword">order</span> <span class="keyword">by</span> age」 「limit <span class="number">1</span>」；</span><br></pre></td></tr></table></figure>
<p>按如上方式进行拆分后clause赋值如下：</p>
<ul>
<li>sql：<ul>
<li>select : select * from user</li>
<li>where : where name &#x3D; ?</li>
<li>order : order by age</li>
<li>limit : limit ?</li>
</ul>
</li>
<li>sqlVars<ul>
<li>where : “bank”</li>
<li>limit : 1</li>
</ul>
</li>
</ul>
<p>对外暴露<code>Set</code>和<code>Build</code>接口：</p>
<ul>
<li>Set：根据上面拆分的结果对不同的子句进行赋值；</li>
<li>Build：按照指定顺序重新组合sql子句，拼出sql语句及需要传入的变量；</li>
</ul>
<h3 id="内部逻辑实现"><a href="#内部逻辑实现" class="headerlink" title="内部逻辑实现"></a>内部逻辑实现</h3><p>有了整体的框架，下面填充不同子句的逻辑，不同子句的函数签名统一如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> generator <span class="function"><span class="keyword">func</span><span class="params">(...<span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">string</span>, []<span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>传入可变长度参数，输出sql子句及对应的变量。<br>下面逐个来讨论子句的实现。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selet <span class="operator">*</span> <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// select子句，input : tableName,[]sting&#123;col1,col2...&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">select</span><span class="params">(values ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">string</span>, []<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	tableName := values[<span class="number">0</span>]</span><br><span class="line">	params := strings.Join(values[<span class="number">1</span>].([]<span class="type">string</span>), <span class="string">&quot;,&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;select %s from %s&quot;</span>, params, tableName), []<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义select子句方法传入两个参数：</p>
<ol>
<li>表名 ➡️ string</li>
<li>查询字段名 ➡️ []string</li>
</ol>
<p>解析传入参数，拼接string，输出，逻辑比较简单不再赘述。</p>
<h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> &quot;bank&quot;,age <span class="operator">=</span> <span class="number">25</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更改记录，input : tableName map[string]interface&#123;&#125;&#123;colName:colValue&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">update</span><span class="params">(values ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">string</span>, []<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	tableName := values[<span class="number">0</span>]</span><br><span class="line">	tableValue := values[<span class="number">1</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">var</span> valueSlice []<span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> vars []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> tableValue &#123;</span><br><span class="line">		valueSlice = <span class="built_in">append</span>(valueSlice, fmt.Sprintf(<span class="string">&quot;%s = ?&quot;</span>, k))</span><br><span class="line">		vars = <span class="built_in">append</span>(vars, v)</span><br><span class="line">	&#125;</span><br><span class="line">	valueSliceStr := strings.Join(valueSlice, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">	sql := fmt.Sprintf(<span class="string">&quot;update %s set %s&quot;</span>, tableName, valueSliceStr)</span><br><span class="line">	<span class="keyword">return</span> sql, vars</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>update子句方法传入两个参数：</p>
<ol>
<li>表名 ➡️ string</li>
<li>更新字段名&amp;值 ➡️ map[string]interface{}</li>
</ol>
<p>从输入参数中解析出表名和更新的字段，然后遍历需要更新的字段map，将<code>key</code>即列名拼接上<code>?</code>填入<code>sql</code>，将<code>value</code>即列值填入返回的参数列表。<br>返回如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> ?,age <span class="operator">=</span> ?</span><br><span class="line">&quot;bank&quot;,<span class="number">25</span></span><br></pre></td></tr></table></figure>

<h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (name,age) <span class="keyword">values</span> (&quot;bank&quot;,<span class="number">25</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入记录(单条),input : tableName,[]string&#123;&quot;name&quot;,&quot;age&quot;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">insert</span><span class="params">(values ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">string</span>, []<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	<span class="comment">// insert into user (name,age)</span></span><br><span class="line">	tableName := values[<span class="number">0</span>]</span><br><span class="line">	args := strings.Join(values[<span class="number">1</span>].([]<span class="type">string</span>), <span class="string">&quot;,&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;insert into %s (%s)&quot;</span>, tableName, args), []<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>insert子句方法传入两个参数：</p>
<ol>
<li>表名 ➡️ string</li>
<li>插入列名 ➡️ []string</li>
</ol>
<p>这部分比较简单，只是解析出表名、列名，拼接sql语句进行返回，返回值如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (name,age)</span><br></pre></td></tr></table></figure>

<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delete子句，input : tableName</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">delete</span><span class="params">(values ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">string</span>, []<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;delete from %s&quot;</span>, values[<span class="number">0</span>]), []<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delete子句只传入表名即可，筛选条件依赖where子句进行注入。</p>
<h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入values exp : []interface&#123;&quot;bank&quot;,25&#125;,[]interface&#123;&quot;emma&quot;,25&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">value</span><span class="params">(values ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">string</span>, []<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	<span class="keyword">var</span> sql strings.Builder</span><br><span class="line">	<span class="keyword">var</span> vars []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> sqlArr []<span class="type">string</span></span><br><span class="line"></span><br><span class="line">	sql.WriteString(<span class="string">&quot;values &quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</span><br><span class="line">		v := value.([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">		sqlArr = <span class="built_in">append</span>(sqlArr, fmt.Sprintf(<span class="string">&quot;(%s)&quot;</span>, genBindVars(<span class="built_in">len</span>(v))))</span><br><span class="line">		vars = <span class="built_in">append</span>(vars, v...)</span><br><span class="line">	&#125;</span><br><span class="line">	sql.WriteString(strings.Join(sqlArr, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">	<span class="comment">// values (?,?),(?,?)  &quot;bank&quot;,25,&quot;emma&quot;,25</span></span><br><span class="line">	<span class="keyword">return</span> sql.String(), vars</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据num生成指定数量的?,如 num = 3 ,output = ?,?,?</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genBindVars</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> vars []<span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">		vars = <span class="built_in">append</span>(vars, <span class="string">&quot;?&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> strings.Join(vars, <span class="string">&quot;, &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>value子句方法输入多个参数，每个参数都是一个[]interface{}，其流程是将values的每个元素即每个[]interface{}进行处理，根据[]interface{}的长度输出含有指定个数<code>?</code>的<code>(?,...)</code>，同时将每一个元素添加到待返回的参数列表中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">values</span> (?,?),(?,?)</span><br><span class="line">&quot;bank&quot;,<span class="number">25</span>,&quot;emma&quot;,<span class="number">25</span></span><br></pre></td></tr></table></figure>


<h4 id="where"><a href="#where" class="headerlink" title="where"></a>where</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// where条件子句，input : name = ? , &quot;bank&quot;...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">where</span><span class="params">(values ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">string</span>, []<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	<span class="comment">// where name = ? , &quot;bank&quot;</span></span><br><span class="line">	desc := values[<span class="number">0</span>]</span><br><span class="line">	args := values[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;where %s&quot;</span>, desc), args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>where子句方法传入多个参数：</p>
<ol>
<li>where条件 ➡️ string</li>
<li>筛选值 ➡️ []interface{}</li>
</ol>
<p>逻辑比较简单，只是提取出where条件，并将后面的筛选值聚合成[]interface{}，直接返回，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input : </span><br><span class="line"><span class="keyword">where</span> name <span class="operator">=</span> ?,age <span class="operator">=</span> ?;&quot;bank&quot;;<span class="number">25</span></span><br><span class="line">output : </span><br><span class="line"><span class="keyword">where</span> name <span class="operator">=</span> ?,age <span class="operator">=</span> ?</span><br><span class="line">&quot;bank&quot;,<span class="number">25</span></span><br></pre></td></tr></table></figure>

<h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">order</span><span class="params">(values ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">string</span>, []<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	orderFiled := values[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;order by %s&quot;</span>, orderFiled), []<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>order子句方法传入一个参数：</p>
<ol>
<li>排序字段</li>
</ol>
<p>拼接sql语句直接返回。</p>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">limit</span><span class="params">(values ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">string</span>, []<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	num := values[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;limit ?&quot;</span>, []<span class="keyword">interface</span>&#123;&#125;&#123;num&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>order子句方法传入一个参数：</p>
<ol>
<li>limit数量</li>
</ol>
<p>输出如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">limit ?</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// count条件子句，input : tableName</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">count</span><span class="params">(values ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="type">string</span>, []<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	<span class="keyword">return</span> _select(values[<span class="number">0</span>], []<span class="type">string</span>&#123;<span class="string">&quot;count(*)&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>count子句方法传入一个参数：</p>
<ol>
<li>表名 ➡️ string</li>
</ol>
<p>复用select子句，将<code>count(*)</code>作为第二个参数传入。</p>
<h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	errorLog = log.New(os.Stdout, <span class="string">&quot;\033[31m[error]\033[0m &quot;</span>, log.LstdFlags|log.Lshortfile)</span><br><span class="line">	infoLog  = log.New(os.Stdout, <span class="string">&quot;\033[32m[info ]\033[0m &quot;</span>, log.LstdFlags|log.Lshortfile)</span><br><span class="line">	loggers  = []*log.Logger&#123;errorLog, infoLog&#125;</span><br><span class="line">	mu       sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	Error  = errorLog.Println</span><br><span class="line">	Errorf = errorLog.Printf</span><br><span class="line">	Info   = infoLog.Println</span><br><span class="line">	Infof  = infoLog.Printf</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	InfoLevel = <span class="literal">iota</span></span><br><span class="line">	ErrorLevel</span><br><span class="line">	Disable</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetLevel</span><span class="params">(level <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// level越低，log信息越丰富</span></span><br><span class="line">	<span class="keyword">for</span> _, logger := <span class="keyword">range</span> loggers &#123;</span><br><span class="line">		logger.SetOutput(os.Stdout)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ErrorLevel &lt; level &#123;</span><br><span class="line">		<span class="comment">// 丢弃错误日志</span></span><br><span class="line">		errorLog.SetOutput(ioutil.Discard)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> InfoLevel &lt; level &#123;</span><br><span class="line">		<span class="comment">// 丢弃普通日志</span></span><br><span class="line">		infoLog.SetOutput(ioutil.Discard)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持按等级输出日志信息，这部分比较简单，不进行赘述。</p>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>session模块和clause是两个核心模块，clause负责具体sql子句的生成，session负责与数据库交互，其主要分成以下几个部分：</p>
<ol>
<li>hook：实现回调函数的相关方法；</li>
<li>raw：底层sql调用方法；</li>
<li>record：记录操作相关方法；</li>
<li>table：表操作相关方法；</li>
<li>transaction：支持事务的相关方法；</li>
</ol>
<p>其中<code>hook</code>和<code>transaction</code>是功能扩展，<code>raw</code>、<code>record</code>、<code>table</code>是基础功能的实现，下面逐个进行讨论。</p>
<p>对于一个session集成了clause、dialect、schema三个模块，同时维护数据库的连接、事务，还有需要执行的sql和对应的变量，因此session的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Session 一次与数据库交互的会话</span></span><br><span class="line"><span class="keyword">type</span> Session <span class="keyword">struct</span> &#123;</span><br><span class="line">	db   *sql.DB</span><br><span class="line">	tx   *sql.Tx</span><br><span class="line">	sql  strings.Builder</span><br><span class="line">	vars []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	clause      *clause.Clause</span><br><span class="line">	tableSchema *schema.Schema</span><br><span class="line">	dialect     dialect.Dialect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了兼容<code>db</code>和<code>tx</code>，定义如下结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonDB 数据库最小功能集合</span></span><br><span class="line"><span class="keyword">type</span> CommonDB <span class="keyword">interface</span> &#123;</span><br><span class="line">	Query(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (*sql.Rows, <span class="type">error</span>)</span><br><span class="line">	QueryRow(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *sql.Row</span><br><span class="line">	Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (sql.Result, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续可以将db 和 tx 分别赋值给 CommonDB 类型的变量 commonDB，然后使用 commonDB 来执行数据库操作。这样，无论是使用 sql.db 还是 sql.tx，都可以通过 CommonDB 接口来进行统一的操作</p>
<h3 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewSession new session</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSession</span><span class="params">(db *sql.DB, dialect dialect.Dialect)</span></span> *Session &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Session&#123;</span><br><span class="line">		db:      db,</span><br><span class="line">		dialect: dialect,</span><br><span class="line">		clause:  &amp;clause.Clause&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear 重新初始化session</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> Clear() &#123;</span><br><span class="line">	s.sql.Reset()</span><br><span class="line">	s.vars = []<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetDB 获取本session连接的数据库</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> GetDB() CommonDB &#123;</span><br><span class="line">	<span class="keyword">if</span> s.tx != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> s.tx</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Raw 添加sql语句和参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> Raw(sql <span class="type">string</span>, vars ...<span class="keyword">interface</span>&#123;&#125;) *Session &#123;</span><br><span class="line">	s.sql.WriteString(sql)</span><br><span class="line">	s.sql.WriteString(<span class="string">&quot; &quot;</span>)</span><br><span class="line">	s.vars = <span class="built_in">append</span>(s.vars, vars...)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Query 获取符合查询条件的所有记录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> Query() (*sql.Rows, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> s.Clear()</span><br><span class="line">	<span class="keyword">return</span> s.GetDB().Query(s.sql.String(), s.vars...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exec 执行session中的sql语句</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> Exec() (sql.Result, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> s.Clear()</span><br><span class="line">	<span class="keyword">return</span> s.GetDB().Exec(s.sql.String(), s.vars...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QueryRow 获取符合查询条件的第一条记录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> QueryRow() *sql.Row &#123;</span><br><span class="line">	<span class="keyword">defer</span> s.Clear()</span><br><span class="line">	<span class="keyword">return</span> s.GetDB().QueryRow(s.sql.String(), s.vars...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体的逻辑比较清晰，封装<code>Exec()</code>、<code>Query()</code>和<code>QueryRow()</code>三个原生方法。</p>
<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Model 解析表结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> Model(model <span class="keyword">interface</span>&#123;&#125;) *Session &#123;</span><br><span class="line">	<span class="keyword">if</span> s.tableSchema == <span class="literal">nil</span> || reflect.TypeOf(model) != reflect.TypeOf(s.tableSchema.Model) &#123;</span><br><span class="line">		s.tableSchema = schema.Parse(model, s.dialect)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetRefTable 获取当前session关联表结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> GetRefTable() *schema.Schema &#123;</span><br><span class="line">	<span class="keyword">return</span> s.tableSchema</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateTable 创建表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> CreateTable() <span class="type">error</span> &#123;</span><br><span class="line">	tableName := s.GetRefTable().Name</span><br><span class="line">	<span class="keyword">var</span> columns []<span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> _, field := <span class="keyword">range</span> s.GetRefTable().Fields &#123;</span><br><span class="line">		columns = <span class="built_in">append</span>(columns, fmt.Sprintf(<span class="string">&quot;%s %s %s&quot;</span>, field.Name, field.Type, field.Tag))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	columnsStr := strings.Join(columns, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">	sql := fmt.Sprintf(<span class="string">&quot;create table %s (%s)&quot;</span>, tableName, columnsStr)</span><br><span class="line">	_, err := s.Raw(sql).Exec()</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DropTable 删除表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> DropTable() <span class="type">error</span> &#123;</span><br><span class="line">	tableName := s.GetRefTable().Name</span><br><span class="line">	sql := fmt.Sprintf(<span class="string">&quot;drop table if exists %s&quot;</span>, tableName)</span><br><span class="line">	_, err := s.Raw(sql).Exec()</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HasTable 判断表是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> HasTable() <span class="type">bool</span> &#123;</span><br><span class="line">	sql, vars := s.dialect.TableExist(s.GetRefTable().Name)</span><br><span class="line">	row := s.Raw(sql, vars...).QueryRow()</span><br><span class="line">	<span class="keyword">var</span> resName <span class="type">string</span></span><br><span class="line">	_ = row.Scan(&amp;resName)</span><br><span class="line">	<span class="keyword">return</span> resName == s.GetRefTable().Name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于表操作部分，封装了如下方法：</p>
<ol>
<li>Model：通过struct解析表结构；</li>
<li>GetRefTable：获取session关联的表结构；</li>
<li>CreateTable：创建表；</li>
<li>DropTable：删除表；</li>
<li>HasTable：判断表是否存在；</li>
</ol>
<p>除<code>Model</code>方法外逻辑比较简单，都是简单的sql执行，<code>Model</code>方法使用了<font color=red>懒加载</font>，当<code>session</code>中的表结构是空或发生改变时再进行更改。</p>
<h3 id="record"><a href="#record" class="headerlink" title="record"></a>record</h3><p>这部分的逻辑比较复杂，下面来逐个方法进行讨论。</p>
<h4 id="insert-1"><a href="#insert-1" class="headerlink" title="insert"></a>insert</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Insert 插入记录，exp: &amp;User&#123;&quot;bank&quot;,25&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> Insert(values ...<span class="keyword">interface</span>&#123;&#125;) (<span class="type">int64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// insert into user (f1,f2) values (&quot;bank&quot;,25),(&quot;emma&quot;,25)</span></span><br><span class="line">	<span class="keyword">var</span> recordValues []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</span><br><span class="line">		<span class="comment">// 这里先调用model进行表schema解析</span></span><br><span class="line">		table := s.Model(value).GetRefTable()</span><br><span class="line">		s.CallMethod(BeforeInsert, value)</span><br><span class="line">		recordValue := table.RecordValues(value)</span><br><span class="line">		recordValues = <span class="built_in">append</span>(recordValues, recordValue)</span><br><span class="line">		<span class="comment">// 添加insert语句</span></span><br><span class="line">		s.clause.Set(clause.INSERT, table.Name, table.FieldNames)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.clause.Set(clause.VALUE, recordValues...)</span><br><span class="line">	sql, vars := s.clause.Build(clause.INSERT, clause.VALUE)</span><br><span class="line">	res, err := s.Raw(sql, vars...).Exec()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	s.CallMethod(AfterInsert, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">return</span> res.RowsAffected()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>insert方法支持传入多个结构体来在表中插入记录，遍历入参，逐个进行处理：</p>
<ol>
<li>首先将struct解析成表结构；</li>
<li>接着将struct的字段按序打平；</li>
<li>然后将打平后的字段追加到参数集合，并将表名和字段名添加insert语句到clause；</li>
<li>将字段值结合value添加到clause；</li>
<li>按序构建sql语句和参数列表；</li>
<li>执行sql语句；（注意这里参数列表需要以可变参数的形式传入）</li>
</ol>
<h4 id="update-1"><a href="#update-1" class="headerlink" title="update"></a>update</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update 更改记录，支持输入 : 1.&quot;age&quot;,26; 2. map[string]interface&#123;&#125;&#123;&quot;age&quot;:26&#125;;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> Update(values ...<span class="keyword">interface</span>&#123;&#125;) (<span class="type">int64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// update user set col1 = val1,col2 = val2,... where [condition]</span></span><br><span class="line">	valuesTable, ok := values[<span class="number">0</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		valuesTable = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(values); i += <span class="number">2</span> &#123;</span><br><span class="line">			valuesTable[values[i].(<span class="type">string</span>)] = values[i+<span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.CallMethod(BeforeUpdate, <span class="literal">nil</span>)</span><br><span class="line">	s.clause.Set(clause.UPDATE, s.GetRefTable().Name, valuesTable)</span><br><span class="line">	sql, args := s.clause.Build(clause.UPDATE, clause.WHERE)</span><br><span class="line">	res, err := s.Raw(sql, args...).Exec()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	s.CallMethod(AfterUpdate, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">return</span> res.RowsAffected()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>update方法支持两种输入：</p>
<ol>
<li>数组形式：”age”,26</li>
<li>map形式：map[string]interface{}{“age”:26}</li>
</ol>
<p>这里核心就是将两种入参统一成map形式，传入clause，再构建sql语句与参数列表，后续步骤与insert一致；</p>
<h4 id="delete-1"><a href="#delete-1" class="headerlink" title="delete"></a>delete</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delete 删除指定记录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> Delete() (<span class="type">int64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// delete from user where [condition]</span></span><br><span class="line">	s.CallMethod(BeforeDelete, <span class="literal">nil</span>)</span><br><span class="line">	s.clause.Set(clause.DELETE, s.tableSchema.Name)</span><br><span class="line">	sql, vars := s.clause.Build(clause.DELETE, clause.WHERE)</span><br><span class="line">	res, err := s.Raw(sql, vars...).Exec()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	s.CallMethod(AfterDelete, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">return</span> res.RowsAffected()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delete方法逻辑简单，将表名传入clause的delete方法即可，构建sql语句时加入where设定的条件。</p>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find 查找匹配的记录，并写入value，value需传入指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> Find(value <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	s.CallMethod(BeforeQuery, <span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">// select * from user</span></span><br><span class="line">	valueSlice := reflect.Indirect(reflect.ValueOf(value))</span><br><span class="line">	<span class="comment">// 第一次Elem()调用，获取slice元素类型</span></span><br><span class="line">	elementType := valueSlice.Type().Elem()</span><br><span class="line">	<span class="comment">// 第二次Elem()调用，获取新创建的slice元素实例</span></span><br><span class="line">	table := s.Model(reflect.New(elementType).Elem().Interface()).GetRefTable()</span><br><span class="line"></span><br><span class="line">	s.clause.Set(clause.SELECT, table.Name, table.FieldNames)</span><br><span class="line">	sql, vars := s.clause.Build(clause.SELECT, clause.WHERE, clause.ORDER, clause.LIMIT)</span><br><span class="line">	rows, err := s.Raw(sql, vars...).Query()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">		<span class="comment">// 获取创建的slice的每个元素类型</span></span><br><span class="line">		dest := reflect.New(elementType).Elem()</span><br><span class="line">		<span class="keyword">var</span> values []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> _, name := <span class="keyword">range</span> s.GetRefTable().FieldNames &#123;</span><br><span class="line">			<span class="comment">// 收集dest中每个字段的地址，填充到values中</span></span><br><span class="line">			values = <span class="built_in">append</span>(values, dest.FieldByName(name).Addr().Interface())</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将rows中的值写入values，即dest的每个字段的地址</span></span><br><span class="line">		<span class="keyword">if</span> err := rows.Scan(values...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		s.CallMethod(AfterQuery, dest.Addr().Interface())</span><br><span class="line">		valueSlice.Set(reflect.Append(valueSlice, dest))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rows.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>获取 value 的反射值，并通过 Elem() 方法获取切片元素的类型。</li>
<li>使用切片元素的类型创建一个新的实例，并通过 Model() 方法获取与该实例关联的表信息。</li>
<li>使用表信息设置查询的 SELECT 子句，构建 SQL 语句和参数。</li>
<li>使用 Raw() 方法执行查询，并获取结果集。</li>
<li>遍历结果集的每一行：<ul>
<li>创建一个新的目标对象 dest，其类型与切片元素的类型相同。</li>
<li>为每个字段收集目标对象 dest 中字段的地址，并将其添加到 values 切片中。</li>
<li>使用 Scan() 方法将结果集中的值填充到 values 中的地址中，即将值写入目标对象 dest 的字段。</li>
<li>在查询之后，调用 AfterQuery 方法，并将目标对象 dest 的地址作为参数。</li>
<li>将目标对象 dest 添加到切片 valueSlice 中。</li>
</ul>
</li>
</ol>
<h4 id="where-1"><a href="#where-1" class="headerlink" title="where"></a>where</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Where 条件语句，支持链式调用，desc : name = ?,args : &quot;bank&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> Where(desc <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) *Session &#123;</span><br><span class="line">	<span class="keyword">var</span> params []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 将desc和args数组打平，统一成数组传入set</span></span><br><span class="line">	s.clause.Set(clause.WHERE, <span class="built_in">append</span>(<span class="built_in">append</span>(params, desc), args...)...)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持链式调用，底层直接调用set方法即可；<br>这里需要注意由于底层的<code>_where</code>方法的入参是<code>name = ? and age = ? , &quot;bank&quot; , 25</code>类型，即打平的数组形式，因此在构造入参时需要使用的<code>s.clause.Set(clause.WHERE, append(append(params, desc), args...)...)</code>形式，否则传入的<code>args</code>不符合预期，会成为一个数组。</p>
<h4 id="limit-1"><a href="#limit-1" class="headerlink" title="limit"></a>limit</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Limit Limit子句，支持链式调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> Limit(num <span class="type">int</span>) *Session &#123;</span><br><span class="line">	s.clause.Set(clause.LIMIT, num)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持链式调用，底层直接调用set方法即可；</p>
<h4 id="order-1"><a href="#order-1" class="headerlink" title="order"></a>order</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Order Order子句，支持链式调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> Order(field <span class="type">string</span>) *Session &#123;</span><br><span class="line">	s.clause.Set(clause.ORDER, field)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持链式调用，底层直接调用set方法即可；</p>
<h4 id="first"><a href="#first" class="headerlink" title="first"></a>first</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// First 获取符合条件的第一条记录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> First(value <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	dest := reflect.Indirect(reflect.ValueOf(value))</span><br><span class="line">	destSlice := reflect.New(reflect.SliceOf(dest.Type())).Elem()</span><br><span class="line">	<span class="keyword">if</span> err := s.Limit(<span class="number">1</span>).Find(destSlice.Addr().Interface()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> destSlice.Len() == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;NOT FOUND&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	dest.Set(destSlice.Index(<span class="number">0</span>))</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复用<code>Find</code>方法，只是添加<code>limit</code>调用，同时读取结果时只读取首个元素即可。</p>
<h4 id="count-1"><a href="#count-1" class="headerlink" title="count"></a>count</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Count 获取符合条件的记录数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> Count() (<span class="type">int64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	s.clause.Set(clause.COUNT, s.GetRefTable().Name)</span><br><span class="line">	sql, vars := s.clause.Build(clause.COUNT, clause.WHERE)</span><br><span class="line">	res, err := s.Raw(sql, vars...).Exec()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res.RowsAffected()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	BeforeQuery  = <span class="string">&quot;BeforeQuery&quot;</span></span><br><span class="line">	AfterQuery   = <span class="string">&quot;AfterQuery&quot;</span></span><br><span class="line">	BeforeUpdate = <span class="string">&quot;BeforeUpdate&quot;</span></span><br><span class="line">	AfterUpdate  = <span class="string">&quot;AfterUpdate&quot;</span></span><br><span class="line">	BeforeDelete = <span class="string">&quot;BeforeDelete&quot;</span></span><br><span class="line">	AfterDelete  = <span class="string">&quot;AfterDelete&quot;</span></span><br><span class="line">	BeforeInsert = <span class="string">&quot;BeforeInsert&quot;</span></span><br><span class="line">	AfterInsert  = <span class="string">&quot;AfterInsert&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CallMethod 根据method调用session的tableSchema实现的指定的方法，value可以传入实现了method方法的struct，优先使用value结构体实现的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> CallMethod(method <span class="type">string</span>, value <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	fm := reflect.ValueOf(s.GetRefTable().Model).MethodByName(method)</span><br><span class="line">	<span class="keyword">if</span> value != <span class="literal">nil</span> &#123;</span><br><span class="line">		fm = reflect.ValueOf(value).MethodByName(method)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fm.IsValid() &#123;</span><br><span class="line">		params := []reflect.Value&#123;reflect.ValueOf(s)&#125;</span><br><span class="line">		<span class="keyword">if</span> res := fm.Call(params); <span class="built_in">len</span>(res) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err, ok := res[<span class="number">0</span>].Interface().(<span class="type">error</span>); ok &#123;</span><br><span class="line">				log.Error(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hook机制同样是通过反射来实现的，s.RefTable().Model 或 value（即当前会话正在操作的对象），使用 MethodByName 方法反射得到该对象的方法。<br>将 s *Session 作为入参调用。每一个钩子的入参类型均是 *Session</p>
<p><code>callmethod</code>默认调用使用session中表结构schema对应的struct实现的相关方法，若传入的value不为空，则调用本session正在操作对象的指定方法。</p>
<h3 id="transaction"><a href="#transaction" class="headerlink" title="transaction"></a>transaction</h3><p>sql中的原生事务如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">User</span> <span class="keyword">WHERE</span> Age <span class="operator">&gt;</span> <span class="number">25</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">User</span> <span class="keyword">VALUES</span> (&quot;Tom&quot;, <span class="number">25</span>), (&quot;Jack&quot;, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<p>在 Session 结构体中当 tx 不为空时，则使用 tx 执行 SQL 语句，否则使用 db 执行 SQL 语句。这样既兼容了普通的执行方式，又提供了对事务的支持。<br>具体实现参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/16184238/database-sql-tx-detecting-commit-or-rollback">stackoverflow</a><br><strong>engine:</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TxFunc <span class="function"><span class="keyword">func</span><span class="params">(*session.Session)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span></span> Transaction(f TxFunc) (res <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>) &#123;</span><br><span class="line">	s := e.NewSession()</span><br><span class="line">	<span class="keyword">if</span> err := s.Begin(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">			_ = s.RollBack()</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Info(<span class="string">&quot;come in err rollback&quot;</span>)</span><br><span class="line">			_ = s.RollBack()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			err = s.Commit()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> f(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>session:</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Begin 开启事务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> Begin() <span class="type">error</span> &#123;</span><br><span class="line">	log.Info(<span class="string">&quot;transaction begin&quot;</span>)</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	s.tx, err = s.db.Begin()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit 提交事务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> Commit() <span class="type">error</span> &#123;</span><br><span class="line">	log.Info(<span class="string">&quot;transaction commit&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err := s.tx.Commit(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RollBack 回滚事务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Session)</span></span> RollBack() <span class="type">error</span> &#123;</span><br><span class="line">	log.Info(<span class="string">&quot;transaction rollback&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err := s.tx.Rollback(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要将所有的操作放到一个回调函数<code>TxFunc</code>中，作为入参传递给engine.Transaction()，发生任何错误，自动回滚，如果没有错误发生，则提交。</p>
<h2 id="engine"><a href="#engine" class="headerlink" title="engine"></a>engine</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">	db      *sql.DB</span><br><span class="line">	dialect dialect.Dialect</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewEngine input : sqlite3,bank.db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEngine</span><span class="params">(driver, source <span class="type">string</span>)</span></span> (*Engine, <span class="type">error</span>) &#123;</span><br><span class="line">	db, err := sql.Open(driver, source)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := db.Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dial, ok := dialect.GetDialect(driver)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(fmt.Sprintf(<span class="string">&quot;dialect %s not found&quot;</span>, driver))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;Engine&#123;db: db, dialect: dial&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSession 新建session</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span></span> NewSession() *session.Session &#123;</span><br><span class="line">	<span class="keyword">return</span> session.NewSession(e.db, e.dialect)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 关闭数据库连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span></span> Close() &#123;</span><br><span class="line">	e.db.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TxFunc <span class="function"><span class="keyword">func</span><span class="params">(*session.Session)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Engine)</span></span> Transaction(f TxFunc) (res <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>) &#123;</span><br><span class="line">	s := e.NewSession()</span><br><span class="line">	<span class="keyword">if</span> err := s.Begin(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Info(<span class="string">&quot;come in recover rollback&quot;</span>)</span><br><span class="line">			log.Info(p)</span><br><span class="line">			_ = s.RollBack()</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Info(<span class="string">&quot;come in err rollback&quot;</span>)</span><br><span class="line">			_ = s.RollBack()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			err = s.Commit()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> f(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Engine 的逻辑非常简单，最重要的方法是<code>NewEngine</code>，主要做了两件事：</p>
<ol>
<li>连接数据库，返回 *sql.DB。</li>
<li>调用 db.Ping()，检查数据库是否能够正常连接。</li>
</ol>
<p>此外，提供了<code>Engine</code>提供了<code>NewSession()</code>方法，这样可以通过<code>Engine</code>实例创建会话，进而与数据库进行交互了。<br>对于<code>Transaction</code>方法已在上一节中介绍过了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这个小型项目的学习总结，学习到了一个orm的构建流程，过程中学习到：</p>
<ol>
<li>golang中reflect的实践练习；</li>
<li>orm的底层原理；</li>
<li>日志的等级控制；</li>
<li>tag的使用；</li>
</ol>
<p>目前实现的功能比较简单，后续可以继续进行研究，扩展功能，如：</p>
<ol>
<li>join、group，having等语句的支持；</li>
<li>多条where的链式调用，目前只支持单个where的调用，若有多个条件需要按照<code>name = ? and age = ?</code>的形式写入where，后续可以参考<code>gorm</code>的实现丰富and、or逻辑的链式调用；</li>
<li>增加mysql连接池的实现；</li>
<li>…</li>
</ol>
<p>本文的整体结构如下：<br><img src="/%E4%BD%BF%E7%94%A8golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84orm.resources/GemmaORM_struct.png" alt="GemmaORM_struct"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">bank</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/09/18/%E4%BD%BF%E7%94%A8golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84orm/">http://example.com/2023/09/18/%E4%BD%BF%E7%94%A8golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84orm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">bank blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/golang/">golang</a><a class="post-meta__tags" href="/tags/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/">工程实践</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/23/%E4%BD%BF%E7%94%A8golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84rpc/" title="使用golang实现简单的rpc"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">使用golang实现简单的rpc</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/18/linux%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/" title="linux命令记录"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">linux命令记录</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/09/07/%E4%BD%BF%E7%94%A8golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84web%E6%A1%86%E6%9E%B6/" title="使用golang实现简单的web框架"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-07</div><div class="title">使用golang实现简单的web框架</div></div></a></div><div><a href="/2023/09/10/%E4%BD%BF%E7%94%A8golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/" title="使用golang实现简单的分布式缓存"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-10</div><div class="title">使用golang实现简单的分布式缓存</div></div></a></div><div><a href="/2023/10/23/%E4%BD%BF%E7%94%A8golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84rpc/" title="使用golang实现简单的rpc"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-23</div><div class="title">使用golang实现简单的rpc</div></div></a></div><div><a href="/2023/05/19/golang%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%A1%A8/" title="golang实现跳表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-19</div><div class="title">golang实现跳表</div></div></a></div><div><a href="/2023/05/16/golang%E6%8C%87%E9%92%88/" title="golang指针讨论"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-16</div><div class="title">golang指针讨论</div></div></a></div><div><a href="/2023/08/08/golang%E7%9A%84GMP/" title="golang的GMP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-08</div><div class="title">golang的GMP</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">bank</div><div class="author-info__description">行至水穷处,坐看云起时</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BC%E8%AF%AD"><span class="toc-number">1.</span> <span class="toc-text">导语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dialect"><span class="toc-number">2.1.</span> <span class="toc-text">dialect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#schema"><span class="toc-number">2.2.</span> <span class="toc-text">schema</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clause"><span class="toc-number">2.3.</span> <span class="toc-text">clause</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.3.1.</span> <span class="toc-text">对外暴露接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.2.</span> <span class="toc-text">内部逻辑实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#select"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">update</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#insert"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">insert</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#delete"><span class="toc-number">2.3.2.4.</span> <span class="toc-text">delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#value"><span class="toc-number">2.3.2.5.</span> <span class="toc-text">value</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#where"><span class="toc-number">2.3.2.6.</span> <span class="toc-text">where</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#order"><span class="toc-number">2.3.2.7.</span> <span class="toc-text">order</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#limit"><span class="toc-number">2.3.2.8.</span> <span class="toc-text">limit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#count"><span class="toc-number">2.3.2.9.</span> <span class="toc-text">count</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#log"><span class="toc-number">2.4.</span> <span class="toc-text">log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#session"><span class="toc-number">2.5.</span> <span class="toc-text">session</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#raw"><span class="toc-number">2.5.1.</span> <span class="toc-text">raw</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#table"><span class="toc-number">2.5.2.</span> <span class="toc-text">table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#record"><span class="toc-number">2.5.3.</span> <span class="toc-text">record</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#insert-1"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">insert</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update-1"><span class="toc-number">2.5.3.2.</span> <span class="toc-text">update</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#delete-1"><span class="toc-number">2.5.3.3.</span> <span class="toc-text">delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find"><span class="toc-number">2.5.3.4.</span> <span class="toc-text">find</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#where-1"><span class="toc-number">2.5.3.5.</span> <span class="toc-text">where</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#limit-1"><span class="toc-number">2.5.3.6.</span> <span class="toc-text">limit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#order-1"><span class="toc-number">2.5.3.7.</span> <span class="toc-text">order</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#first"><span class="toc-number">2.5.3.8.</span> <span class="toc-text">first</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#count-1"><span class="toc-number">2.5.3.9.</span> <span class="toc-text">count</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hook"><span class="toc-number">2.5.4.</span> <span class="toc-text">hook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transaction"><span class="toc-number">2.5.5.</span> <span class="toc-text">transaction</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#engine"><span class="toc-number">2.6.</span> <span class="toc-text">engine</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/08/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%BC%96%E5%86%99%E6%96%B9%E6%B3%95/" title="测试用例编写方法">测试用例编写方法</a><time datetime="2023-11-08T11:22:27.040Z" title="发表于 2023-11-08 19:22:27">2023-11-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/23/%E4%BD%BF%E7%94%A8golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84rpc/" title="使用golang实现简单的rpc">使用golang实现简单的rpc</a><time datetime="2023-10-23T13:46:47.443Z" title="发表于 2023-10-23 21:46:47">2023-10-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/18/%E4%BD%BF%E7%94%A8golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84orm/" title="使用golang实现简单的orm">使用golang实现简单的orm</a><time datetime="2023-09-18T14:15:39.197Z" title="发表于 2023-09-18 22:15:39">2023-09-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/18/linux%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/" title="linux命令记录">linux命令记录</a><time datetime="2023-09-18T08:18:35.307Z" title="发表于 2023-09-18 16:18:35">2023-09-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/10/%E4%BD%BF%E7%94%A8golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/" title="使用golang实现简单的分布式缓存">使用golang实现简单的分布式缓存</a><time datetime="2023-09-10T05:40:09.505Z" title="发表于 2023-09-10 13:40:09">2023-09-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By bank</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>