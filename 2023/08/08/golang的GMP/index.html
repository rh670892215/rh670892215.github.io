<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>golang的GMP | bank blog</title><meta name="author" content="bank"><meta name="copyright" content="bank"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="article">
<meta property="og:title" content="golang的GMP">
<meta property="og:url" content="http://example.com/2023/08/08/golang%E7%9A%84GMP/index.html">
<meta property="og:site_name" content="bank blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-08-08T12:25:58.964Z">
<meta property="article:modified_time" content="2023-08-13T09:12:03.184Z">
<meta property="article:author" content="bank">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/08/08/golang%E7%9A%84GMP/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'golang的GMP',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-13 17:12:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="bank blog"><span class="site-name">bank blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">golang的GMP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-08T12:25:58.964Z" title="发表于 2023-08-08 20:25:58">2023-08-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-13T09:12:03.184Z" title="更新于 2023-08-13 17:12:03">2023-08-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/golang/">golang</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="golang的GMP"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer"/>

<span id="more"></span>

<h1 id="golang的GMP"><a href="#golang的GMP" class="headerlink" title="golang的GMP"></a>golang的GMP</h1><p>go语言拥有强大的并发能力，这归功于golang中的协程goroutine，对于其GMP模型网上的资源有很多，这里在学习之后进行总结，加深理解。</p>
<p>首先对比一下进程、线程、协程：（对于这里的区别本文不做过多赘述，本文只来探究golang的协程模型，这里后续单写一篇文章进行介绍）</p>
<ul>
<li>进程：程序运行的单位，是操作系统进行资源分配和调度的基本单位，进程间内存隔离，可以通过管道、信号、套接字等手段进行通信，同时，进程间切换的代价较高，需要从用户态切换成内核态，需要保存和回复比较多的上下文信息；</li>
<li>线程：线程是操作系统能够进行调度的最小单位，一个进程中可以开启多个线程，多个线程共享进程的内存空间，因此线程之间的通信比较简单，但是线程的崩溃可能会导致其他线程的崩溃，线程的切换开销小于进程，需要保存的上下文信息较少，但是也需要从用户态切换成内核态；</li>
<li>协程：协程是用户态的轻量级线程，协程的切换不需要切换到内核态，在用户态就可以实现切换，因此切换代价很小，只涉及到栈指针和程序计数器的切换，不需要上下文的保存和恢复，但是需要程序员维护协程的状态，进行调度和切换；</li>
</ul>
<p>golang之所以天然支持高并发就是因为其goroutine，本文对golang的协程调度进行研究。</p>
<h2 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h2><ul>
<li>G：协程结构体，一个<code>go func()</code>就会创建一个G；</li>
<li>M：内核线程，直接与操作系统进行交互，CPU调度的基本单元；</li>
<li>P：解耦G和M，管理<code>goroutine</code>的处理器，维护一个局部可运行的G队列；</li>
</ul>
<p><img src="/golang%E7%9A%84GMP.resources/GMP-%E8%B0%83%E5%BA%A6.png" alt="GMP-调度"></p>
<ul>
<li>全局队列：存放等待运行的G；</li>
<li>P的本地队列：与全局队列类似，也是存放等待运行的G，存放G的上限是256，若其中存储G的数量超过上限，则从本地队列中取出一半G放入到全局队列；</li>
<li>P列表：在程序初始化时P的数量就确定了，最多有<code>GOMAXPROCS</code>个；</li>
<li>M：从P中拿G执行，优先从本地队列中取，本地队列中若没有可执行的G则从全局队列中取一部分加入到本地队列或从其他本地队列偷一半放到自己P的本地队列。M运行G，G执行完成后会获取下一个G；M的最大数量是10000，若没有足够的M可以执行P，比如所有的M阻塞住了，但是还有很多P等待执行，这时就会新创建M；</li>
</ul>
<p>为什么一定要有P呢？<br><img src="https://mmbiz.qpic.cn/mmbiz_gif/FmVWPHrDdnnCNicPFSO8UrVpOetibsuuG23P8oL2pcUicqVKNCIMAakX36ib5CLZFjUcHeVmmdtyq31jQOMOfl4lUw/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="GM模型"><br>起初的golang使用的是GM模型（Go1.1之前），如上图所示，由一个全局队列管理全部的g，这个全局队列有一把大锁，m想获取g的时候就需要获取这把大锁，因此当并发量大的时候这把大锁就成为了性能瓶颈。<br>golang在原有的GM模型上增加了P，来对G和M解耦。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看GOMAXPROCS的值，也就是P的数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getGOMAXPROCS</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> runtime.GOMAXPROCS(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其调度过程如下：<br><img src="/golang%E7%9A%84GMP.resources/go-func%E8%B0%83%E5%BA%A6%E5%91%A8%E6%9C%9F.png" alt="go-func调度周期"></p>
<ol>
<li>执行<code>go func()</code>，创建G；</li>
<li>G优先入本地队列，若本地队列满了则入全局队列；</li>
<li>M从P中获取G执行，优先从本地队列获取，若本地队列没有则在全局队列中获取或从其他的MP组合偷P来执行；</li>
<li>若正在执行的G发生系统调用或遇到了阻塞，则会选取一个空闲的M或新建一个M接管阻塞的G，当前的M继续执行下一个G；</li>
</ol>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123; </span><br><span class="line">    <span class="comment">// 当前 Goroutine 的栈内存范围 [stack.lo, stack.hi)</span></span><br><span class="line">    stack       stack </span><br><span class="line">    <span class="comment">// 用于调度器抢占式调度  </span></span><br><span class="line">    stackguard0 <span class="type">uintptr</span>   </span><br><span class="line"></span><br><span class="line">    _panic       *_panic  </span><br><span class="line">    _defer       *_defer  </span><br><span class="line">    <span class="comment">// 当前 Goroutine 占用的线程</span></span><br><span class="line">    m            *m       </span><br><span class="line">    <span class="comment">// 存储 Goroutine 的调度相关的数据</span></span><br><span class="line">    sched        gobuf </span><br><span class="line">    <span class="comment">// Goroutine 的状态</span></span><br><span class="line">    atomicstatus <span class="type">uint32</span> </span><br><span class="line">    <span class="comment">// 抢占信号</span></span><br><span class="line">    preempt       <span class="type">bool</span> <span class="comment">// preemption signal, duplicates stackguard0 = stackpreempt</span></span><br><span class="line">    <span class="comment">// 抢占时将状态修改成 `_Gpreempted`</span></span><br><span class="line">    preemptStop   <span class="type">bool</span> <span class="comment">// transition to _Gpreempted on preemption; otherwise, just deschedule</span></span><br><span class="line">    <span class="comment">// 在同步安全点收缩栈</span></span><br><span class="line">    preemptShrink <span class="type">bool</span> <span class="comment">// shrink stack at synchronous safe point</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 栈指针</span></span><br><span class="line">    sp   <span class="type">uintptr</span></span><br><span class="line">    <span class="comment">// 程序计数器</span></span><br><span class="line">    pc   <span class="type">uintptr</span></span><br><span class="line">    <span class="comment">// gobuf对应的Goroutine</span></span><br><span class="line">    g    guintptr </span><br><span class="line">    <span class="comment">// 系统调用的返回值</span></span><br><span class="line">    ret  sys.Uintreg</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>G状态：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">//  刚刚被分配并且还没有被初始化</span></span><br><span class="line">    _Gidle = <span class="literal">iota</span> <span class="comment">// 0 </span></span><br><span class="line">    <span class="comment">// 没有执行代码，没有栈的所有权，存储在运行队列中</span></span><br><span class="line">    _Grunnable <span class="comment">// 1 </span></span><br><span class="line">    <span class="comment">// 可以执行代码，拥有栈的所有权，被赋予了内核线程 M 和处理器 P</span></span><br><span class="line">    _Grunning <span class="comment">// 2 </span></span><br><span class="line">    <span class="comment">// 正在执行系统调用，拥有栈的所有权，没有执行用户代码，</span></span><br><span class="line">    <span class="comment">// 被赋予了内核线程 M 但是不在运行队列上</span></span><br><span class="line">    _Gsyscall <span class="comment">// 3 </span></span><br><span class="line">    <span class="comment">// 由于运行时而被阻塞，没有执行用户代码并且不在运行队列上，</span></span><br><span class="line">    <span class="comment">// 但是可能存在于 Channel 的等待队列上</span></span><br><span class="line">    _Gwaiting <span class="comment">// 4  </span></span><br><span class="line">    <span class="comment">// 表示当前goroutine没有被使用，没有执行代码，可能有分配的栈</span></span><br><span class="line">    _Gdead <span class="comment">// 6  </span></span><br><span class="line">    <span class="comment">// 栈正在被拷贝，没有执行代码，不在运行队列上</span></span><br><span class="line">    _Gcopystack <span class="comment">// 8 </span></span><br><span class="line">    <span class="comment">// 由于抢占而被阻塞，没有执行用户代码并且不在运行队列上，等待唤醒</span></span><br><span class="line">    _Gpreempted <span class="comment">// 9 </span></span><br><span class="line">    <span class="comment">// GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在</span></span><br><span class="line">    _Gscan          = <span class="number">0x1000</span> </span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 持有调度栈的 Goroutine</span></span><br><span class="line">    g0      *g       </span><br><span class="line">    <span class="comment">// 处理 signal 的 G</span></span><br><span class="line">    gsignal       *g           </span><br><span class="line">    <span class="comment">// 线程本地存储 thread-local</span></span><br><span class="line">    tls           [<span class="number">6</span>]<span class="type">uintptr</span>   <span class="comment">// thread-local storage (for x86 extern register)</span></span><br><span class="line">    <span class="comment">// 当前运行的G</span></span><br><span class="line">    curg          *g       <span class="comment">// current running goroutine</span></span><br><span class="line">    caughtsig     guintptr <span class="comment">// goroutine running during fatal signal</span></span><br><span class="line">    <span class="comment">// 正在运行代码的P</span></span><br><span class="line">    p             puintptr <span class="comment">// attached p for executing go code (nil if not executing go code)</span></span><br><span class="line">    nextp         puintptr</span><br><span class="line">    <span class="comment">// 之前使用的P</span></span><br><span class="line">    oldp          puintptr  </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    id          <span class="type">int32</span></span><br><span class="line">    <span class="comment">// p 的状态</span></span><br><span class="line">    status      <span class="type">uint32</span>  </span><br><span class="line">    <span class="comment">// 调度器调用会+1</span></span><br><span class="line">    schedtick   <span class="type">uint32</span>     <span class="comment">// incremented on every scheduler call</span></span><br><span class="line">    <span class="comment">// 系统调用会+1</span></span><br><span class="line">    syscalltick <span class="type">uint32</span>     <span class="comment">// incremented on every system call</span></span><br><span class="line">    <span class="comment">// 对应关联的 M</span></span><br><span class="line">    m           muintptr    </span><br><span class="line">    mcache      *mcache</span><br><span class="line">    pcache      pageCache </span><br><span class="line">    <span class="comment">// defer 结构池</span></span><br><span class="line">    deferpool    [<span class="number">5</span>][]*_defer  </span><br><span class="line">    deferpoolbuf [<span class="number">5</span>][<span class="number">32</span>]*_defer  </span><br><span class="line">    <span class="comment">// 可运行的 Goroutine 队列，可无锁访问</span></span><br><span class="line">    runqhead <span class="type">uint32</span></span><br><span class="line">    runqtail <span class="type">uint32</span></span><br><span class="line">    runq     [<span class="number">256</span>]guintptr</span><br><span class="line">    <span class="comment">// 缓存可立即执行的 G</span></span><br><span class="line">    runnext guintptr </span><br><span class="line">    <span class="comment">// 可用的 G 列表，G 状态等于 Gdead </span></span><br><span class="line">    gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">        gList</span><br><span class="line">        n <span class="type">int32</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>P状态：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ( </span><br><span class="line">    <span class="comment">// 表示P没有运行用户代码或者调度器 </span></span><br><span class="line">    _Pidle = <span class="literal">iota</span> </span><br><span class="line">    <span class="comment">// 被线程 M 持有，并且正在执行用户代码或者调度器</span></span><br><span class="line">    _Prunning </span><br><span class="line">    <span class="comment">// 没有执行用户代码，当前线程陷入系统调用</span></span><br><span class="line">    _Psyscall</span><br><span class="line">    <span class="comment">// 被线程 M 持有，当前处理器由于垃圾回收 STW 被停止</span></span><br><span class="line">    _Pgcstop </span><br><span class="line">    <span class="comment">// 当前处理器已经不被使用</span></span><br><span class="line">    _Pdead</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    lock mutex </span><br><span class="line">    <span class="comment">// 空闲的 M 列表</span></span><br><span class="line">    midle        muintptr  </span><br><span class="line">    <span class="comment">// 空闲的 M 列表数量</span></span><br><span class="line">    nmidle       <span class="type">int32</span>      </span><br><span class="line">    <span class="comment">// 下一个被创建的 M 的 id</span></span><br><span class="line">    mnext        <span class="type">int64</span>  </span><br><span class="line">    <span class="comment">// 能拥有的最大数量的 M  </span></span><br><span class="line">    maxmcount    <span class="type">int32</span>    </span><br><span class="line">    <span class="comment">// 空闲 p 链表</span></span><br><span class="line">    pidle      puintptr <span class="comment">// idle p&#x27;s</span></span><br><span class="line">    <span class="comment">// 空闲 p 数量</span></span><br><span class="line">    npidle     <span class="type">uint32</span></span><br><span class="line">    <span class="comment">// 处于 spinning 状态的 M 的数量</span></span><br><span class="line">    nmspinning <span class="type">uint32</span>   </span><br><span class="line">    <span class="comment">// 全局 runnable G 队列</span></span><br><span class="line">    runq     gQueue</span><br><span class="line">    runqsize <span class="type">int32</span>  </span><br><span class="line">    <span class="comment">// 有效 dead G 的全局缓存.</span></span><br><span class="line">    gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">        lock    mutex</span><br><span class="line">        stack   gList <span class="comment">// Gs with stacks</span></span><br><span class="line">        noStack gList <span class="comment">// Gs without stacks</span></span><br><span class="line">        n       <span class="type">int32</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// sudog 结构的集中缓存</span></span><br><span class="line">    sudoglock  mutex</span><br><span class="line">    sudogcache *sudog </span><br><span class="line">    <span class="comment">// defer 结构的池</span></span><br><span class="line">    deferlock mutex</span><br><span class="line">    deferpool [<span class="number">5</span>]*_defer </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调度器-1"><a href="#调度器-1" class="headerlink" title="调度器"></a>调度器</h2><p>为了更好的理解调度器，首先来看一下golang程序的启动过程。</p>
<h3 id="程序启动"><a href="#程序启动" class="headerlink" title="程序启动"></a>程序启动</h3><p>本文使用的go版本是1.20.2<br>golang程序启动并不是直接从<code>main</code>函数开始的，下面是程序启动的汇编程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT|TOPFRAME,$<span class="number">0</span></span><br><span class="line">	</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 初始化G0</span></span><br><span class="line">	MOVD	$runtime·g0(SB), g</span><br><span class="line">	...</span><br><span class="line">        <span class="comment">// 初始化M0</span></span><br><span class="line">	MOVD	$runtime·m0(SB), R2</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绑定M0和G0</span></span><br><span class="line">	MOVD	g, m_g0(R2)</span><br><span class="line">	MOVD	R2, g_m(g)</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化main参数</span></span><br><span class="line">	BL	runtime·args(SB)</span><br><span class="line">        <span class="comment">// 初始化os</span></span><br><span class="line">	BL	runtime·osinit(SB)</span><br><span class="line">        <span class="comment">// 初始化调度器</span></span><br><span class="line">	BL	runtime·schedinit(SB)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// main函数入口</span></span><br><span class="line">	MOVD	$runtime·mainPC(SB), R2		<span class="comment">// entry</span></span><br><span class="line">        CALL	runtime·newproc(SB)</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始调度器循环</span></span><br><span class="line">	BL	runtime·mstart(SB)</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数入口地址</span></span><br><span class="line">DATA	runtime·mainPC+<span class="number">0</span>(SB)/<span class="number">8</span>,$runtime·main(SB)</span><br><span class="line">GLOBL	runtime·mainPC(SB),RODATA,$<span class="number">8</span></span><br></pre></td></tr></table></figure>

<h3 id="调度器初始化"><a href="#调度器初始化" class="headerlink" title="调度器初始化"></a>调度器初始化</h3><p>再来看<code>schedinit</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码文件路径：/src/runtime/proc.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">	<span class="comment">// raceinit must be the first call to race detector.</span></span><br><span class="line">	<span class="comment">// In particular, it must be done before mallocinit below calls racemapshadow.</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		_g_.racectx, raceprocctx0 = raceinit()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sched.maxmcount = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The world starts stopped.</span></span><br><span class="line">	worldStopped()</span><br><span class="line"></span><br><span class="line">	moduledataverify()</span><br><span class="line">	stackinit()</span><br><span class="line">	mallocinit()</span><br><span class="line">	cpuinit()      <span class="comment">// must run before alginit</span></span><br><span class="line">	alginit()      <span class="comment">// maps, hash, fastrand must not be used before this call</span></span><br><span class="line">	fastrandinit() <span class="comment">// must run before mcommoninit</span></span><br><span class="line">	mcommoninit(_g_.m, <span class="number">-1</span>)</span><br><span class="line">	modulesinit()   <span class="comment">// provides activeModules</span></span><br><span class="line">	typelinksinit() <span class="comment">// uses maps, activeModules</span></span><br><span class="line">	itabsinit()     <span class="comment">// uses activeModules</span></span><br><span class="line">	stkobjinit()    <span class="comment">// must run before GC starts</span></span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	goargs()</span><br><span class="line">	goenvs()</span><br><span class="line">	parsedebugvars()</span><br><span class="line">	gcinit()</span><br><span class="line"></span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	sched.lastpoll = <span class="type">uint64</span>(nanotime())</span><br><span class="line">	procs := ncpu</span><br><span class="line">	<span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">&quot;GOMAXPROCS&quot;</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		procs = n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;unknown runnable goroutine during bootstrap&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，m的上限设定成10000，p的数量初始化成<code>GOMAXPROCS</code>的值，若<code>GOMAXPROCS</code>没配置，则取cpu核心数量。</p>
<h3 id="M初始化"><a href="#M初始化" class="headerlink" title="M初始化"></a>M初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mcommoninit</span><span class="params">(mp *m, id <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// g0 stack won&#x27;t make sense for user (and is not necessary unwindable).</span></span><br><span class="line">	<span class="keyword">if</span> _g_ != _g_.m.g0 &#123;</span><br><span class="line">		callers(<span class="number">1</span>, mp.createstack[:])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> id &gt;= <span class="number">0</span> &#123;</span><br><span class="line">		mp.id = id</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mp.id = mReserveID()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lo := <span class="type">uint32</span>(int64Hash(<span class="type">uint64</span>(mp.id), fastrandseed))</span><br><span class="line">	hi := <span class="type">uint32</span>(int64Hash(<span class="type">uint64</span>(cputicks()), ^fastrandseed))</span><br><span class="line">	<span class="keyword">if</span> lo|hi == <span class="number">0</span> &#123;</span><br><span class="line">		hi = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Same behavior as for 1.17.</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Simplify ths.</span></span><br><span class="line">	<span class="keyword">if</span> goarch.BigEndian &#123;</span><br><span class="line">		mp.fastrand = <span class="type">uint64</span>(lo)&lt;&lt;<span class="number">32</span> | <span class="type">uint64</span>(hi)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mp.fastrand = <span class="type">uint64</span>(hi)&lt;&lt;<span class="number">32</span> | <span class="type">uint64</span>(lo)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mpreinit(mp)</span><br><span class="line">	<span class="keyword">if</span> mp.gsignal != <span class="literal">nil</span> &#123;</span><br><span class="line">		mp.gsignal.stackguard1 = mp.gsignal.stack.lo + _StackGuard</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add to allm so garbage collector doesn&#x27;t free g-&gt;m</span></span><br><span class="line">	<span class="comment">// when it is just in a register or thread-local storage.</span></span><br><span class="line">	mp.alllink = allm</span><br><span class="line"></span><br><span class="line">	<span class="comment">// NumCgoCall() iterates over allm w/o schedlock,</span></span><br><span class="line">	<span class="comment">// so we need to publish it safely.</span></span><br><span class="line">	atomicstorep(unsafe.Pointer(&amp;allm), unsafe.Pointer(mp))</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate memory to hold a cgo traceback if the cgo call crashes.</span></span><br><span class="line">	<span class="keyword">if</span> iscgo || GOOS == <span class="string">&quot;solaris&quot;</span> || GOOS == <span class="string">&quot;illumos&quot;</span> || GOOS == <span class="string">&quot;windows&quot;</span> &#123;</span><br><span class="line">		mp.cgoCallers = <span class="built_in">new</span>(cgoCallers)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序的核心是把M0加入到全局链表<code>allm</code>中。全局变量<code>allm</code>用于存储所有活动的M的链表，这样的目的是确保垃圾回收器不会在M仅存在于寄存器或线程本地存储中时被释放。</p>
<h3 id="P初始化"><a href="#P初始化" class="headerlink" title="P初始化"></a>P初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">procresize</span><span class="params">(nprocs <span class="type">int32</span>)</span></span> *p &#123;</span><br><span class="line">	assertLockHeld(&amp;sched.lock)</span><br><span class="line">	assertWorldStopped()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取之前的P个数</span></span><br><span class="line">	old := gomaxprocs</span><br><span class="line">	<span class="keyword">if</span> old &lt; <span class="number">0</span> || nprocs &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;procresize: invalid arg&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGomaxprocs(nprocs)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新统计信息</span></span><br><span class="line">	now := nanotime()</span><br><span class="line">	<span class="keyword">if</span> sched.procresizetime != <span class="number">0</span> &#123;</span><br><span class="line">		sched.totaltime += <span class="type">int64</span>(old) * (now - sched.procresizetime)</span><br><span class="line">	&#125;</span><br><span class="line">	sched.procresizetime = now</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算需要多少位32位的字来表示全部的P</span></span><br><span class="line">	maskWords := (nprocs + <span class="number">31</span>) / <span class="number">32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据runtime.MAXGOPROCS调整p的数量</span></span><br><span class="line">	<span class="keyword">if</span> nprocs &gt; <span class="type">int32</span>(<span class="built_in">len</span>(allp)) &#123;</span><br><span class="line">		<span class="comment">// Synchronize with retake, which could be running</span></span><br><span class="line">		<span class="comment">// concurrently since it doesn&#x27;t run on a P.</span></span><br><span class="line">		lock(&amp;allpLock)</span><br><span class="line">		<span class="keyword">if</span> nprocs &lt;= <span class="type">int32</span>(<span class="built_in">cap</span>(allp)) &#123;</span><br><span class="line">			allp = allp[:nprocs]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			nallp := <span class="built_in">make</span>([]*p, nprocs)</span><br><span class="line">			<span class="comment">// Copy everything up to allp&#x27;s cap so we</span></span><br><span class="line">			<span class="comment">// never lose old allocated Ps.</span></span><br><span class="line">			<span class="built_in">copy</span>(nallp, allp[:<span class="built_in">cap</span>(allp)])</span><br><span class="line">			allp = nallp</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调整idlepMask、timerpMask。idlepMask和timerpMask是用于跟踪空闲P（处理器）和定时器P的位图</span></span><br><span class="line">		<span class="keyword">if</span> maskWords &lt;= <span class="type">int32</span>(<span class="built_in">cap</span>(idlepMask)) &#123;</span><br><span class="line">			idlepMask = idlepMask[:maskWords]</span><br><span class="line">			timerpMask = timerpMask[:maskWords]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			nidlepMask := <span class="built_in">make</span>([]<span class="type">uint32</span>, maskWords)</span><br><span class="line">			<span class="built_in">copy</span>(nidlepMask, idlepMask)</span><br><span class="line">			idlepMask = nidlepMask</span><br><span class="line"></span><br><span class="line">			ntimerpMask := <span class="built_in">make</span>([]<span class="type">uint32</span>, maskWords)</span><br><span class="line">			<span class="built_in">copy</span>(ntimerpMask, timerpMask)</span><br><span class="line">			timerpMask = ntimerpMask</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;allpLock)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化新的p</span></span><br><span class="line">	<span class="keyword">for</span> i := old; i &lt; nprocs; i++ &#123;</span><br><span class="line">		pp := allp[i]</span><br><span class="line">		<span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">			pp = <span class="built_in">new</span>(p)</span><br><span class="line">		&#125;</span><br><span class="line">		pp.init(i)</span><br><span class="line">		atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前的p</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	<span class="comment">// 若p不是空，且id小于nprocs，则继续使用当前的p</span></span><br><span class="line">	<span class="keyword">if</span> gp.m.p != <span class="number">0</span> &amp;&amp; gp.m.p.ptr().id &lt; nprocs &#123;</span><br><span class="line">		<span class="comment">// continue to use the current P</span></span><br><span class="line">		gp.m.p.ptr().status = _Prunning</span><br><span class="line">		gp.m.p.ptr().mcache.prepareForSweep()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 当前p已经失效，释放当前p</span></span><br><span class="line">		<span class="keyword">if</span> gp.m.p != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">				traceGoSched()</span><br><span class="line">				traceProcStop(gp.m.p.ptr())</span><br><span class="line">			&#125;</span><br><span class="line">			gp.m.p.ptr().m = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		gp.m.p = <span class="number">0</span></span><br><span class="line">		pp := allp[<span class="number">0</span>]</span><br><span class="line">		pp.m = <span class="number">0</span></span><br><span class="line">		<span class="comment">// 设置p的状态是_Pidle</span></span><br><span class="line">		pp.status = _Pidle</span><br><span class="line">		<span class="comment">// P0绑定M0</span></span><br><span class="line">		acquirep(pp)</span><br><span class="line">		<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">			traceGoStart()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// g.m.p is now set, so we no longer need mcache0 for bootstrapping.</span></span><br><span class="line">	mcache0 = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 清理未使用的P</span></span><br><span class="line">	<span class="keyword">for</span> i := nprocs; i &lt; old; i++ &#123;</span><br><span class="line">		pp := allp[i]</span><br><span class="line">		pp.destroy()</span><br><span class="line">		<span class="comment">// can&#x27;t free P itself because it can be referenced by an M in syscall</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重置allp长度</span></span><br><span class="line">	<span class="keyword">if</span> <span class="type">int32</span>(<span class="built_in">len</span>(allp)) != nprocs &#123;</span><br><span class="line">		lock(&amp;allpLock)</span><br><span class="line">		allp = allp[:nprocs]</span><br><span class="line">		idlepMask = idlepMask[:maskWords]</span><br><span class="line">		timerpMask = timerpMask[:maskWords]</span><br><span class="line">		unlock(&amp;allpLock)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> runnablePs *p</span><br><span class="line">	<span class="comment">// 遍历全部p</span></span><br><span class="line">	<span class="keyword">for</span> i := nprocs - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		pp := allp[i]</span><br><span class="line">		<span class="comment">// 跳过当前正在使用的p</span></span><br><span class="line">		<span class="keyword">if</span> gp.m.p.ptr() == pp &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		pp.status = _Pidle</span><br><span class="line">		<span class="keyword">if</span> runqempty(pp) &#123;</span><br><span class="line">			<span class="comment">// 将任务列表是空的p放入空闲列表</span></span><br><span class="line">			pidleput(pp, now)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 获取空闲的m绑定到p</span></span><br><span class="line">			pp.m.set(mget())</span><br><span class="line">			pp.link.set(runnablePs)</span><br><span class="line">			runnablePs = pp</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	stealOrder.reset(<span class="type">uint32</span>(nprocs))</span><br><span class="line">	<span class="keyword">var</span> int32p *<span class="type">int32</span> = &amp;gomaxprocs <span class="comment">// make compiler check that gomaxprocs is an int32</span></span><br><span class="line">	atomic.Store((*<span class="type">uint32</span>)(unsafe.Pointer(int32p)), <span class="type">uint32</span>(nprocs))</span><br><span class="line">	<span class="keyword">if</span> old != nprocs &#123;</span><br><span class="line">		<span class="comment">// Notify the limiter that the amount of procs has changed.</span></span><br><span class="line">		gcCPULimiter.resetCapacity(now, nprocs)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> runnablePs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>首先会根据runtime.MAXGOPROCS调整p的数量，多余的截断，不足的新建p，并进行初始化，初始化的id是在allp全局数组中的索引，状态是<code>_Pgcstop</code>；</li>
<li>同时更新用于跟踪空闲P（处理器）和定时器P的位图；</li>
<li>然后获取M0，若M0已经和有效的P绑定上，则修改P的状态成<code>_Prunning</code>，否则获取allp[0]作为P0与M0进行绑定；</li>
<li>超过处理器个数的P通过<code>p.destroy</code>进行释放；</li>
<li>最后遍历<code>allp</code>检查P的状态，将空闲的P放入空闲列表；</li>
</ol>
<h3 id="G初始化"><a href="#G初始化" class="headerlink" title="G初始化"></a>G初始化</h3><p>G初始化的入口如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(fn *funcval)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取当前的g</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	<span class="comment">// 获取程序计数器</span></span><br><span class="line">	pc := getcallerpc()</span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 获取新的g结构体</span></span><br><span class="line">		newg := newproc1(fn, gp, pc)</span><br><span class="line"></span><br><span class="line">		pp := getg().m.p.ptr()</span><br><span class="line">		<span class="comment">// 将g放入到p的运行队列</span></span><br><span class="line">		runqput(pp, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> mainStarted &#123;</span><br><span class="line">			<span class="comment">// 唤醒新的p执行g</span></span><br><span class="line">			wakep()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li><code>newproc</code>获取当前的g和调用方的程序计数器，然后调用<code>newproc</code>创建新的g结构体；</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, callergp *g, callerpc <span class="type">uintptr</span>)</span></span> *g &#123;</span><br><span class="line">	<span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">		fatal(<span class="string">&quot;go of nil func value&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加锁，防止g的m被抢占</span></span><br><span class="line">	mp := acquirem() <span class="comment">// disable preemption because we hold M and P in local vars.</span></span><br><span class="line">	pp := mp.p.ptr()</span><br><span class="line">	<span class="comment">// 获取空闲的g</span></span><br><span class="line">	newg := gfget(pp)</span><br><span class="line">	<span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 若没获取到空闲的p，则新建一个p，栈大小初始化成2k</span></span><br><span class="line">		newg = malg(_StackMin)</span><br><span class="line">		casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">		allgadd(newg) <span class="comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#x27;t look at uninitialized stack.</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> newg.stack.hi == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;newproc1: newg missing stack&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> readgstatus(newg) != _Gdead &#123;</span><br><span class="line">		throw(<span class="string">&quot;newproc1: new g is not Gdead&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置栈顶指针</span></span><br><span class="line">	totalSize := <span class="type">uintptr</span>(<span class="number">4</span>*goarch.PtrSize + sys.MinFrameSize) <span class="comment">// extra space in case of reads slightly beyond frame</span></span><br><span class="line">	totalSize = alignUp(totalSize, sys.StackAlign)</span><br><span class="line">	sp := newg.stack.hi - totalSize</span><br><span class="line">	spArg := sp</span><br><span class="line">	<span class="keyword">if</span> usesLR &#123;</span><br><span class="line">		<span class="comment">// caller&#x27;s LR</span></span><br><span class="line">		*(*<span class="type">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span><br><span class="line">		prepGoExitFrame(sp)</span><br><span class="line">		spArg += sys.MinFrameSize</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置一些结构体、栈相关的指针</span></span><br><span class="line">	memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line">	newg.sched.sp = sp</span><br><span class="line">	newg.stktopsp = sp</span><br><span class="line">	newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function</span></span><br><span class="line">	newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">	gostartcallfn(&amp;newg.sched, fn)</span><br><span class="line">	newg.gopc = callerpc</span><br><span class="line">	newg.ancestors = saveAncestors(callergp)</span><br><span class="line">	newg.startpc = fn.fn</span><br><span class="line">	<span class="keyword">if</span> isSystemGoroutine(newg, <span class="literal">false</span>) &#123;</span><br><span class="line">		sched.ngsys.Add(<span class="number">1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Only user goroutines inherit pprof labels.</span></span><br><span class="line">		<span class="keyword">if</span> mp.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">			newg.labels = mp.curg.labels</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> goroutineProfile.active &#123;</span><br><span class="line">			<span class="comment">// A concurrent goroutine profile is running. It should include</span></span><br><span class="line">			<span class="comment">// exactly the set of goroutines that were alive when the goroutine</span></span><br><span class="line">			<span class="comment">// profiler first stopped the world. That does not include newg, so</span></span><br><span class="line">			<span class="comment">// mark it as not needing a profile before transitioning it from</span></span><br><span class="line">			<span class="comment">// _Gdead.</span></span><br><span class="line">			newg.goroutineProfiled.Store(goroutineProfileSatisfied)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Track initial transition?</span></span><br><span class="line">	newg.trackingSeq = <span class="type">uint8</span>(fastrand())</span><br><span class="line">	<span class="keyword">if</span> newg.trackingSeq%gTrackingPeriod == <span class="number">0</span> &#123;</span><br><span class="line">		newg.tracking = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	casgstatus(newg, _Gdead, _Grunnable)</span><br><span class="line">	gcController.addScannableStack(pp, <span class="type">int64</span>(newg.stack.hi-newg.stack.lo))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pp.goidcache == pp.goidcacheend &#123;</span><br><span class="line">		<span class="comment">// Sched.goidgen is the last allocated id,</span></span><br><span class="line">		<span class="comment">// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].</span></span><br><span class="line">		<span class="comment">// At startup sched.goidgen=0, so main goroutine receives goid=1.</span></span><br><span class="line">		pp.goidcache = sched.goidgen.Add(_GoidCacheBatch)</span><br><span class="line">		pp.goidcache -= _GoidCacheBatch - <span class="number">1</span></span><br><span class="line">		pp.goidcacheend = pp.goidcache + _GoidCacheBatch</span><br><span class="line">	&#125;</span><br><span class="line">	newg.goid = pp.goidcache</span><br><span class="line">	pp.goidcache++</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		newg.racectx = racegostart(callerpc)</span><br><span class="line">		<span class="keyword">if</span> newg.labels != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// See note in proflabel.go on labelSync&#x27;s role in synchronizing</span></span><br><span class="line">			<span class="comment">// with the reads in the signal handler.</span></span><br><span class="line">			racereleasemergeg(newg, unsafe.Pointer(&amp;labelSync))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoCreate(newg, newg.startpc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 解锁</span></span><br><span class="line">	releasem(mp)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>首先从系统中获取空闲的g，若没有则新建一个栈大小是2k的g；</li>
<li>设置一些g相关的结构体指针；（这里比较复杂，后续单独进行研究）</li>
</ol>
<p>接着来看空闲g的获取：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gfget</span><span class="params">(pp *p)</span></span> *g &#123;</span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">// 若p的空闲列表gFree是空，且sched的空闲列表gFree非空</span></span><br><span class="line">	<span class="keyword">if</span> pp.gFree.empty() &amp;&amp; (!sched.gFree.stack.empty() || !sched.gFree.noStack.empty()) &#123;</span><br><span class="line">		<span class="comment">// golang中goroutine退出后并不会马上被系统回收，当创建新的goroutine时，系统可以从sched的gFree中取出一个已经存在的goroutine复用</span></span><br><span class="line">		lock(&amp;sched.gFree.lock)</span><br><span class="line">		<span class="comment">// 从sched.gFree列表中移出32个空闲的goroutine给p的gFree</span></span><br><span class="line">		<span class="keyword">for</span> pp.gFree.n &lt; <span class="number">32</span> &#123;</span><br><span class="line">			<span class="comment">// Prefer Gs with stacks.</span></span><br><span class="line">			gp := sched.gFree.stack.pop()</span><br><span class="line">			<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">				gp = sched.gFree.noStack.pop()</span><br><span class="line">				<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			sched.gFree.n--</span><br><span class="line">			pp.gFree.push(gp)</span><br><span class="line">			pp.gFree.n++</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;sched.gFree.lock)</span><br><span class="line">		<span class="keyword">goto</span> retry</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从p的gFree队头移出一个g返回</span></span><br><span class="line">	gp := pp.gFree.pop()</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>若p的空闲g列表是空，则从sched持有的空闲g列表转移32个g到p的gFree；</li>
<li>从p的gFree的队头返回一个g；</li>
</ol>
<p>对于<code>runqput</code>函数，是负责将g加入到p的运行队列，其流程如下：</p>
<ol>
<li>如果 next 为 false，则 runqput 将 g 添加到可运行队列的尾部。</li>
<li>如果 next 为 true，则 runqput 将 g 放入 pp.runnext 位置。</li>
<li>如果可运行队列已满，则 runqput 将 g 放入全局队列。<br>注意这里本地队列是一个上限是256的环形链表；</li>
</ol>
<p>至此，全部的初始化工作也就完成了，下面进行调度。</p>
<p>调度的入口函数是<code>schedule</code>，其中寻找可执行的g的函数是<code>findRunnable</code>，我们主要对<code>findRunnable</code>函数进行研究。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pp.schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    gp := globrunqget(pp, <span class="number">1</span>)</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">    <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了保证公平，调度器每工作61次，就会尝试从全局队列中取出待运行的g来执行。</p>
<p>首先在p的本地队列获取可以执行的g，源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若inheritTime是true则返回的g继承当前剩余的时间片，若inheritTime是false则g新建一个时间片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqget</span><span class="params">(pp *p)</span></span> (gp *g, inheritTime <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">// 若runnext非空，即找到了下一个待执行的g，直接返回</span></span><br><span class="line">	next := pp.runnext</span><br><span class="line">	<span class="keyword">if</span> next != <span class="number">0</span> &amp;&amp; pp.runnext.cas(next, <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> next.ptr(), <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		h := atomic.LoadAcq(&amp;pp.runqhead) <span class="comment">// load-acquire, synchronize with other consumers</span></span><br><span class="line">		t := pp.runqtail</span><br><span class="line">		<span class="keyword">if</span> t == h &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 遍历本地链表(环形链表，方便复用)，</span></span><br><span class="line">		gp := pp.runq[h%<span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))].ptr()</span><br><span class="line">		<span class="keyword">if</span> atomic.CasRel(&amp;pp.runqhead, h, h+<span class="number">1</span>) &#123; <span class="comment">// cas-release, commits consume</span></span><br><span class="line">			<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>本地队列先从runtext字段中获取，若不为空则直接返回，接下来遍历本地队列（环形队列）寻找g；</li>
</ol>
<p>接下来在全局队列中拿g，源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">globrunqget</span><span class="params">(pp *p, max <span class="type">int32</span>)</span></span> *g &#123;</span><br><span class="line">	assertLockHeld(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> sched.runqsize == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算n，用全局队列的长度/p的数量 + 1</span></span><br><span class="line">	n := sched.runqsize/gomaxprocs + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> n &gt; sched.runqsize &#123;</span><br><span class="line">		n = sched.runqsize</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> max &gt; <span class="number">0</span> &amp;&amp; n &gt; max &#123;</span><br><span class="line">		n = max</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">// n的上限不能超过本地队列长度的一半</span></span><br><span class="line">	<span class="keyword">if</span> n &gt; <span class="type">int32</span>(<span class="built_in">len</span>(pp.runq))/<span class="number">2</span> &#123;</span><br><span class="line">		n = <span class="type">int32</span>(<span class="built_in">len</span>(pp.runq)) / <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sched.runqsize -= n</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将全局队列中队首的g拿出来，作为待执行的g返回</span></span><br><span class="line">	gp := sched.runq.pop()</span><br><span class="line">	n--</span><br><span class="line">	<span class="comment">// 将“全局队列的长度/p的数量”个g从全局队列移到p的本地队列</span></span><br><span class="line">	<span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n-- &#123;</span><br><span class="line">		gp1 := sched.runq.pop()</span><br><span class="line">		runqput(pp, gp1, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>从全局队列中获取<code>全局队列的长度/p的数量 + 1</code>个g（这个值上限是全局队列长度的一半），其中第一个g用于执行，剩余的g加入到本地队列；</li>
</ol>
<p>接着会从网络轮询器中获取可以运行的g，也就是网络IO已经ready的g，源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> netpollinited() &amp;&amp; netpollWaiters.Load() &gt; <span class="number">0</span> &amp;&amp; sched.lastpoll.Load() != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> list := netpoll(<span class="number">0</span>); !list.empty() &#123; <span class="comment">// non-blocking</span></span><br><span class="line">		gp := list.pop()</span><br><span class="line">		injectglist(&amp;list)</span><br><span class="line">		casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">		<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">			traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>首先，它检查网络轮询器是否已经初始化，是否有等待的Goroutine，以及是否有其他线程已经在执行网络轮询。如果这些条件都满足，它会执行网络轮询；</li>
<li>netpoll(0)函数执行非阻塞的网络轮询。如果有网络I&#x2F;O事件发生，它会返回一个包含了所有可运行Goroutine的列表；</li>
<li>如果列表不为空，它会从列表中弹出一个Goroutine，并将剩余的Goroutine注入到全局的运行队列中；</li>
<li>然后，它会将这个Goroutine的状态从等待状态（_Gwaiting）更改为可运行状态（_Grunnable）；</li>
<li>最后，它返回这个Goroutine，以及两个表示是否从本地运行队列或全局运行队列获取Goroutine的布尔值。在这种情况下，这两个布尔值都是false，因为Goroutine是从网络轮询器中获取的；</li>
</ol>
<p>这里在偷取其他p中的g前会先设置自旋m的数量上限，不能大于忙碌的p的一半，避免多余的cpu消耗，源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> mp.spinning || <span class="number">2</span>*sched.nmspinning.Load() &lt; gomaxprocs-sched.npidle.Load() </span><br></pre></td></tr></table></figure>

<p>接下来去其他的p中“偷取”g，源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stealWork</span><span class="params">(now <span class="type">int64</span>)</span></span> (gp *g, inheritTime <span class="type">bool</span>, rnow, pollUntil <span class="type">int64</span>, newWork <span class="type">bool</span>) &#123;</span><br><span class="line">	pp := getg().m.p.ptr()</span><br><span class="line"></span><br><span class="line">	ranTimer := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> stealTries = <span class="number">4</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; stealTries; i++ &#123;</span><br><span class="line">		stealTimersOrRunNextG := i == stealTries<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 按照一定的顺序遍历所有的p，这里看应该是用了一个hash映射去遍历</span></span><br><span class="line">		<span class="keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;</span><br><span class="line">			<span class="comment">// 若有GC任务等待执行，则直接返回，让出处理器</span></span><br><span class="line">			<span class="keyword">if</span> sched.gcwaiting.Load() &#123;</span><br><span class="line">				<span class="comment">// GC work may be available.</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, now, pollUntil, <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 遍历到的p</span></span><br><span class="line">			p2 := allp[enum.position()]</span><br><span class="line">			<span class="comment">// 若取到当前的p，continue</span></span><br><span class="line">			<span class="keyword">if</span> pp == p2 &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 若是最后一次偷取尝试，且当前处理器可能有定时器任务，则偷取定时器任务</span></span><br><span class="line">			<span class="keyword">if</span> stealTimersOrRunNextG &amp;&amp; timerpMask.read(enum.position()) &#123;</span><br><span class="line">				tnow, w, ran := checkTimers(p2, now)</span><br><span class="line">				now = tnow</span><br><span class="line">				<span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; (pollUntil == <span class="number">0</span> || w &lt; pollUntil) &#123;</span><br><span class="line">					pollUntil = w</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> ran &#123;</span><br><span class="line">					<span class="keyword">if</span> gp, inheritTime := runqget(pp); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> gp, inheritTime, now, pollUntil, ranTimer</span><br><span class="line">					&#125;</span><br><span class="line">					ranTimer = <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 用idlepMask记录p的空闲状态，偷取非空闲的p中的g</span></span><br><span class="line">			<span class="keyword">if</span> !idlepMask.read(enum.position()) &#123;</span><br><span class="line">				<span class="keyword">if</span> gp := runqsteal(pp, p2, stealTimersOrRunNextG); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> gp, <span class="literal">false</span>, now, pollUntil, ranTimer</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若没偷取到g，则设置一个定时器，后续再进行偷取</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, now, pollUntil, ranTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>一共尝试4次偷取，每次都去遍历所有的p，其遍历顺序是通过一个hash映射确定的；</li>
<li>通过idlepMask来寻找非空闲的p，从中偷取g；</li>
<li>若是最后一次偷取则偷取p的定时器队列；</li>
</ol>
<p>这里简单介绍一下定时器队列：</p>
<ul>
<li>本地的 goroutine 运行队列：这是一个环形队列，用于存储等待在该处理器上运行的 goroutine。这个队列的长度上限是 256，这意味着每个处理器最多可以管理 256 个 goroutine。当这个队列满时，新的 goroutine 会被放入全局的运行队列，或者被放入其他处理器的本地运行队列（这取决于工作窃取的策略）；</li>
<li>本地的定时器队列：这是一个按照触发时间排序的队列，用于存储该处理器上的定时器任务。这个队列没有固定的长度上限，它可以根据需要动态地增长和缩小。当一个定时器任务的触发时间到达时，运行时系统会从队列中取出这个任务并执行它；</li>
</ul>
<p>实际的偷取g函数源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqsteal</span><span class="params">(pp, p2 *p, stealRunNextG <span class="type">bool</span>)</span></span> *g &#123;</span><br><span class="line">	t := pp.runqtail</span><br><span class="line">	n := runqgrab(p2, &amp;pp.runq, t, stealRunNextG)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	n--</span><br><span class="line">	gp := pp.runq[(t+n)%<span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))].ptr()</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> gp</span><br><span class="line">	&#125;</span><br><span class="line">	h := atomic.LoadAcq(&amp;pp.runqhead) <span class="comment">// load-acquire, synchronize with consumers</span></span><br><span class="line">	<span class="keyword">if</span> t-h+n &gt;= <span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq)) &#123;</span><br><span class="line">		throw(<span class="string">&quot;runqsteal: runq overflow&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	atomic.StoreRel(&amp;pp.runqtail, t+n) <span class="comment">// store-release, makes the item available for consumption</span></span><br><span class="line">	<span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li>从其他的p中偷取一半的g放到当前p的本地队列，并返回第一个g；</li>
</ol>
<p>若上面的逻辑都没有获取到可执行的g，接下来会进行一系列的校验操作，源码比较复杂这里不进行列举了，下面总结一下<code>findrunnable</code>函数的流程：</p>
<ol>
<li>首先检查是否在GC，若正在GC则暂停现在的M；</li>
<li>从本地队列、全局队列中查找g；</li>
<li>从网络轮询器中查找是否有g等待运行；</li>
<li>从其他p上窃取g，窃取正在执行的p的一半g到当前p的本地队列，这里allp的遍历从随机位置的p开始，避免每次遍历都使用相同的顺序访问allp中的元素；</li>
<li>若本地队列、全局队列、网络轮询器、其他p都没能找到g，在休眠m前进行一些检查；</li>
<li>首先检查是否在GC mark阶段，若是，返回mark阶段的g；</li>
<li>休眠前保存全局队列allp、idlepMask、timerpMask的快照；</li>
<li>再次检查全局p列表，检查可执行g队列；</li>
<li>再检查是否有GC mark的G出现，若有，获取p并回到第一步，重新执行偷取工作；</li>
<li>检查网络轮询器；</li>
<li>什么都没找到，休眠m；</li>
</ol>
<h2 id="一些细节问题"><a href="#一些细节问题" class="headerlink" title="一些细节问题"></a>一些细节问题</h2><h3 id="golang调度器——协作与抢占"><a href="#golang调度器——协作与抢占" class="headerlink" title="golang调度器——协作与抢占"></a>golang调度器——协作与抢占</h3><p>详细的过程可以看<a target="_blank" rel="noopener" href="https://juejin.cn/post/7217810344696954936">这篇博客</a>，这里只说结论；</p>
<h4 id="用户主动让出cpu"><a href="#用户主动让出cpu" class="headerlink" title="用户主动让出cpu"></a>用户主动让出cpu</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Gosched</span><span class="params">()</span></span> &#123;</span><br><span class="line">	checkTimeouts()</span><br><span class="line">	mcall(gosched_m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Gosched continuation on g0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gosched_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoSched()</span><br><span class="line">	&#125;</span><br><span class="line">	goschedImpl(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goschedImpl</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	status := readgstatus(gp)</span><br><span class="line">	<span class="keyword">if</span> status&amp;^_Gscan != _Grunning &#123;</span><br><span class="line">		dumpgstatus(gp)</span><br><span class="line">		throw(<span class="string">&quot;bad g status&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	casgstatus(gp, _Grunning, _Grunnable)</span><br><span class="line">	<span class="comment">// 使当前m放弃g</span></span><br><span class="line">	dropg()</span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	<span class="comment">// 将g放入全局队列等待调度</span></span><br><span class="line">	globrunqput(gp)</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用<code>Gosched</code>函数使g放弃当前cpu，等待调度，对用户要求较高；</p>
<h4 id="基于协作的抢占式调度"><a href="#基于协作的抢占式调度" class="headerlink" title="基于协作的抢占式调度"></a>基于协作的抢占式调度</h4><p>除了标记<code>//go:nosplit</code>的函数，在函数调用前会有检测指令，检测是否会触发栈扩张；</p>
<ol>
<li>首先，后台监控线程会对运行时间过长（≥10ms）的协程设置栈扩张标记；</li>
<li>协程运行到任何一个函数的序言的时候，都会首先检查栈扩张标记；</li>
<li>如果需要进行栈扩张，在进行栈扩张的时候，会夺取这个协程的运行权，从而实现抢占式调度，抢占流程与<code>goschedImpl</code>函数一致；</li>
</ol>
<h4 id="基于信号的抢占式调度"><a href="#基于信号的抢占式调度" class="headerlink" title="基于信号的抢占式调度"></a>基于信号的抢占式调度</h4><p>“基于协作的抢占式调度”存在问题，那就是必须要运行函数栈的序言部分，否则没法进行抢占式调度，因此引入了基于信号的抢占式调度，流程如下：</p>
<ol>
<li>M1发送信号_SIGURG；</li>
<li>M2接收到信号，并通过信号处理函数进行处理；</li>
<li>M2修改执行的上下文，并恢复到修改后的位置；</li>
<li>重新进入调度循环，进而调度其他goroutine。</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://www.yuque.com/aceld/golang/srxd6d">https://www.yuque.com/aceld/golang/srxd6d</a><br><a target="_blank" rel="noopener" href="https://www.luozhiyun.com/archives/448">https://www.luozhiyun.com/archives/448</a><br><a target="_blank" rel="noopener" href="https://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2golang%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">https://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2golang%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7212937418961895481">https://juejin.cn/post/7212937418961895481</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/SEE2TUeZQZ7W1BKkmnelAA">https://mp.weixin.qq.com/s/SEE2TUeZQZ7W1BKkmnelAA</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7217810344696954936">https://juejin.cn/post/7217810344696954936</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">bank</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/08/08/golang%E7%9A%84GMP/">http://example.com/2023/08/08/golang%E7%9A%84GMP/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">bank blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/golang/">golang</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/09/git%E7%9B%B8%E5%85%B3/" title="git相关"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">git相关</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/04/antlr4%E5%AD%A6%E4%B9%A0/" title="antlr4学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">antlr4学习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/05/19/golang%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%A1%A8/" title="golang实现跳表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-19</div><div class="title">golang实现跳表</div></div></a></div><div><a href="/2023/05/16/golang%E6%8C%87%E9%92%88/" title="golang指针讨论"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-16</div><div class="title">golang指针讨论</div></div></a></div><div><a href="/2023/08/10/golang%E7%9A%84GC/" title="golang的GC"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-10</div><div class="title">golang的GC</div></div></a></div><div><a href="/2023/08/10/golang%E7%9A%84map/" title="golang的map"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-10</div><div class="title">golang的map</div></div></a></div><div><a href="/2023/08/10/golang%E7%9A%84sync.map/" title="golang的sync.map"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-10</div><div class="title">golang的sync.map</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">bank</div><div class="author-info__description">行至水穷处,坐看云起时</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#golang%E7%9A%84GMP"><span class="toc-number">1.</span> <span class="toc-text">golang的GMP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GMP%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">GMP模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#G"><span class="toc-number">1.2.1.</span> <span class="toc-text">G</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#M"><span class="toc-number">1.2.2.</span> <span class="toc-text">M</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P"><span class="toc-number">1.2.3.</span> <span class="toc-text">P</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">1.2.4.</span> <span class="toc-text">调度器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8-1"><span class="toc-number">1.3.</span> <span class="toc-text">调度器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">程序启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.2.</span> <span class="toc-text">调度器初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#M%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.3.</span> <span class="toc-text">M初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.4.</span> <span class="toc-text">P初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.5.</span> <span class="toc-text">G初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text">一些细节问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#golang%E8%B0%83%E5%BA%A6%E5%99%A8%E2%80%94%E2%80%94%E5%8D%8F%E4%BD%9C%E4%B8%8E%E6%8A%A2%E5%8D%A0"><span class="toc-number">1.4.1.</span> <span class="toc-text">golang调度器——协作与抢占</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E4%B8%BB%E5%8A%A8%E8%AE%A9%E5%87%BAcpu"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">用户主动让出cpu</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%8D%8F%E4%BD%9C%E7%9A%84%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">基于协作的抢占式调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">基于信号的抢占式调度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">1.5.</span> <span class="toc-text">参考文献</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/10/golang%E7%9A%84GC/" title="golang的GC">golang的GC</a><time datetime="2023-08-10T13:44:34.793Z" title="发表于 2023-08-10 21:44:34">2023-08-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/10/golang%E7%9A%84map/" title="golang的map">golang的map</a><time datetime="2023-08-10T12:58:53.450Z" title="发表于 2023-08-10 20:58:53">2023-08-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/10/golang%E7%9A%84sync.map/" title="golang的sync.map">golang的sync.map</a><time datetime="2023-08-10T12:03:13.490Z" title="发表于 2023-08-10 20:03:13">2023-08-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/09/git%E7%9B%B8%E5%85%B3/" title="git相关">git相关</a><time datetime="2023-08-09T07:05:02.732Z" title="发表于 2023-08-09 15:05:02">2023-08-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/08/golang%E7%9A%84GMP/" title="golang的GMP">golang的GMP</a><time datetime="2023-08-08T12:25:58.964Z" title="发表于 2023-08-08 20:25:58">2023-08-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By bank</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>