<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>golang的GC源码阅读 | bank blog</title><meta name="author" content="bank"><meta name="copyright" content="bank"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="article">
<meta property="og:title" content="golang的GC源码阅读">
<meta property="og:url" content="http://example.com/2023/08/23/golang%E7%9A%84gc%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/index.html">
<meta property="og:site_name" content="bank blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-08-23T08:42:42.422Z">
<meta property="article:modified_time" content="2023-08-27T07:29:37.283Z">
<meta property="article:author" content="bank">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/08/23/golang%E7%9A%84gc%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'golang的GC源码阅读',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-27 15:29:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="bank blog"><span class="site-name">bank blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">golang的GC源码阅读</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-23T08:42:42.422Z" title="发表于 2023-08-23 16:42:42">2023-08-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-27T07:29:37.283Z" title="更新于 2023-08-27 15:29:37">2023-08-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/golang/">golang</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="golang的GC源码阅读"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer"/>

<span id="more"></span>

<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>之前我们讨论过golang的gc原理，三色标记法+混合写屏障，学习过原理后结合网上的文章和源码，本文从源码维度进行分析，加深理解。<br>本文就v1.18.4版本的golang进行分析。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="触发时机"><a href="#触发时机" class="headerlink" title="触发时机"></a>触发时机</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t gcTrigger)</span></span> test() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !memstats.enablegc || panicking != <span class="number">0</span> || gcphase != _GCoff &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> t.kind &#123;</span><br><span class="line">	<span class="keyword">case</span> gcTriggerHeap:</span><br><span class="line">		<span class="comment">// Non-atomic access to gcController.heapLive for performance. If</span></span><br><span class="line">		<span class="comment">// we are going to trigger on this, this thread just</span></span><br><span class="line">		<span class="comment">// atomically wrote gcController.heapLive anyway and we&#x27;ll see our</span></span><br><span class="line">		<span class="comment">// own write.</span></span><br><span class="line">		<span class="keyword">return</span> gcController.heapLive &gt;= gcController.trigger</span><br><span class="line">	<span class="keyword">case</span> gcTriggerTime:</span><br><span class="line">		<span class="keyword">if</span> gcController.gcPercent.Load() &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		lastgc := <span class="type">int64</span>(atomic.Load64(&amp;memstats.last_gc_nanotime))</span><br><span class="line">		<span class="keyword">return</span> lastgc != <span class="number">0</span> &amp;&amp; t.now-lastgc &gt; forcegcperiod</span><br><span class="line">	<span class="keyword">case</span> gcTriggerCycle:</span><br><span class="line">		<span class="comment">// t.n &gt; work.cycles, but accounting for wraparound.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="type">int32</span>(t.n-work.cycles) &gt; <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的方法是gc检查的入口，可以看到有三种触发gc的时条件：</p>
<ul>
<li>gcTriggerHeap：堆内存的分配达到达控制器计算的触发堆大小；</li>
<li>gcTriggerTime：如果一定时间内没有触发，就会触发新的循环；</li>
<li>gcTriggerCycle：要求启动新一轮的GC, 已启动则跳过；</li>
</ul>
<p>对于<code>gcTriggerTime</code>，源码中定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> forcegcperiod <span class="type">int64</span> = <span class="number">2</span> * <span class="number">60</span> * <span class="number">1e9</span></span><br></pre></td></tr></table></figure>
<p>默认是2min检查一次，即若2min没有进行gc则强制进行GC。</p>
<p>我们主要来看下<code>gcTriggerHeap</code>的case。<br><code>heapLive</code>的值在内存分配的时候进行计算，主要来研究GC阈值的计算逻辑。</p>
<p>首先计算<code>triggerRatio</code>，可以通过<code>runtime.GOGC</code>配置GC的时机，但是内部会根据偏移量进行微调：</p>
<ul>
<li>实际增长率越大, 触发系数偏移值越小, 小于0时下次触发GC会提早；</li>
<li>CPU占用率越大, 触发系数偏移值越小, 小于0时下次触发GC会提早；</li>
<li>原触发系数越大, 触发系数偏移值越小, 小于0时下次触发GC会提早；</li>
</ul>
<p>计算trigger比率的源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">nextTriggerRatio := gcController.endCycle(now, <span class="type">int</span>(gomaxprocs), work.userForced)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> endCycle(now <span class="type">int64</span>, procs <span class="type">int</span>, userForced <span class="type">bool</span>) <span class="type">float64</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">const</span> triggerGain = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 目标heap增长率：（下次 GC 完后堆大小 - 堆存活大小）/ 堆存活大小</span></span><br><span class="line">	goalGrowthRatio := c.effectiveGrowthRatio()</span><br><span class="line">	<span class="comment">// 实际heap增长率：总大小/存活大小-1</span></span><br><span class="line">	actualGrowthRatio := <span class="type">float64</span>(c.heapLive)/<span class="type">float64</span>(c.heapMarked) - <span class="number">1</span></span><br><span class="line">	<span class="comment">// 触发系数偏移值：目标增长率 - 原触发系数 - CPU占用率 / 目标CPU占用率 * (实际增长率 - 原触发系数)</span></span><br><span class="line">	triggerError := goalGrowthRatio - c.triggerRatio - utilization/gcGoalUtilization*(actualGrowthRatio-c.triggerRatio)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据偏移值调整触发系数，每次只调整偏移值的一半</span></span><br><span class="line">	triggerRatio := c.triggerRatio + triggerGain*triggerError</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> triggerRatio</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算好比率后，计算实际触发GC的堆大小的阈值，这里会做<code>triggerRatio</code>的限制，上限<code>0.95 * (gcPercent/100）</code>下限<code>0.6 * (gcPercent/100）</code>，接着通过公式<code>当前标记存活的大小 * (1 + triggerRatio)</code>计算trigger，即触发GC的堆内存阈值。<br>源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> oldCommit(triggerRatio <span class="type">float64</span>) &#123;</span><br><span class="line">	<span class="comment">// gcPercent由环境变量GOGC决定</span></span><br><span class="line">	gcPercent := c.gcPercent.Load()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute the next GC goal, which is when the allocated heap</span></span><br><span class="line">	<span class="comment">// has grown by GOGC/100 over the heap marked by the last</span></span><br><span class="line">	<span class="comment">// cycle.</span></span><br><span class="line">	goal := ^<span class="type">uint64</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> gcPercent &gt;= <span class="number">0</span> &#123;</span><br><span class="line">		goal = c.heapMarked + c.heapMarked*<span class="type">uint64</span>(gcPercent)/<span class="number">100</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set the trigger ratio, capped to reasonable bounds.</span></span><br><span class="line">	<span class="keyword">if</span> gcPercent &gt;= <span class="number">0</span> &#123;</span><br><span class="line">		scalingFactor := <span class="type">float64</span>(gcPercent) / <span class="number">100</span></span><br><span class="line">		<span class="comment">// triggerRatio 上限是0.95</span></span><br><span class="line">		maxTriggerRatio := <span class="number">0.95</span> * scalingFactor</span><br><span class="line">		<span class="keyword">if</span> triggerRatio &gt; maxTriggerRatio &#123;</span><br><span class="line">			triggerRatio = maxTriggerRatio</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// triggerRatio 下限是0.6</span></span><br><span class="line">		minTriggerRatio := <span class="number">0.6</span> * scalingFactor</span><br><span class="line">		<span class="keyword">if</span> triggerRatio &lt; minTriggerRatio &#123;</span><br><span class="line">			triggerRatio = minTriggerRatio</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> triggerRatio &lt; <span class="number">0</span> &#123;</span><br><span class="line">		triggerRatio = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.triggerRatio = triggerRatio</span><br><span class="line"></span><br><span class="line">	trigger := ^<span class="type">uint64</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> gcPercent &gt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 计算trigger = 当前标记存活的大小 * (1 + triggerRatio)</span></span><br><span class="line">		trigger = <span class="type">uint64</span>(<span class="type">float64</span>(c.heapMarked) * (<span class="number">1</span> + triggerRatio))</span><br><span class="line">		<span class="comment">// Don&#x27;t trigger below the minimum heap size.</span></span><br><span class="line">		minTrigger := c.heapMinimum</span><br><span class="line">		<span class="keyword">if</span> !isSweepDone() &#123;</span><br><span class="line">			sweepMin := atomic.Load64(&amp;c.heapLive) + sweepMinHeapDistance</span><br><span class="line">			<span class="keyword">if</span> sweepMin &gt; minTrigger &#123;</span><br><span class="line">				minTrigger = sweepMin</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> trigger &lt; minTrigger &#123;</span><br><span class="line">			trigger = minTrigger</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="type">int64</span>(trigger) &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;runtime: heapGoal=&quot;</span>, c.heapGoal, <span class="string">&quot; heapMarked=&quot;</span>, c.heapMarked, <span class="string">&quot; gcController.heapLive=&quot;</span>, c.heapLive, <span class="string">&quot; initialHeapLive=&quot;</span>, work.initialHeapLive, <span class="string">&quot;triggerRatio=&quot;</span>, triggerRatio, <span class="string">&quot; minTrigger=&quot;</span>, minTrigger, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">			throw(<span class="string">&quot;trigger underflow&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> trigger &gt; goal &#123;</span><br><span class="line">			<span class="comment">// The trigger ratio is always less than GOGC/100, but</span></span><br><span class="line">			<span class="comment">// other bounds on the trigger may have raised it.</span></span><br><span class="line">			<span class="comment">// Push up the goal, too.</span></span><br><span class="line">			goal = trigger</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Commit to the trigger and goal.</span></span><br><span class="line">	c.trigger = trigger</span><br><span class="line">	atomic.Store64(&amp;c.heapGoal, goal)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取<code>GOGC</code>初始化<code>gcPercent</code>的源码如下，读取后后续通过一系列的函数调用来原子的初始化<code>gcPercent</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readGOGC</span><span class="params">()</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">	p := gogetenv(<span class="string">&quot;GOGC&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> p == <span class="string">&quot;off&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n, ok := atoi32(p); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完GC的触发时机，下面我们来讨论一下GC的流程。</p>
<h2 id="GC流程"><a href="#GC流程" class="headerlink" title="GC流程"></a>GC流程</h2><h3 id="主动GC"><a href="#主动GC" class="headerlink" title="主动GC"></a>主动GC</h3><p>首先来看一下主动触发GC的函数，流程如下：</p>
<ol>
<li>等待上一轮GC结束；</li>
<li>开启新一轮的GC；</li>
<li>等待本轮GC结束；</li>
<li>等待清理全部待处理的内存管理单元，让出P；</li>
<li>将本阶段的堆内存状态快照发出来；</li>
</ol>
<p>源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GC</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 加载当前的GC轮数</span></span><br><span class="line">	n := atomic.Load(&amp;work.cycles)</span><br><span class="line">	<span class="comment">// 等待第n轮GC结束，即上一轮GC结束</span></span><br><span class="line">	gcWaitOnMark(n)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始GC</span></span><br><span class="line">	gcStart(gcTrigger&#123;kind: gcTriggerCycle, n: n + <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待n+1轮GC结束，即本轮</span></span><br><span class="line">	gcWaitOnMark(n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待清理全部待处理的内存管理单元</span></span><br><span class="line">	<span class="keyword">for</span> atomic.Load(&amp;work.cycles) == n+<span class="number">1</span> &amp;&amp; sweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		sweep.nbgsweep++</span><br><span class="line">		<span class="comment">// 让出P</span></span><br><span class="line">		Gosched()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> atomic.Load(&amp;work.cycles) == n+<span class="number">1</span> &amp;&amp; !isSweepDone() &#123;</span><br><span class="line">		Gosched()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mp := acquirem()</span><br><span class="line">	cycle := atomic.Load(&amp;work.cycles)</span><br><span class="line">	<span class="keyword">if</span> cycle == n+<span class="number">1</span> || (gcphase == _GCmark &amp;&amp; cycle == n+<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">// 将本阶段的堆内存状态快照发出来</span></span><br><span class="line">		mProf_PostSweep()</span><br><span class="line">	&#125;</span><br><span class="line">	releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们主要研究<code>gcStart()</code>函数，来探究GC的流程。</p>
<h3 id="gcStart"><a href="#gcStart" class="headerlink" title="gcStart"></a>gcStart</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcStart</span><span class="params">(trigger gcTrigger)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在一些不可抢占的情况或不稳定的情况下不进行GC</span></span><br><span class="line">	<span class="comment">// 获取当前M</span></span><br><span class="line">	mp := acquirem()</span><br><span class="line">	<span class="comment">// 获取当前G，若G对象是M的g0（表示当前线程正在执行非Go代码）、或M持有的锁的数量大于1、或者M的preemptoff字段不为空（表示M处于不可抢占状态），则满足这些条件的情况下不会启动垃圾回收</span></span><br><span class="line">	<span class="keyword">if</span> gp := getg(); gp == mp.g0 || mp.locks &gt; <span class="number">1</span> || mp.preemptoff != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// 释放M</span></span><br><span class="line">		releasem(mp)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 释放M</span></span><br><span class="line">	releasem(mp)</span><br><span class="line">	mp = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理未清扫的span，并再次检查GC条件</span></span><br><span class="line">	<span class="keyword">for</span> trigger.test() &amp;&amp; sweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		sweep.nbgsweep++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取信号量work.startSema，确保在GC前所有的必要条件已经满足</span></span><br><span class="line">	semacquire(&amp;work.startSema)</span><br><span class="line">	<span class="comment">// 再次检查GC条件</span></span><br><span class="line">	<span class="keyword">if</span> !trigger.test() &#123;</span><br><span class="line">		semrelease(&amp;work.startSema)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查是否是手动调用GC</span></span><br><span class="line">	work.userForced = trigger.kind == gcTriggerCycle</span><br><span class="line"></span><br><span class="line">	<span class="comment">// In gcstoptheworld debug mode, upgrade the mode accordingly.</span></span><br><span class="line">	<span class="comment">// We do this after re-checking the transition condition so</span></span><br><span class="line">	<span class="comment">// that multiple goroutines that detect the heap trigger don&#x27;t</span></span><br><span class="line">	<span class="comment">// start multiple STW GCs.</span></span><br><span class="line">	mode := gcBackgroundMode</span><br><span class="line">	<span class="keyword">if</span> debug.gcstoptheworld == <span class="number">1</span> &#123;</span><br><span class="line">		mode = gcForceMode</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> debug.gcstoptheworld == <span class="number">2</span> &#123;</span><br><span class="line">		mode = gcForceBlockMode</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待gcsema和worldsema信号，准备STW</span></span><br><span class="line">	semacquire(&amp;gcsema)</span><br><span class="line">	semacquire(&amp;worldsema)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGCStart()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查所有P完成延迟的mcache刷新</span></span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">		<span class="keyword">if</span> fg := atomic.Load(&amp;p.mcache.flushGen); fg != mheap_.sweepgen &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;runtime: p&quot;</span>, p.id, <span class="string">&quot;flushGen&quot;</span>, fg, <span class="string">&quot;!= sweepgen&quot;</span>, mheap_.sweepgen)</span><br><span class="line">			throw(<span class="string">&quot;p mcache not flushed&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动后台标记任务</span></span><br><span class="line">	gcBgMarkStartWorkers()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 系统调用，重置标记相关状态</span></span><br><span class="line">	systemstack(gcResetMarkState)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// work初始化</span></span><br><span class="line">	work.stwprocs, work.maxprocs = gomaxprocs, gomaxprocs</span><br><span class="line">	<span class="keyword">if</span> work.stwprocs &gt; ncpu &#123;</span><br><span class="line">		<span class="comment">// This is used to compute CPU time of the STW phases,</span></span><br><span class="line">		<span class="comment">// so it can&#x27;t be more than ncpu, even if GOMAXPROCS is.</span></span><br><span class="line">		work.stwprocs = ncpu</span><br><span class="line">	&#125;</span><br><span class="line">	work.heap0 = atomic.Load64(&amp;gcController.heapLive)</span><br><span class="line">	work.pauseNS = <span class="number">0</span></span><br><span class="line">	work.mode = mode</span><br><span class="line"></span><br><span class="line">	now := nanotime()</span><br><span class="line">	work.tSweepTerm = now</span><br><span class="line">	work.pauseStart = now</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGCSTWStart(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// STW</span></span><br><span class="line">	systemstack(stopTheWorldWithSema)</span><br><span class="line">	<span class="comment">// 并发标记前确认清理结束</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		finishsweep_m()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 清理sync.pool和sudog缓存，sync.pool管理对象池，sudog用于表示等待的goroutine，</span></span><br><span class="line">	clearpools()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新GC轮数</span></span><br><span class="line">	work.cycles++</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 清理控制器状态，表示开始新一轮的GC</span></span><br><span class="line">	gcController.startCycle(now, <span class="type">int</span>(gomaxprocs))</span><br><span class="line">	work.heapGoal = gcController.heapGoal</span><br><span class="line"></span><br><span class="line">	<span class="comment">// In STW mode, disable scheduling of user Gs. This may also</span></span><br><span class="line">	<span class="comment">// disable scheduling of this goroutine, so it may block as</span></span><br><span class="line">	<span class="comment">// soon as we start the world again.</span></span><br><span class="line">	<span class="keyword">if</span> mode != gcBackgroundMode &#123;</span><br><span class="line">		schedEnableUser(<span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置GC状态是_GCmark，启用写屏障</span></span><br><span class="line">	setGCPhase(_GCmark)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化后台扫描需要的状态</span></span><br><span class="line">	gcBgMarkPrepare() <span class="comment">// Must happen before assist enable.</span></span><br><span class="line">	<span class="comment">// 扫描栈、全局对象等根对象</span></span><br><span class="line">	gcMarkRootPrepare()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 标记所有tiny alloc等待合并的对象</span></span><br><span class="line">	gcMarkTinyAllocs()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用mutator assisets协助线程，这里是为了防止GC的速度赶不上内存分配的速度，导致GC永远无法结束，所以使用协助线程保证GC可以完成</span></span><br><span class="line">	atomic.Store(&amp;gcBlackenEnabled, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 确保不可抢占</span></span><br><span class="line">	mp = acquirem()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 系统调用，启动程序，start the world，后台任务开始标记堆中的对象</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		now = startTheWorldWithSema(trace.enabled)</span><br><span class="line">		<span class="comment">// 记录STW时间</span></span><br><span class="line">		work.pauseNS += now - work.pauseStart</span><br><span class="line">		work.tMark = now</span><br><span class="line">		memstats.gcPauseDist.record(now - work.pauseStart)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待worldsema信号</span></span><br><span class="line">	semrelease(&amp;worldsema)</span><br><span class="line">	<span class="comment">// 释放M</span></span><br><span class="line">	releasem(mp)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 让出G</span></span><br><span class="line">	<span class="keyword">if</span> mode != gcBackgroundMode &#123;</span><br><span class="line">		Gosched()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	semrelease(&amp;work.startSema)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其大体分以下几步：</p>
<ul>
<li>gcBgMarkStartWorkers，启动后台标记任务；</li>
<li>STW；</li>
<li>startCycle；</li>
<li>setGCPhase(_GCmark)，开启写屏障；</li>
<li>gcMarkTinyAllocs()，标记tiny对象；</li>
<li>start the world；</li>
</ul>
<h4 id="gcBgMarkStartWorkers"><a href="#gcBgMarkStartWorkers" class="headerlink" title="gcBgMarkStartWorkers"></a>gcBgMarkStartWorkers</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkStartWorkers</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 每个P启动一个标记协程</span></span><br><span class="line">	<span class="keyword">for</span> gcBgMarkWorkerCount &lt; gomaxprocs &#123;</span><br><span class="line">		<span class="keyword">go</span> gcBgMarkWorker()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 挂起，等待gcBgMarkWorker中完成标记协程与P的绑定后唤醒</span></span><br><span class="line">		notetsleepg(&amp;work.bgMarkReady, <span class="number">-1</span>)</span><br><span class="line">		noteclear(&amp;work.bgMarkReady)</span><br><span class="line"></span><br><span class="line">		gcBgMarkWorkerCount++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给每个P绑定一个标记协程。</p>
<h4 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopTheWorldWithSema</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取当前的g</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we hold a lock, then we won&#x27;t be able to stop another M</span></span><br><span class="line">	<span class="comment">// that is blocked trying to acquire the lock.</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks &gt; <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;stopTheWorld: holding locks&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拿锁</span></span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	<span class="comment">// 设置计数，记录已经停止的p数量</span></span><br><span class="line">	sched.stopwait = gomaxprocs</span><br><span class="line">	atomic.Store(&amp;sched.gcwaiting, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 发送抢占信息抢占所有 G，后将 p 状态置为 syscall</span></span><br><span class="line">	preemptall()</span><br><span class="line">	<span class="comment">// 停止当前的p，并将状态配置成stop</span></span><br><span class="line">	_g_.m.p.ptr().status = _Pgcstop <span class="comment">// Pgcstop is only diagnostic.</span></span><br><span class="line">	sched.stopwait--</span><br><span class="line">	<span class="comment">// 遍历所有的p，将每一个p停止，并将状态设置成stop</span></span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">		s := p.status</span><br><span class="line">		<span class="keyword">if</span> s == _Psyscall &amp;&amp; atomic.Cas(&amp;p.status, s, _Pgcstop) &#123;</span><br><span class="line">			<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">				traceGoSysBlock(p)</span><br><span class="line">				traceProcStop(p)</span><br><span class="line">			&#125;</span><br><span class="line">			p.syscalltick++</span><br><span class="line">			sched.stopwait--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将空闲状态(idle)的P停止，并设置状态成stop</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		p := pidleget()</span><br><span class="line">		<span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		p.status = _Pgcstop</span><br><span class="line">		sched.stopwait--</span><br><span class="line">	&#125;</span><br><span class="line">	wait := sched.stopwait &gt; <span class="number">0</span></span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待阻塞的g完成，并停止</span></span><br><span class="line">	<span class="keyword">if</span> wait &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">// wait for 100us, then try to re-preempt in case of any races</span></span><br><span class="line">			<span class="keyword">if</span> notetsleep(&amp;sched.stopnote, <span class="number">100</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">				noteclear(&amp;sched.stopnote)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			preemptall()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sanity checks</span></span><br><span class="line">	bad := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">if</span> sched.stopwait != <span class="number">0</span> &#123;</span><br><span class="line">		bad = <span class="string">&quot;stopTheWorld: not stopped (stopwait != 0)&quot;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">			<span class="keyword">if</span> p.status != _Pgcstop &#123;</span><br><span class="line">				bad = <span class="string">&quot;stopTheWorld: not stopped (status != _Pgcstop)&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;freezing) != <span class="number">0</span> &#123;</span><br><span class="line">		lock(&amp;deadlock)</span><br><span class="line">		lock(&amp;deadlock)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> bad != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		throw(bad)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	worldStopped()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先抢占全部的g，并将p的状态设置成syscall，然后遍历全部的p，逐个停止，并将p的状态修改成stop，具体一共分成三步：</p>
<ol>
<li>停止全部正在运行的p；</li>
<li>停止所有空闲的p；</li>
<li>等待所有正在系统调用的p返回，并停止；（计数实现）</li>
</ol>
<h4 id="startCycle"><a href="#startCycle" class="headerlink" title="startCycle"></a>startCycle</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> startCycle(markStartTime <span class="type">int64</span>, procs <span class="type">int</span>) &#123;</span><br><span class="line">	c.heapScanWork.Store(<span class="number">0</span>)</span><br><span class="line">	c.stackScanWork.Store(<span class="number">0</span>)</span><br><span class="line">	c.globalsScanWork.Store(<span class="number">0</span>)</span><br><span class="line">	c.bgScanCredit = <span class="number">0</span></span><br><span class="line">	c.assistTime = <span class="number">0</span></span><br><span class="line">	c.dedicatedMarkTime = <span class="number">0</span></span><br><span class="line">	c.fractionalMarkTime = <span class="number">0</span></span><br><span class="line">	c.idleMarkTime = <span class="number">0</span></span><br><span class="line">	c.markStartTime = markStartTime</span><br><span class="line">	c.stackScan = atomic.Load64(&amp;c.scannableStackSize)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 确保GC后的目标堆大小heapGoal比当前存活的堆大小要大一点点</span></span><br><span class="line">	<span class="keyword">if</span> goexperiment.PacerRedesign &#123;</span><br><span class="line">		<span class="keyword">if</span> c.heapGoal &lt; c.heapLive+<span class="number">64</span>&lt;&lt;<span class="number">10</span> &#123;</span><br><span class="line">			<span class="comment">// 64&lt;&lt;10 = 65536</span></span><br><span class="line">			c.heapGoal = c.heapLive + <span class="number">64</span>&lt;&lt;<span class="number">10</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 1&lt;&lt;20 = 104876</span></span><br><span class="line">		<span class="keyword">if</span> c.heapGoal &lt; c.heapLive+<span class="number">1</span>&lt;&lt;<span class="number">20</span> &#123;</span><br><span class="line">			c.heapGoal = c.heapLive + <span class="number">1</span>&lt;&lt;<span class="number">20</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// gcBackgroundUtilization = 0.25，GC所占P的目标是是25%</span></span><br><span class="line">	totalUtilizationGoal := <span class="type">float64</span>(procs) * gcBackgroundUtilization</span><br><span class="line">	<span class="comment">// dedicatedMarkWorkersNeeded = P的数量*25%后四舍五入</span></span><br><span class="line">	c.dedicatedMarkWorkersNeeded = <span class="type">int64</span>(totalUtilizationGoal + <span class="number">0.5</span>)</span><br><span class="line">	utilError := <span class="type">float64</span>(c.dedicatedMarkWorkersNeeded)/totalUtilizationGoal - <span class="number">1</span></span><br><span class="line">	<span class="keyword">const</span> maxUtilError = <span class="number">0.3</span></span><br><span class="line">	<span class="keyword">if</span> utilError &lt; -maxUtilError || utilError &gt; maxUtilError &#123;</span><br><span class="line">		<span class="comment">// Rounding put us more than 30% off our goal. With</span></span><br><span class="line">		<span class="comment">// gcBackgroundUtilization of 25%, this happens for</span></span><br><span class="line">		<span class="comment">// GOMAXPROCS&lt;=3 or GOMAXPROCS=6. Enable fractional</span></span><br><span class="line">		<span class="comment">// workers to compensate.</span></span><br><span class="line">		<span class="keyword">if</span> <span class="type">float64</span>(c.dedicatedMarkWorkersNeeded) &gt; totalUtilizationGoal &#123;</span><br><span class="line">			<span class="comment">// Too many dedicated workers.</span></span><br><span class="line">			c.dedicatedMarkWorkersNeeded--</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 计算每一个P分得的时间片，若整体占cpu的25%，有5个p，那么每个p占用的时间片就是0.05</span></span><br><span class="line">		c.fractionalUtilizationGoal = (totalUtilizationGoal - <span class="type">float64</span>(c.dedicatedMarkWorkersNeeded)) / <span class="type">float64</span>(procs)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c.fractionalUtilizationGoal = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// STW时，只有专用线程工作，其他全部停止</span></span><br><span class="line">	<span class="keyword">if</span> debug.gcstoptheworld &gt; <span class="number">0</span> &#123;</span><br><span class="line">		c.dedicatedMarkWorkersNeeded = <span class="type">int64</span>(procs)</span><br><span class="line">		c.fractionalUtilizationGoal = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 清理每一个P的状态</span></span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">		p.gcAssistTime = <span class="number">0</span></span><br><span class="line">		p.gcFractionalMarkTime = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute initial values for controls that are updated</span></span><br><span class="line">	<span class="comment">// throughout the cycle.</span></span><br><span class="line">	c.revise()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debug.gcpacertrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">		assistRatio := c.assistWorkPerByte.Load()</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;pacer: assist ratio=&quot;</span>, assistRatio,</span><br><span class="line">			<span class="string">&quot; (scan &quot;</span>, gcController.heapScan&gt;&gt;<span class="number">20</span>, <span class="string">&quot; MB in &quot;</span>,</span><br><span class="line">			work.initialHeapLive&gt;&gt;<span class="number">20</span>, <span class="string">&quot;-&gt;&quot;</span>,</span><br><span class="line">			c.heapGoal&gt;&gt;<span class="number">20</span>, <span class="string">&quot; MB)&quot;</span>,</span><br><span class="line">			<span class="string">&quot; workers=&quot;</span>, c.dedicatedMarkWorkersNeeded,</span><br><span class="line">			<span class="string">&quot;+&quot;</span>, c.fractionalUtilizationGoal, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里计算两个参数，用来控制标记的频率：</p>
<ul>
<li>dedicatedMarkWorkersNeeded：整体分得的占用CPU的比例；</li>
<li>fractionalUtilizationGoal：每个P分得的时间片；</li>
</ul>
<p>若P的数量是4的倍数，则将标记协程的数量设置成P&#x2F;4；<br>若P的数量不能被4整除，则通过控制标记协程执行时长的方式，来使全局标记协程对CPU的使用率趋近于25%；</p>
<h4 id="setGCPhase"><a href="#setGCPhase" class="headerlink" title="setGCPhase"></a>setGCPhase</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setGCPhase</span><span class="params">(x <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">	atomic.Store(&amp;gcphase, x)</span><br><span class="line">	writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination</span><br><span class="line">	writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> writeBarrier <span class="keyword">struct</span> &#123;</span><br><span class="line">	enabled <span class="type">bool</span>    <span class="comment">// compiler emits a check of this before calling write barrier</span></span><br><span class="line">	pad     [<span class="number">3</span>]<span class="type">byte</span> <span class="comment">// compiler uses 32-bit load for &quot;enabled&quot; field</span></span><br><span class="line">	needed  <span class="type">bool</span>    <span class="comment">// whether we need a write barrier for current GC phase</span></span><br><span class="line">	cgo     <span class="type">bool</span>    <span class="comment">// whether we need a write barrier for a cgo check</span></span><br><span class="line">	alignme <span class="type">uint64</span>  <span class="comment">// guarantee alignment so that compiler can use a 32 or 64-bit load</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开启写屏障；</p>
<h4 id="gcMarkTinyAllocs"><a href="#gcMarkTinyAllocs" class="headerlink" title="gcMarkTinyAllocs"></a>gcMarkTinyAllocs</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkTinyAllocs</span><span class="params">()</span></span> &#123;</span><br><span class="line">	assertWorldStopped()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">		c := p.mcache</span><br><span class="line">		<span class="keyword">if</span> c == <span class="literal">nil</span> || c.tiny == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		_, span, objIndex := findObject(c.tiny, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">		gcw := &amp;p.gcw</span><br><span class="line">		<span class="comment">// 标记全部活跃的tiny对象grey，并将其加入gcw队列</span></span><br><span class="line">		greyobject(c.tiny, <span class="number">0</span>, <span class="number">0</span>, span, gcw, objIndex)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历所有的p，将mcache中的tiny对象全部置灰；</p>
<h4 id="start-the-world"><a href="#start-the-world" class="headerlink" title="start the world"></a>start the world</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTheWorldWithSema</span><span class="params">(emitTraceEvent <span class="type">bool</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">	assertWorldStopped()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取并锁定当前m，确保不可抢占</span></span><br><span class="line">	mp := acquirem() <span class="comment">// disable preemption because it can be holding p in a local var</span></span><br><span class="line">	<span class="keyword">if</span> netpollinited() &#123;</span><br><span class="line">		list := netpoll(<span class="number">0</span>) <span class="comment">// non-blocking</span></span><br><span class="line">		injectglist(&amp;list)</span><br><span class="line">	&#125;</span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	procs := gomaxprocs</span><br><span class="line">	<span class="keyword">if</span> newprocs != <span class="number">0</span> &#123;</span><br><span class="line">		procs = newprocs</span><br><span class="line">		newprocs = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	p1 := procresize(procs)</span><br><span class="line">	sched.gcwaiting = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> sched.sysmonwait != <span class="number">0</span> &#123;</span><br><span class="line">		sched.sysmonwait = <span class="number">0</span></span><br><span class="line">		notewakeup(&amp;sched.sysmonnote)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	worldStarted()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历全部p，将p与队员的m重新绑定，唤醒全部的p</span></span><br><span class="line">	<span class="keyword">for</span> p1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		p := p1</span><br><span class="line">		p1 = p1.link.ptr()</span><br><span class="line">		<span class="keyword">if</span> p.m != <span class="number">0</span> &#123;</span><br><span class="line">			mp := p.m.ptr()</span><br><span class="line">			p.m = <span class="number">0</span></span><br><span class="line">			<span class="keyword">if</span> mp.nextp != <span class="number">0</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;startTheWorld: inconsistent mp-&gt;nextp&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			mp.nextp.set(p)</span><br><span class="line">			notewakeup(&amp;mp.park)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Start M to run P.  Do not start another M below.</span></span><br><span class="line">			newm(<span class="literal">nil</span>, p, <span class="number">-1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Capture start-the-world time before doing clean-up tasks.</span></span><br><span class="line">	startTime := nanotime()</span><br><span class="line">	<span class="keyword">if</span> emitTraceEvent &#123;</span><br><span class="line">		traceGCSTWDone()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wakep()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放m</span></span><br><span class="line">	releasem(mp)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> startTime</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 这里判断是否要进行GC</span></span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &amp;&amp; gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 正在进行GC，找GC的协程</span></span><br><span class="line">		gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())</span><br><span class="line">		<span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">			tryWakeP = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调度的函数中若发现正在进行GC，则去寻找GC标记的协程进行调度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *gcControllerState)</span></span> findRunnableGCWorker(_p_ *p) *g &#123;</span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;gcControllerState.findRunnable: blackening not enabled&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !gcMarkWorkAvailable(_p_) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从全局标记协程池gcBgMarkWorkerPool中取出g</span></span><br><span class="line">	node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop())</span><br><span class="line">	<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	decIfPositive := <span class="function"><span class="keyword">func</span><span class="params">(ptr *<span class="type">int64</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			v := atomic.Loadint64(ptr)</span><br><span class="line">			<span class="keyword">if</span> v &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> atomic.Casint64(ptr, v, v<span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 确定标记协程的工作状态</span></span><br><span class="line">	<span class="keyword">if</span> decIfPositive(&amp;c.dedicatedMarkWorkersNeeded) &#123;</span><br><span class="line">		_p_.gcMarkWorkerMode = gcMarkWorkerDedicatedMode</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> c.fractionalUtilizationGoal == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// No need for fractional workers.</span></span><br><span class="line">		gcBgMarkWorkerPool.push(&amp;node.node)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		delta := nanotime() - c.markStartTime</span><br><span class="line">		<span class="keyword">if</span> delta &gt; <span class="number">0</span> &amp;&amp; <span class="type">float64</span>(_p_.gcFractionalMarkTime)/<span class="type">float64</span>(delta) &gt; c.fractionalUtilizationGoal &#123;</span><br><span class="line">			<span class="comment">// Nope. No need to run a fractional worker.</span></span><br><span class="line">			gcBgMarkWorkerPool.push(&amp;node.node)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Run a fractional worker.</span></span><br><span class="line">		_p_.gcMarkWorkerMode = gcMarkWorkerFractionalMode</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Run the background mark worker.</span></span><br><span class="line">	gp := node.gp.ptr()</span><br><span class="line">	casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> gp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里从全局标记协程池gcBgMarkWorkerPool中取出g，这个全局标记协程池gcBgMarkWorkerPool，是在我们上面讨论过的<code>gcBgMarkStartWorkers</code>函数中，为每一个P都开一个标记协程，具体开的协程入口函数就是下面的<code>gcBgMarkWorker</code>函数，可以看出是使用<code>gcBgMarkWorkerNode</code>对协程进行封装，然后通过<code>gcBgMarkWorkerPool.push(&amp;node.node)</code>统一放在<code>gcBgMarkWorkerPool</code>中进行调度的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">	gp := getg()</span><br><span class="line"></span><br><span class="line">	gp.m.preemptoff = <span class="string">&quot;GC worker init&quot;</span></span><br><span class="line">	<span class="comment">// 使用gcBgMarkWorkerNode封装标记协程</span></span><br><span class="line">	node := <span class="built_in">new</span>(gcBgMarkWorkerNode)</span><br><span class="line">	gp.m.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">	node.gp.set(gp)</span><br><span class="line"></span><br><span class="line">	node.m.set(acquirem())</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Go to sleep until woken by</span></span><br><span class="line">		<span class="comment">// gcController.findRunnableGCWorker.</span></span><br><span class="line">		gopark(<span class="function"><span class="keyword">func</span><span class="params">(g *g, nodep unsafe.Pointer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">			node := (*gcBgMarkWorkerNode)(nodep)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> mp := node.m.ptr(); mp != <span class="literal">nil</span> &#123;</span><br><span class="line">				releasem(mp)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// gcBgMarkWorkerPool中添加node</span></span><br><span class="line">			gcBgMarkWorkerPool.push(&amp;node.node)</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;, unsafe.Pointer(node), waitReasonGCWorkerIdle, traceEvGoBlock, <span class="number">0</span>)</span><br><span class="line">		...</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码展示了node节点的常见，即标记协程池的赋值，此外在<code>gcBgMarkWorker</code>方法中下面这段逻辑也很重要：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据不同的调度模式，执行gcDrain</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">			<span class="keyword">switch</span> pp.gcMarkWorkerMode &#123;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				throw(<span class="string">&quot;gcBgMarkWorker: unexpected gcMarkWorkerMode&quot;</span>)</span><br><span class="line">			<span class="comment">// 专一模式. 需要完整执行完标记任务，不可被抢占</span></span><br><span class="line">			<span class="keyword">case</span> gcMarkWorkerDedicatedMode:</span><br><span class="line">				<span class="comment">// 先以可抢占模式执行，若有协程进行抢占，则将抢占协程放入全局队列，然后以不抢占模式运行</span></span><br><span class="line">				gcDrain(&amp;pp.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">				<span class="keyword">if</span> gp.preempt &#123;</span><br><span class="line">					<span class="comment">// 将抢占协程放入全局队列</span></span><br><span class="line">					<span class="keyword">if</span> drainQ, n := runqdrain(pp); n &gt; <span class="number">0</span> &#123;</span><br><span class="line">						lock(&amp;sched.lock)</span><br><span class="line">						globrunqputbatch(&amp;drainQ, <span class="type">int32</span>(n))</span><br><span class="line">						unlock(&amp;sched.lock)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Go back to draining, this time</span></span><br><span class="line">				<span class="comment">// without preemption.</span></span><br><span class="line">				gcDrain(&amp;pp.gcw, gcDrainFlushBgCredit)</span><br><span class="line">			<span class="comment">// 分时模式. 当标记协程执行时长达到一定比例后，可以被抢占</span></span><br><span class="line">			<span class="keyword">case</span> gcMarkWorkerFractionalMode:</span><br><span class="line">				gcDrain(&amp;pp.gcw, gcDrainFractional|gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">			<span class="comment">// 空闲模式. 随时可以被抢占</span></span><br><span class="line">			<span class="keyword">case</span> gcMarkWorkerIdleMode:</span><br><span class="line">				gcDrain(&amp;pp.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">			&#125;</span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">		&#125;)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段逻辑是通过不同的GC模式来调用<code>gcDrain</code>方法，不同的GC模式常量定义如下，<code>gcDrain</code>方法是并发标记阶段的核心，下面来研究下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	gcMarkWorkerNotWorker gcMarkWorkerMode = <span class="literal">iota</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 专一模式. 需要完整执行完标记任务，不可被抢占</span></span><br><span class="line">	gcMarkWorkerDedicatedMode</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分时模式. 当标记协程执行时长达到一定比例后，可以被抢占</span></span><br><span class="line">	gcMarkWorkerFractionalMode</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 空闲模式. 随时可以被抢占</span></span><br><span class="line">	gcMarkWorkerIdleMode</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>GC的标记工作模式。</p>
<h3 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h3><p>标记阶段的核心函数是<code>gcDrain</code>，在讨论其流程前，我们先来看下<code>gcWork</code>数据结构。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> gcWork <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 双缓存，存储灰色对象列表指针</span></span><br><span class="line">	wbuf1, wbuf2 *workbuf</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在这个gcWork中，已经标记了多少字节的数据</span></span><br><span class="line">	bytesMarked <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在这个gcWork中，已经扫描了多少堆内存</span></span><br><span class="line">	heapScanWork <span class="type">int64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 是否已经把一些灰色对象的指针从gcWork中移出，放到了全局的工作列表中</span></span><br><span class="line">	flushedWork <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个GC的过程使用<code>gcWork</code>存储灰色对象，其中<code>workbuf</code>是双缓存，轮流使用。<br>灰对象缓存队列分为两层：</p>
<ul>
<li>每个P私有的gcWork，实现上由两条单向链表构成，采用轮换机制使用；</li>
<li>全局队列workType.full，底层是一个通过CAS操作维护的栈结构，由所有P共享；</li>
</ul>
<p>下面来看<code>gcDrain</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrain</span><span class="params">(gcw *gcWork, flags gcDrainFlags)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !writeBarrier.needed &#123;</span><br><span class="line">		throw(<span class="string">&quot;gcDrain phase incorrect&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gp := getg().m.curg</span><br><span class="line">	preemptible := flags&amp;gcDrainUntilPreempt != <span class="number">0</span></span><br><span class="line">	flushBgCredit := flags&amp;gcDrainFlushBgCredit != <span class="number">0</span></span><br><span class="line">	idle := flags&amp;gcDrainIdle != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	initScanWork := gcw.heapScanWork</span><br><span class="line"></span><br><span class="line">	checkWork := <span class="type">int64</span>(<span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">var</span> check <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span></span><br><span class="line">	<span class="comment">// 根据不同的GC标记模式，采取不同的策略</span></span><br><span class="line">	<span class="keyword">if</span> flags&amp;(gcDrainIdle|gcDrainFractional) != <span class="number">0</span> &#123;</span><br><span class="line">		checkWork = initScanWork + drainCheckThreshold</span><br><span class="line">		<span class="keyword">if</span> idle &#123;</span><br><span class="line">			check = pollWork</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> flags&amp;gcDrainFractional != <span class="number">0</span> &#123;</span><br><span class="line">			check = pollFractionalWorkerExit</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 标记根对象</span></span><br><span class="line">	<span class="keyword">if</span> work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class="line">		<span class="comment">// Stop if we&#x27;re preemptible or if someone wants to STW.</span></span><br><span class="line">		<span class="keyword">for</span> !(gp.preempt &amp;&amp; (preemptible || atomic.Load(&amp;sched.gcwaiting) != <span class="number">0</span>)) &#123;</span><br><span class="line">			job := atomic.Xadd(&amp;work.markrootNext, +<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> job &gt;= work.markrootJobs &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			markroot(gcw, job, flushBgCredit)</span><br><span class="line">			<span class="keyword">if</span> check != <span class="literal">nil</span> &amp;&amp; check() &#123;</span><br><span class="line">				<span class="keyword">goto</span> done</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历gcw队列，进行消费</span></span><br><span class="line">	<span class="keyword">for</span> !(gp.preempt &amp;&amp; (preemptible || atomic.Load(&amp;sched.gcwaiting) != <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="comment">// 将本地一部分工作放入全局队列</span></span><br><span class="line">		<span class="keyword">if</span> work.full == <span class="number">0</span> &#123;</span><br><span class="line">			gcw.balance()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 试从 p 本地队列中获取灰色对象，无锁</span></span><br><span class="line">		b := gcw.tryGetFast()</span><br><span class="line">		<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 尝试从全局队列中获取灰色对象，加锁</span></span><br><span class="line">			b = gcw.tryGet()</span><br><span class="line">			<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 因为缺灰，会释放写屏障缓存，进行补灰操作</span></span><br><span class="line">				wbBufFlush(<span class="literal">nil</span>, <span class="number">0</span>)</span><br><span class="line">				b = gcw.tryGet()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 标记完成</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		scanobject(b, gcw)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 若已经标记了一定数量的对象 gcCreditSlack = 2000</span></span><br><span class="line">		<span class="keyword">if</span> gcw.heapScanWork &gt;= gcCreditSlack &#123;</span><br><span class="line">			<span class="comment">// 把扫描的对象数量添加到全局</span></span><br><span class="line">			gcController.heapScanWork.Add(gcw.heapScanWork)</span><br><span class="line">			<span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">				<span class="comment">// 记录这次扫描的内存字节数用于减少辅助标记的工作量</span></span><br><span class="line">				gcFlushBgCredit(gcw.heapScanWork - initScanWork)</span><br><span class="line">				initScanWork = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">			checkWork -= gcw.heapScanWork</span><br><span class="line">			gcw.heapScanWork = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> checkWork &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				checkWork += drainCheckThreshold</span><br><span class="line">				<span class="keyword">if</span> check != <span class="literal">nil</span> &amp;&amp; check() &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">	<span class="comment">// Flush remaining scan work credit.</span></span><br><span class="line">	<span class="keyword">if</span> gcw.heapScanWork &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 把扫描的对象数量添加到全局</span></span><br><span class="line">		gcController.heapScanWork.Add(gcw.heapScanWork)</span><br><span class="line">		<span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">			<span class="comment">// 记录这次扫描的内存字节数用于减少辅助标记的工作量</span></span><br><span class="line">			gcFlushBgCredit(gcw.heapScanWork - initScanWork)</span><br><span class="line">		&#125;</span><br><span class="line">		gcw.heapScanWork = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其主要是以下几步：</p>
<ol>
<li>根据不同的mode采取不同的GC策略；</li>
<li>标记根对象；</li>
<li>消费gcw队列中的灰色对象；</li>
<li>更新全局标记数据；</li>
</ol>
<h4 id="根据不同的mode采取不同的GC策略"><a href="#根据不同的mode采取不同的GC策略" class="headerlink" title="根据不同的mode采取不同的GC策略"></a>根据不同的mode采取不同的GC策略</h4><p>每次扫描完根对象，都会check一下是否需要推出标记任务，根据mode的不同check的策略也不同：</p>
<ul>
<li>gcDrainUntilPreempt：当 G 被抢占时返回；</li>
<li>gcDrainIdle：调用 runtime.pollWork，当 P 上包含其他待执行 G 时返回；</li>
<li>gcDrainFractional：调用 runtime.pollFractionalWorkerExit，当 CPU 的占用率超过 fractionalUtilizationGoal 的 20% 时返回；</li>
</ul>
<h4 id="标记根对象"><a href="#标记根对象" class="headerlink" title="标记根对象"></a>标记根对象</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">markroot</span><span class="params">(gcw *gcWork, i <span class="type">uint32</span>, flushBgCredit <span class="type">bool</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">	<span class="comment">// Note: if you add a case here, please also update heapdump.go:dumproots.</span></span><br><span class="line">	<span class="keyword">var</span> workDone <span class="type">int64</span></span><br><span class="line">	<span class="keyword">var</span> workCounter *atomic.Int64</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="comment">// 扫描已初始化的全局变量</span></span><br><span class="line">	<span class="keyword">case</span> work.baseData &lt;= i &amp;&amp; i &lt; work.baseBSS:</span><br><span class="line">		workCounter = &amp;gcController.globalsScanWork</span><br><span class="line">		<span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">			workDone += markrootBlock(datap.data, datap.edata-datap.data, datap.gcdatamask.bytedata, gcw, <span class="type">int</span>(i-work.baseData))</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">// 扫描未初始化的全局变量</span></span><br><span class="line">	<span class="keyword">case</span> work.baseBSS &lt;= i &amp;&amp; i &lt; work.baseSpans:</span><br><span class="line">		workCounter = &amp;gcController.globalsScanWork</span><br><span class="line">		<span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">			workDone += markrootBlock(datap.bss, datap.ebss-datap.bss, datap.gcbssmask.bytedata, gcw, <span class="type">int</span>(i-work.baseBSS))</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">// 扫描finalizer队列，finalizer队列存储所有需要执行终结器的对象，GC时会遍历这个列表，将其中的对象标记为灰色，以防止它们被回收</span></span><br><span class="line">	<span class="keyword">case</span> i == fixedRootFinalizers:</span><br><span class="line">		<span class="keyword">for</span> fb := allfin; fb != <span class="literal">nil</span>; fb = fb.alllink &#123;</span><br><span class="line">			cnt := <span class="type">uintptr</span>(atomic.Load(&amp;fb.cnt))</span><br><span class="line">			scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;fb.fin[<span class="number">0</span>])), cnt*unsafe.Sizeof(fb.fin[<span class="number">0</span>]), &amp;finptrmask[<span class="number">0</span>], gcw, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">// 释放已终止g的栈</span></span><br><span class="line">	<span class="keyword">case</span> i == fixedRootFreeGStacks:</span><br><span class="line">		<span class="comment">// Switch to the system stack so we can call</span></span><br><span class="line">		<span class="comment">// stackfree.</span></span><br><span class="line">		systemstack(markrootFreeGStacks)</span><br><span class="line">	<span class="comment">// 扫描mspan中的special对象，special对象：1.有终结器的对象; 2.包含了指向其他 Go 对象的指针的非 Go 对象;</span></span><br><span class="line">	<span class="keyword">case</span> work.baseSpans &lt;= i &amp;&amp; i &lt; work.baseStacks:</span><br><span class="line">		<span class="comment">// mark mspan.specials</span></span><br><span class="line">		markrootSpans(gcw, <span class="type">int</span>(i-work.baseSpans))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// 扫描当前g的栈</span></span><br><span class="line">		workCounter = &amp;gcController.stackScanWork</span><br><span class="line">		<span class="keyword">if</span> i &lt; work.baseStacks || work.baseEnd &lt;= i &#123;</span><br><span class="line">			printlock()</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;runtime: markroot index &quot;</span>, i, <span class="string">&quot; not in stack roots range [&quot;</span>, work.baseStacks, <span class="string">&quot;, &quot;</span>, work.baseEnd, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">			throw(<span class="string">&quot;markroot: bad index&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		gp := work.stackRoots[i-work.baseStacks]</span><br><span class="line"></span><br><span class="line">		status := readgstatus(gp) <span class="comment">// We are not in a scan state</span></span><br><span class="line">		<span class="keyword">if</span> (status == _Gwaiting || status == _Gsyscall) &amp;&amp; gp.waitsince == <span class="number">0</span> &#123;</span><br><span class="line">			gp.waitsince = work.tstart</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			</span><br><span class="line">			userG := getg().m.curg</span><br><span class="line">			selfScan := gp == userG &amp;&amp; readgstatus(userG) == _Grunning</span><br><span class="line">			<span class="keyword">if</span> selfScan &#123;</span><br><span class="line">				casgstatus(userG, _Grunning, _Gwaiting)</span><br><span class="line">				userG.waitreason = waitReasonGarbageCollectionScan</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			stopped := suspendG(gp)</span><br><span class="line">			<span class="keyword">if</span> stopped.dead &#123;</span><br><span class="line">				gp.gcscandone = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> gp.gcscandone &#123;</span><br><span class="line">				throw(<span class="string">&quot;g already scanned&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			workDone += scanstack(gp, gcw)</span><br><span class="line">			gp.gcscandone = <span class="literal">true</span></span><br><span class="line">			resumeG(stopped)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> selfScan &#123;</span><br><span class="line">				casgstatus(userG, _Gwaiting, _Grunning)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> goexperiment.PacerRedesign &#123;</span><br><span class="line">		<span class="keyword">if</span> workCounter != <span class="literal">nil</span> &amp;&amp; workDone != <span class="number">0</span> &#123;</span><br><span class="line">			workCounter.Add(workDone)</span><br><span class="line">			<span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">				gcFlushBgCredit(workDone)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> workDone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我理解对于根对象的选取有：已初始化的全局对象、未初始化的全局对象、finalizer队列、mspan中的special对象、当前g的栈中的对象；</p>
<p>下面看一下<code>scanblock</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanblock</span><span class="params">(b0, n0 <span class="type">uintptr</span>, ptrmask *<span class="type">uint8</span>, gcw *gcWork, stk *stackScanState)</span></span> &#123;</span><br><span class="line">	b := b0</span><br><span class="line">	n := n0</span><br><span class="line">	<span class="comment">// 遍历扫描的地址</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; n; &#123;</span><br><span class="line">		<span class="comment">// 找到bitmap中对应的byte</span></span><br><span class="line">		bits := <span class="type">uint32</span>(*addb(ptrmask, i/(goarch.PtrSize*<span class="number">8</span>)))</span><br><span class="line">		<span class="keyword">if</span> bits == <span class="number">0</span> &#123;</span><br><span class="line">			i += goarch.PtrSize * <span class="number">8</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 遍历每个byte</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">8</span> &amp;&amp; i &lt; n; j++ &#123;</span><br><span class="line">			<span class="comment">// 若该地址存在指针</span></span><br><span class="line">			<span class="keyword">if</span> bits&amp;<span class="number">1</span> != <span class="number">0</span> &#123;</span><br><span class="line">				p := *(*<span class="type">uintptr</span>)(unsafe.Pointer(b + i))</span><br><span class="line">				<span class="keyword">if</span> p != <span class="number">0</span> &#123;</span><br><span class="line">					<span class="comment">// 将该对象至灰</span></span><br><span class="line">					<span class="keyword">if</span> obj, span, objIndex := findObject(p, b, i); obj != <span class="number">0</span> &#123;</span><br><span class="line">						greyobject(obj, b, i, span, gcw, objIndex)</span><br><span class="line">					&#125; <span class="keyword">else</span> <span class="keyword">if</span> stk != <span class="literal">nil</span> &amp;&amp; p &gt;= stk.stack.lo &amp;&amp; p &lt; stk.stack.hi &#123;</span><br><span class="line">						stk.putPtr(p, <span class="literal">false</span>)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			bits &gt;&gt;= <span class="number">1</span></span><br><span class="line">			i += goarch.PtrSize</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用位图ptrmask辅助加速流程. 在ptrmask当中，每个bit位对应了一个指针大小（8B）的位置的标识信息，指明当前位置是否是指针，倘若非指针，则直接跳过扫描。</p>
<p>对于栈的扫描比较复杂，这里暂时未研究明白。</p>
<h4 id="消费gcw中的对象"><a href="#消费gcw中的对象" class="headerlink" title="消费gcw中的对象"></a>消费gcw中的对象</h4><p>首先来看下对象扫描函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanobject</span><span class="params">(b <span class="type">uintptr</span>, gcw *gcWork)</span></span> &#123;</span><br><span class="line">	sys.Prefetch(b)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取b的heapBits对象</span></span><br><span class="line">	hbits := heapBitsForAddr(b)</span><br><span class="line">	<span class="comment">// 获取b对应的span</span></span><br><span class="line">	s := spanOfUnchecked(b)</span><br><span class="line">	<span class="comment">// span对应对象的大小</span></span><br><span class="line">	n := s.elemsize</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;scanobject n == 0&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> n &gt; maxObletBytes &#123;</span><br><span class="line">		<span class="keyword">if</span> b == s.base() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> s.spanclass.noscan() &#123;</span><br><span class="line">				<span class="comment">// Bypass the whole scan.</span></span><br><span class="line">				gcw.bytesMarked += <span class="type">uint64</span>(n)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> oblet := b + maxObletBytes; oblet &lt; s.base()+s.elemsize; oblet += maxObletBytes &#123;</span><br><span class="line">				<span class="keyword">if</span> !gcw.putFast(oblet) &#123;</span><br><span class="line">					gcw.put(oblet)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		n = s.base() + s.elemsize - b</span><br><span class="line">		<span class="keyword">if</span> n &gt; maxObletBytes &#123;</span><br><span class="line">			n = maxObletBytes</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 顺沿当前对象的成员指针，扫描后续的对象</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="type">uintptr</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; n; i, hbits = i+goarch.PtrSize, hbits.next() &#123;</span><br><span class="line">		<span class="comment">// 通过 heapArena 中的 bitmap 记录的信息，加速遍历过程</span></span><br><span class="line">		bits := hbits.bits()</span><br><span class="line">		<span class="keyword">if</span> bits&amp;bitScan == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span> <span class="comment">// no more pointers in this object</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> bits&amp;bitPointer == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span> <span class="comment">// not a pointer</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		obj := *(*<span class="type">uintptr</span>)(unsafe.Pointer(b + i))</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> obj != <span class="number">0</span> &amp;&amp; obj-b &gt;= n &#123;</span><br><span class="line">			<span class="comment">// 将遍历到的对象置灰</span></span><br><span class="line">			<span class="keyword">if</span> obj, span, objIndex := findObject(obj, b, i); obj != <span class="number">0</span> &#123;</span><br><span class="line">				greyobject(obj, b, i, span, gcw, objIndex)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	gcw.bytesMarked += <span class="type">uint64</span>(n)</span><br><span class="line">	gcw.heapScanWork += <span class="type">int64</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其主要步骤如下：</p>
<ol>
<li>获取给定对象的<code>heapbits</code>对象，它包含了对象的内存布局信息，可以用来加速遍历过程；</li>
<li>获取给定对象所在的<code>span</code>，及<code>span</code>中对象的大小<code>elemsize</code>；</li>
<li>若对象的大小大于<code>maxObletBytes</code>（128kb），则将对象分割成多个小的部分并添加到<code>gcw</code>中；</li>
<li>遍历给定对象的成员指针；</li>
<li>对于每个成员指针，检查它指向的对象是否在给定对象之外，并置灰；</li>
<li>更新统计信息；</li>
</ol>
<p>在看具体的置灰函数前，先来看下golang是如何实现三色标记法的。<br>每个对象都有从属的span，span结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    allocBits  *gcBits</span><br><span class="line">    gcmarkBits *gcBits</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> gcBits <span class="type">uint8</span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>allocBits：一个bit位对应一个object大小的内存块，置1表示已使用，置0表示空闲；</li>
<li>gcmarkBits：GC阶段使用，置1表示对象存活；</li>
</ul>
<p>三色实现：</p>
<ul>
<li>黑色：对象在mspan.gcmarkBits中bit位值为1，且对象已经离开灰对象缓存队列；</li>
<li>灰色：对象在mspan.gcmarkBits中bit位值为1，且对象仍处于灰对象缓存队列中；</li>
<li>白色：对象在mspan.gcmarkBits中bit位值位0；</li>
</ul>
<p>下面来看下置灰函数<code>greyObject</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greyobject</span><span class="params">(obj, base, off <span class="type">uintptr</span>, span *mspan, gcw *gcWork, objIndex <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    ..</span><br><span class="line">    <span class="comment">// 在其所属的 mspan 中，将对应位置的 gcMark bitmap 位置为 1</span></span><br><span class="line">    mbits.setMarked()</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将对象添加到当前 p 的本地队列</span></span><br><span class="line">    <span class="keyword">if</span> !gcw.putFast(obj) &#123;</span><br><span class="line">        gcw.put(obj)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="辅助标记"><a href="#辅助标记" class="headerlink" title="辅助标记"></a>辅助标记</h4><p><code>mutator assists</code>，主要是为了防止heap增速太快, 在GC执行的过程中如果同时运行的G分配了内存, 那么这个G会被要求辅助GC做一部分的工作。<br>分配内存的函数中有这样一段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> assistG *g</span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &#123;       </span><br><span class="line">        assistG = getg()</span><br><span class="line">        <span class="keyword">if</span> assistG.m.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">            assistG = assistG.m.curg</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每个g会有资产</span></span><br><span class="line">        assistG.gcAssistBytes -= <span class="type">int64</span>(size)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> assistG.gcAssistBytes &lt; <span class="number">0</span> &#123;     </span><br><span class="line">            <span class="comment">// 当前g负债了      </span></span><br><span class="line">            gcAssistAlloc(assistG)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面讨论过的<code>gcDrain</code>函数中有这样一段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">              <span class="comment">// 若已经标记了一定数量的对象 gcCreditSlack = 2000</span></span><br><span class="line"><span class="keyword">if</span> gcw.heapScanWork &gt;= gcCreditSlack &#123;</span><br><span class="line">	<span class="comment">// 把扫描的对象数量添加到全局</span></span><br><span class="line">	gcController.heapScanWork.Add(gcw.heapScanWork)</span><br><span class="line">	<span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">		<span class="comment">// 记录这次扫描的内存字节数用于减少辅助标记的工作量</span></span><br><span class="line">		gcFlushBgCredit(gcw.heapScanWork - initScanWork)</span><br><span class="line">		initScanWork = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	checkWork -= gcw.heapScanWork</span><br><span class="line">	gcw.heapScanWork = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> checkWork &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		checkWork += drainCheckThreshold</span><br><span class="line">		<span class="keyword">if</span> check != <span class="literal">nil</span> &amp;&amp; check() &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里若GC标记协程标记的量大于2000，则将多出来的部分作为全局资产存起来，在辅助标记的时候使用；<br>辅助标记的源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcAssistAlloc</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">retry:</span><br><span class="line">	assistWorkPerByte := gcController.assistWorkPerByte.Load()</span><br><span class="line">	assistBytesPerWork := gcController.assistBytesPerWork.Load()</span><br><span class="line">	<span class="comment">// 计算负债，计算需要进行标记的大小</span></span><br><span class="line">	debtBytes := -gp.gcAssistBytes</span><br><span class="line">	scanWork := <span class="type">int64</span>(assistWorkPerByte * <span class="type">float64</span>(debtBytes))</span><br><span class="line">	<span class="keyword">if</span> scanWork &lt; gcOverAssistWork &#123;</span><br><span class="line">		scanWork = gcOverAssistWork</span><br><span class="line">		debtBytes = <span class="type">int64</span>(assistBytesPerWork * <span class="type">float64</span>(scanWork))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取全局资产</span></span><br><span class="line">	bgScanCredit := atomic.Loadint64(&amp;gcController.bgScanCredit)</span><br><span class="line">	stolen := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> bgScanCredit &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> bgScanCredit &lt; scanWork &#123;</span><br><span class="line">			stolen = bgScanCredit</span><br><span class="line">			gp.gcAssistBytes += <span class="number">1</span> + <span class="type">int64</span>(assistBytesPerWork*<span class="type">float64</span>(stolen))</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			stolen = scanWork</span><br><span class="line">			gp.gcAssistBytes += debtBytes</span><br><span class="line">		&#125;</span><br><span class="line">		atomic.Xaddint64(&amp;gcController.bgScanCredit, -stolen)</span><br><span class="line"></span><br><span class="line">		scanWork -= stolen</span><br><span class="line">		<span class="comment">// 全局资产可以抵当前g中的债务，无需进行标记，直接返回</span></span><br><span class="line">		<span class="keyword">if</span> scanWork == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> traced &#123;</span><br><span class="line">				traceGCMarkAssistDone()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &amp;&amp; !traced &#123;</span><br><span class="line">		traced = <span class="literal">true</span></span><br><span class="line">		traceGCMarkAssistStart()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 切换到g0，开始标记</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		gcAssistAlloc1(gp, scanWork)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	completed := gp.param != <span class="literal">nil</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> completed &#123;</span><br><span class="line">		gcMarkDone()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gp.gcAssistBytes &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> gp.preempt &#123;</span><br><span class="line">			Gosched()</span><br><span class="line">			<span class="keyword">goto</span> retry</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !gcParkAssist() &#123;</span><br><span class="line">			<span class="keyword">goto</span> retry</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> traced &#123;</span><br><span class="line">		traceGCMarkAssistDone()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里逻辑还比较清晰，通过本地债务和全局信用的对比来判断当前的g需要辅助标记多少的内存。</p>
<h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// writebarrier pass inserts write barriers for store ops (Store, Move, Zero)</span></span><br><span class="line"><span class="comment">// when necessary (the condition above). It rewrites store ops to branches</span></span><br><span class="line"><span class="comment">// and runtime calls, like</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// if writeBarrier.enabled &#123;</span></span><br><span class="line"><span class="comment">// gcWriteBarrier(ptr, val) // Not a regular Go call</span></span><br><span class="line"><span class="comment">// &#125; else &#123;</span></span><br><span class="line"><span class="comment">// *ptr = val</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>在执行<code>Store</code>,<code>Move</code>,<code>Zero</code>等汇编操作的时候加入写屏障。</p>
<p>汇编函数会调用<code>runtime.wbBufFlush</code>将<code>write barrier</code>的缓存任务添加到GC的工作队列中进行处理，具体的标记流程和并发标记一致，这里不再赘述。</p>
<p>注意看这里，分配内存的函数当判断正在GC时则会将对象置灰：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">            gcmarknewobject(span, <span class="type">uintptr</span>(x), size, scanSize)</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcmarknewobject</span><span class="params">(span *mspan, obj, size, scanSize <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    objIndex := span.objIndex(obj)</span><br><span class="line">    <span class="comment">// 标记对象</span></span><br><span class="line">    span.markBitsForIndex(objIndex).setMarked()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完成标记"><a href="#完成标记" class="headerlink" title="完成标记"></a>完成标记</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkDone</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Ensure only one thread is running the ragged barrier at a</span></span><br><span class="line">	<span class="comment">// time.</span></span><br><span class="line">	semacquire(&amp;work.markDoneSema)</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">	<span class="comment">// 再次检查标记任务是否全部结束</span></span><br><span class="line">	<span class="keyword">if</span> !(gcphase == _GCmark &amp;&amp; work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>)) &#123;</span><br><span class="line">		semrelease(&amp;work.markDoneSema)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	semacquire(&amp;worldsema)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Flush all local buffers and collect flushedWork flags.</span></span><br><span class="line">	gcMarkDoneFlushed = <span class="number">0</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		gp := getg().m.curg</span><br><span class="line">		casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">		forEachP(<span class="function"><span class="keyword">func</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">			<span class="comment">// 将p的写屏障缓冲中的对象写入gcw</span></span><br><span class="line">			wbBufFlush1(_p_)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 将gcw中缓存的对象加入全局队列</span></span><br><span class="line">			_p_.gcw.dispose()</span><br><span class="line">			<span class="comment">// 校验写屏障缓冲区是否刷新完成</span></span><br><span class="line">			<span class="keyword">if</span> _p_.gcw.flushedWork &#123;</span><br><span class="line">				atomic.Xadd(&amp;gcMarkDoneFlushed, <span class="number">1</span>)</span><br><span class="line">				_p_.gcw.flushedWork = <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gcMarkDoneFlushed != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 若写屏障缓冲区未刷新完成，继续校验标记任务是否完成</span></span><br><span class="line">		semrelease(&amp;worldsema)</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录完成标记阶段开始的时间和STW开始的时间</span></span><br><span class="line">	now := nanotime()</span><br><span class="line">	work.tMarkTerm = now</span><br><span class="line">	work.pauseStart = now</span><br><span class="line">	getg().m.preemptoff = <span class="string">&quot;gcing&quot;</span></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGCSTWStart(<span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// STW</span></span><br><span class="line">	systemstack(stopTheWorldWithSema)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断所有p的本地gcw是否标记完成，即gcw中没有对象</span></span><br><span class="line">	restart := <span class="literal">false</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">			wbBufFlush1(p)</span><br><span class="line">			<span class="keyword">if</span> !p.gcw.empty() &#123;</span><br><span class="line">				restart = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 若存在p的本地gcw未标记完成</span></span><br><span class="line">	<span class="keyword">if</span> restart &#123;</span><br><span class="line">		getg().m.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// start the world</span></span><br><span class="line">			now := startTheWorldWithSema(<span class="literal">true</span>)</span><br><span class="line">			work.pauseNS += now - work.pauseStart</span><br><span class="line">			memstats.gcPauseDist.record(now - work.pauseStart)</span><br><span class="line">		&#125;)</span><br><span class="line">		semrelease(&amp;worldsema)</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭辅助标记协程及后台标记协程</span></span><br><span class="line">	atomic.Store(&amp;gcBlackenEnabled, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 唤醒所有因辅助GC而休眠的g</span></span><br><span class="line">	gcWakeAllAssists()</span><br><span class="line"></span><br><span class="line">	semrelease(&amp;work.markDoneSema)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 恢复用户协程的调度，但此时处在STW，唤醒的协程并不会立即执行，要等start the world</span></span><br><span class="line">	schedEnableUser(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算下一次执行GC需要的heap阈值</span></span><br><span class="line">	nextTriggerRatio := gcController.endCycle(now, <span class="type">int</span>(gomaxprocs), work.userForced)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行标记终止</span></span><br><span class="line">	gcMarkTermination(nextTriggerRatio)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤如下：</p>
<ol>
<li>遍历全部p的本地gcw，并将其中的任务全部加入到全局队列，接着判断所有p的本地gcw是否是空，若非空则跳转到本函数的起始处继续执行上面的步骤；</li>
<li>STW；</li>
<li>关闭辅助标记协程及后台标记协程；</li>
<li>唤醒所有因辅助GC而休眠的g；</li>
<li>恢复用户协程的调度，但此时处在STW，唤醒的协程并不会立即执行，要等start the world；</li>
<li>计算下一次执行GC需要的heap阈值；</li>
<li>执行标记终止；</li>
</ol>
<p>而终止标记函数，<code>gcMarkTermination</code>的主要流程如下：</p>
<ol>
<li>GC阶段设置成<code>_GCmarktermination</code></li>
<li>确认标记工作完成；</li>
<li>GC阶段设置成<code>_GCoff</code>；</li>
<li>start the world；</li>
<li>更新统计信息；</li>
<li>开始清扫工作；</li>
</ol>
<p>这个<code>gcMarkTermination</code>函数的代码比较长，但是逻辑并不复杂，主要是做一些确认工作和统计工作。</p>
<h3 id="后台清扫"><a href="#后台清扫" class="headerlink" title="后台清扫"></a>后台清扫</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcSweep</span><span class="params">(mode gcMode)</span></span> &#123;</span><br><span class="line">    assertWorldStopped()</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒后台清扫任务</span></span><br><span class="line">    lock(&amp;sweep.lock)</span><br><span class="line">    <span class="keyword">if</span> sweep.parked &#123;</span><br><span class="line">        sweep.parked = <span class="literal">false</span></span><br><span class="line">        ready(sweep.g, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;sweep.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>ready</code>函数是用来将指定的g标记成可以运行状态的。<br>在<code>main</code>主协程中有这样一句代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    gcenable()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcenable</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Kick off sweeping and scavenging.</span></span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> bgsweep(c)</span><br><span class="line">	<span class="keyword">go</span> bgscavenge(c)</span><br><span class="line">	&lt;-c</span><br><span class="line">	&lt;-c</span><br><span class="line">	memstats.enablegc = <span class="literal">true</span> <span class="comment">// now that runtime is initialized, GC is okay</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bgsweep</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	sweep.g = getg()</span><br><span class="line"></span><br><span class="line">	lockInit(&amp;sweep.lock, lockRankSweep)</span><br><span class="line">	lock(&amp;sweep.lock)</span><br><span class="line">	sweep.parked = <span class="literal">true</span></span><br><span class="line">	c &lt;- <span class="number">1</span></span><br><span class="line">	goparkunlock(&amp;sweep.lock, waitReasonGCSweepWait, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="comment">// 每扫描一个span，会主动让出执行权</span></span><br><span class="line">		<span class="keyword">for</span> sweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">			sweep.nbgsweep++</span><br><span class="line">			Gosched()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> freeSomeWbufs(<span class="literal">true</span>) &#123;</span><br><span class="line">			Gosched()</span><br><span class="line">		&#125;</span><br><span class="line">		lock(&amp;sweep.lock)</span><br><span class="line">		<span class="keyword">if</span> !isSweepDone() &#123;</span><br><span class="line">			<span class="comment">// This can happen if a GC runs between</span></span><br><span class="line">			<span class="comment">// gosweepone returning ^0 above</span></span><br><span class="line">			<span class="comment">// and the lock being acquired.</span></span><br><span class="line">			unlock(&amp;sweep.lock)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">                <span class="comment">// 清扫完成，继续阻塞</span></span><br><span class="line">		sweep.parked = <span class="literal">true</span></span><br><span class="line">		goparkunlock(&amp;sweep.lock, waitReasonGCSweepWait, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在异步启动的bgsweep方法中，会首先将当前协程gopark挂起，等待被唤醒。<br>当在标记终止阶段被唤醒后，会进入for循环，每轮完成一个mspan的清扫工作，随后就调用Gosched方法主动让出P的执行权，采用这种懒清扫的方式逐步推进标记清扫流程。</p>
<p>而核心的清扫过程在<code>sweepone</code>函数中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sweepone</span><span class="params">()</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    sl := sweep.active.begin()</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 查找到一个待清扫的 mspan</span></span><br><span class="line">        s := mheap_.nextSpanForSweep()</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> s, ok := sl.tryAcquire(s); ok &#123;</span><br><span class="line">            npages = s.npages</span><br><span class="line">            <span class="comment">// 对一个 mspan 进行清扫</span></span><br><span class="line">            <span class="keyword">if</span> s.sweep(<span class="literal">false</span>) &#123;</span><br><span class="line">                mheap_.reclaimCredit.Add(npages)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                npages = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sweep.active.end(sl)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> npages</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际负责清扫的<code>sweep</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *sweepLocked)</span></span> sweep(preserve <span class="type">bool</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> spc.sizeclass() != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 回收小对象</span></span><br><span class="line">		<span class="keyword">if</span> nfreed &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 是否有任何对象被释放</span></span><br><span class="line">			s.needzero = <span class="number">1</span></span><br><span class="line">			stats := memstats.heapStats.acquire()</span><br><span class="line">			atomic.Xadduintptr(&amp;stats.smallFreeCount[spc.sizeclass()], <span class="type">uintptr</span>(nfreed))</span><br><span class="line">			memstats.heapStats.release()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 是否需要保留span</span></span><br><span class="line">		<span class="keyword">if</span> !preserve &#123;</span><br><span class="line">			<span class="comment">// 不保留</span></span><br><span class="line">			<span class="keyword">if</span> nalloc == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// span中没有剩余的对象，将span直接释放到heap</span></span><br><span class="line">				mheap_.freeSpan(s)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// span中有剩余的对象，将span释放到mcentral</span></span><br><span class="line">			<span class="keyword">if</span> <span class="type">uintptr</span>(nalloc) == s.nelems &#123;</span><br><span class="line">				mheap_.central[spc].mcentral.fullSwept(sweepgen).push(s)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				mheap_.central[spc].mcentral.partialSwept(sweepgen).push(s)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> !preserve &#123;</span><br><span class="line">		<span class="comment">// 回收大对象</span></span><br><span class="line">		<span class="keyword">if</span> nfreed != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 有对象被释放</span></span><br><span class="line">			<span class="keyword">if</span> debug.efence &gt; <span class="number">0</span> &#123;</span><br><span class="line">				s.limit = <span class="number">0</span> <span class="comment">// prevent mlookup from finding this span</span></span><br><span class="line">				sysFault(unsafe.Pointer(s.base()), size)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 直接释放到heap中</span></span><br><span class="line">				mheap_.freeSpan(s)</span><br><span class="line">			&#125;</span><br><span class="line">			stats := memstats.heapStats.acquire()</span><br><span class="line">			atomic.Xadduintptr(&amp;stats.largeFreeCount, <span class="number">1</span>)</span><br><span class="line">			atomic.Xadduintptr(&amp;stats.largeFree, size)</span><br><span class="line">			memstats.heapStats.release()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 没有任何对象被释放，那么它会将 span 直接添加到 full+swept 列表中</span></span><br><span class="line">		mheap_.central[spc].mcentral.fullSwept(sweepgen).push(s)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的主要工作是处理 span 中的对象，根据对象的大小和数量，以及是否有对象被释放，来决定如何处理 span。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这两个配图摘自参考中的blog：<br><img src="/golang%E7%9A%84GC%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.resources/%E6%80%BB%E7%BB%93.png" alt="总结"><br><img src="/golang%E7%9A%84GC%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.resources/gc%E6%B5%81%E7%A8%8B.png" alt="gc流程"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Db19tKNer8D6FX6UG-Yujw">https://mp.weixin.qq.com/s/Db19tKNer8D6FX6UG-Yujw</a><br><a target="_blank" rel="noopener" href="https://www.luozhiyun.com/archives/475">https://www.luozhiyun.com/archives/475</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">bank</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/08/23/golang%E7%9A%84gc%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">http://example.com/2023/08/23/golang%E7%9A%84gc%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">bank blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/golang/">golang</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/08/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%AD%A6%E4%B9%A0/" title="分布式事务学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">分布式事务学习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/05/16/golang%E6%8C%87%E9%92%88/" title="golang指针讨论"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-16</div><div class="title">golang指针讨论</div></div></a></div><div><a href="/2023/05/19/golang%E5%AE%9E%E7%8E%B0%E8%B7%B3%E8%A1%A8/" title="golang实现跳表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-19</div><div class="title">golang实现跳表</div></div></a></div><div><a href="/2023/08/10/golang%E7%9A%84GC/" title="golang的GC"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-10</div><div class="title">golang的GC</div></div></a></div><div><a href="/2023/08/08/golang%E7%9A%84GMP/" title="golang的GMP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-08</div><div class="title">golang的GMP</div></div></a></div><div><a href="/2023/08/10/golang%E7%9A%84sync.map/" title="golang的sync.map"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-10</div><div class="title">golang的sync.map</div></div></a></div><div><a href="/2023/08/10/golang%E7%9A%84map/" title="golang的map"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-10</div><div class="title">golang的map</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">bank</div><div class="author-info__description">行至水穷处,坐看云起时</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E8%A7%88"><span class="toc-number">1.</span> <span class="toc-text">总览</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA"><span class="toc-number">2.1.</span> <span class="toc-text">触发时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">GC流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8GC"><span class="toc-number">2.2.1.</span> <span class="toc-text">主动GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gcStart"><span class="toc-number">2.2.2.</span> <span class="toc-text">gcStart</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gcBgMarkStartWorkers"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">gcBgMarkStartWorkers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STW"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">STW</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#startCycle"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">startCycle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setGCPhase"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">setGCPhase</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gcMarkTinyAllocs"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">gcMarkTinyAllocs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#start-the-world"><span class="toc-number">2.2.2.6.</span> <span class="toc-text">start the world</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6"><span class="toc-number">2.2.3.</span> <span class="toc-text">调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5"><span class="toc-number">2.2.4.</span> <span class="toc-text">标记阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%B8%8D%E5%90%8C%E7%9A%84mode%E9%87%87%E5%8F%96%E4%B8%8D%E5%90%8C%E7%9A%84GC%E7%AD%96%E7%95%A5"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">根据不同的mode采取不同的GC策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%A0%B9%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">标记根对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9gcw%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">消费gcw中的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E6%A0%87%E8%AE%B0"><span class="toc-number">2.2.4.4.</span> <span class="toc-text">辅助标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="toc-number">2.2.4.5.</span> <span class="toc-text">写屏障</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E6%A0%87%E8%AE%B0"><span class="toc-number">2.2.5.</span> <span class="toc-text">完成标记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E6%B8%85%E6%89%AB"><span class="toc-number">2.2.6.</span> <span class="toc-text">后台清扫</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/23/golang%E7%9A%84gc%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" title="golang的GC源码阅读">golang的GC源码阅读</a><time datetime="2023-08-23T08:42:42.422Z" title="发表于 2023-08-23 16:42:42">2023-08-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%AD%A6%E4%B9%A0/" title="分布式事务学习">分布式事务学习</a><time datetime="2023-08-20T09:10:31.395Z" title="发表于 2023-08-20 17:10:31">2023-08-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/16/%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E8%AE%A8%E8%AE%BA/" title="缓存相关讨论">缓存相关讨论</a><time datetime="2023-08-16T05:54:27.557Z" title="发表于 2023-08-16 13:54:27">2023-08-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/14/golang%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" title="golang的内存分配">golang的内存分配</a><time datetime="2023-08-14T11:12:56.579Z" title="发表于 2023-08-14 19:12:56">2023-08-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/13/golang%E7%9A%84%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/" title="golang的内存逃逸">golang的内存逃逸</a><time datetime="2023-08-13T09:53:37.132Z" title="发表于 2023-08-13 17:53:37">2023-08-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By bank</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>