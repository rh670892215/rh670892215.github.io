<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>网络编程的一些思考 | bank blog</title><meta name="author" content="bank"><meta name="copyright" content="bank"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="article">
<meta property="og:title" content="网络编程的一些思考">
<meta property="og:url" content="http://example.com/2023/06/06/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/index.html">
<meta property="og:site_name" content="bank blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-06-06T09:30:37.533Z">
<meta property="article:modified_time" content="2023-07-11T11:12:52.065Z">
<meta property="article:author" content="bank">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/06/06/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '网络编程的一些思考',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-11 19:12:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="bank blog"><span class="site-name">bank blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">网络编程的一些思考</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-06T09:30:37.533Z" title="发表于 2023-06-06 17:30:37">2023-06-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-11T11:12:52.065Z" title="更新于 2023-07-11 19:12:52">2023-07-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>70分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="网络编程的一些思考"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer"/>
<span id="more"></span>

<h1 id="网络编程的一些思考"><a href="#网络编程的一些思考" class="headerlink" title="网络编程的一些思考"></a>网络编程的一些思考</h1><p>最近在研究golang的网络模型的时候，联想到了之前学习过的一些linux网络编程的知识，在这里进行总结，加深自己对网络编程的理解。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>进程：占用内存空间的正在运行的程序。<br>进程创建后系统会给进程分配一个ID（进程ID），其值是大于2的整数，1要分配给操作系统启动后的（用于协助操作系统）首个进程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查看所有进程</span><br><span class="line">ps au</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 成功时返回进程ID,失败时返回 -1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对于父进程返回子进程PID</li>
<li>对于子进程返回0</li>
</ul>
<p>通过fork创建子进程后，父子进程共用一套代码，但各自的内存空间是独立的，见下面的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> globalVal = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> localVal = <span class="number">25</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        localVal++;</span><br><span class="line">        globalVal++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        localVal--;</span><br><span class="line">        globalVal--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child proc localVal :[%d],globalVal is :[%d]\n&quot;</span>, localVal, globalVal);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent proc localVal :[%d],globalVal is :[%d]\n&quot;</span>, localVal, globalVal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过fork创建子进程后,父子进程拥有独立的内存结构,只是共用一套代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[centos ~/net_test/10]$ ./fork </span><br><span class="line">parent proc localVal :[24],globalVal is :[9]</span><br><span class="line">child proc localVal :[26],globalVal is :[11]</span><br></pre></td></tr></table></figure>
<p>完整程序：<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/process/fork.c">fork</a></p>
<h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p>这里有个老生常谈的问题，僵尸进程。<br>僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。如果父进程先退出，子进程被init接管，子进程退出后init会回收其占用的相关资源。<br>也就是说父进程创建完子进程后一定要记得回收，防止出现僵尸进程。<br>来做个实验：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;here is child process&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child pid is %d\n&quot;</span>, pid);</span><br><span class="line">        sleep(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;child process end&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;parent process end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/process/zombie.c">zombie</a><br>执行结果如下：<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/zombie_run.png" alt="zombie_run"><br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/zombie_monitor.png" alt="zombie_monitor"><br>子进程结束后，父进程并没有进行回收，在父进程sleep的期间可以看到，子进程变成了僵尸进程。</p>
<p>首先来看一下fork子进程的终止方式：</p>
<ul>
<li>传递参数并调用exit()函数</li>
<li>main函数中执行return语句并返回值</li>
</ul>
<p>而向exit函数传入的值和return返回的值都会传给操作系统，而操作系统不会销毁子进程，也不会将这些值主动传给父进程，所以就导致了僵尸进程的产生。<br>只有父进程主动发起请求（函数调用）的时候，操作系统才会传递该值。换言之，如果父进程未主动要求获得子进程结束状态值，操作系统将一直保存，并让子进程长时间处于僵尸进程状态。也就是说，父母要负责收回自己生的孩子。<br>对于父进程收回子进程，有以下两种方式：</p>
<ol>
<li>wait<br>函数签名：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *statloc)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回终止的子进程 ID ,失败时返回 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
调用此函数时如果已有子进程终止，那么子进程终止时传递的返回值（exit 函数的参数返回值，main函数的return返回值）将保存到该函数的参数所指的内存空间。但函数参数指向的单元中还包含其他信息，因此需要用下列宏进行分离：</li>
</ol>
<ul>
<li>WIFEXITED 子进程正常终止时返回真</li>
<li>WEXITSTATUS 返回子进程时的返回值</li>
</ul>
<p>也就是说，向wait函数传递变量status的地址时，调用wait函数后应编写如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Normal termination&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Child pass num: %d&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child one process pid is [%d]\n&quot;</span>, pid);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child two process pid is [%d]\n&quot;</span>, pid);</span><br><span class="line">            <span class="comment">// 调用wait函数消灭僵尸进程的,调用wait函数时，如果没有己终止的子进程,那么程序将阻塞(Blocking)直到有子进程终止</span></span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child one return %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child two return %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">            &#125;</span><br><span class="line">            sleep(<span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码：<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/process/wait.c">wait</a><br>这就是通过wait函数消灭僵尸进程的方法，调用 wait 函数时，如果没有已经终止的子进程，那么程序将阻塞直到有子进程终止，因此要谨慎调用该函数。</p>
<ol start="2">
<li>waitpid<br>wait函数会引起程序阻塞，还可以考虑调用waitpid函数。这是防止僵尸进程的第二种方法，也是防止阻塞的方法。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *statloc, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回终止的子进程ID 或 0 ，失败时返回 -1</span></span><br><span class="line"><span class="comment">pid: 等待终止的目标子进程的ID,若传 -1，则与 wait 函数相同，可以等待任意子进程终止</span></span><br><span class="line"><span class="comment">statloc: 与 wait 函数的 statloc 参数具有相同含义</span></span><br><span class="line"><span class="comment">options: 传递头文件 sys/wait.h 声明的常量 WNOHANG ,即使没有终止的子进程也不会进入阻塞状态，而是返回 0 退出函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
代码实现：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">15</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process pid is %d\n&quot;</span>, pid);</span><br><span class="line">        <span class="comment">// waitpid 第一个参数传-1表示等待任何子进程的结束</span></span><br><span class="line">        <span class="comment">// 第二个参数与wait相同</span></span><br><span class="line">        <span class="comment">// 第三个参数传声明的常量WNOHANG,即使没有终止的子进程也不会进入阻塞状态，而是返回0退出函数。</span></span><br><span class="line">        <span class="keyword">while</span> (!waitpid(<span class="number">-1</span>, &amp;status, WNOHANG)) &#123;</span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent wait 3 second.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child process return %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/process/wait_pid.c">wait_pid</a></li>
</ol>
<h4 id="信号处理机制"><a href="#信号处理机制" class="headerlink" title="信号处理机制"></a>信号处理机制</h4><p>子进程终止的识别主题是操作系统，因此，若操作系统能把子进程结束的信息告诉正忙于工作的父进程，将有助于构建更高效的程序，我们来讨论一下信号处理机制，【信号】是在特定事件发生时由操作系统向进程发送的消息。</p>
<h5 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h5><p>当进程发现自己的子进程结束时，可以请求操作系统调用指定的函数，该请求可以通过如下函数调用来完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> signo, <span class="type">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为了在产生信号时调用，返回之前注册的函数指针</span></span><br><span class="line"><span class="comment">函数名: signal</span></span><br><span class="line"><span class="comment">参数：int signo,void(*func)(int)</span></span><br><span class="line"><span class="comment">返回类型：参数类型为int型，返回 void 型函数指针</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>调用上述函数时，第一个参数为特殊情况信息，第二个参数为特殊情况下将要调用的函数的地址值（指针）。发生第一个参数代表的情况时，调用第二个参数所指的函数。下面给出可以在signal函数中注册的部分特殊情况和对应的函数。</p>
<ul>
<li>SIGALRM：已到通过调用 alarm 函数注册时间</li>
<li>SIGINT：输入 ctrl+c</li>
<li>SIGCHLD：子进程终止</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">keyControl</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timeout</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    signal(SIGINT, keyControl);</span><br><span class="line">    signal(SIGALRM, timeout);</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 这里看程序本应阻塞300s,但是实际执行过程中不到10s程序就会执行结束,原因如下:</span></span><br><span class="line">        <span class="comment">// 发生信号时将唤醒由于调用 sleep函数而进入阻塞状态的进程,而进程一旦被唤醒就不会再进入睡眠状态(即使sleep中的时间还未到);</span></span><br><span class="line">        <span class="comment">// 因此整个程序10s还不到就会运行完毕;</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;wait...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">keyControl</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGINT) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;input ctr + c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timeout</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGALRM) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;timeout...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码：<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/process/signal.c">signal</a></p>
<p>调用函数的主体的确是操作系统，但是进程处于睡眠状态时无法调用函数，因此，产生信号时，为了调用信号处理器，将唤醒由于调用 sleep 函数而进入阻塞状态的进程。而且，进程一旦被唤醒，就不会再进入睡眠状态。即使还未到 sleep 中规定的时间也是如此。所以上述示例运行不到 10 秒后就会结束，连续输入 CTRL+C 可能连一秒都不到。</p>
<h5 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h5><p>signal函数在Unix系列的不同操作系统可能存在区别，但sigaction函数完全相同，因此更多的是使用sigaction函数来实现信号处理机制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signo, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 0 ，失败时返回 -1</span></span><br><span class="line"><span class="comment">act: 对于第一个参数的信号处理函数（信号处理器）信息。</span></span><br><span class="line"><span class="comment">oldact: 通过此参数获取之前注册的信号处理函数指针，若不需要则传递 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;</span><br><span class="line">    <span class="type">int</span> sa_flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此结构体的成员sa_handler保存信号处理的函数指针值（地址值）。sa_mask 和 sa_flags 的所有位初始化0即可。这2个成员用于指定信号相关的选项和特性，而我们的目的主要是防止产生僵尸进程，故省略。</p>
<p>首先来看一下sigaction函数的使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timeout</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_handler = timeout;</span><br><span class="line">    <span class="comment">// 将act结构体中的sa_mask成员设置为空信号集，表示在执行信号处理函数时不屏蔽任何信号。这意味着，在信号处理函数执行期间，可以接收和处理其他信号</span></span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    <span class="comment">// 将act结构体中的sa_flags成员设置为0，表示不使用任何特殊的标志。这意味着，在信号处理函数执行期间，不会进行任何特殊的处理</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sigaction(SIGALRM, &amp;act, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    alarm(<span class="number">2</span>);<span class="comment">// 每隔2s产生信号</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;wait...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timeout</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sig == SIGALRM) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;timeout...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[centos ~/net_test/10]$ ./sigaction </span><br><span class="line">wait...</span><br><span class="line">timeout...</span><br><span class="line">wait...</span><br><span class="line">timeout...</span><br><span class="line">wait...</span><br><span class="line">timeout...</span><br></pre></td></tr></table></figure>
<p>可以发现，和上面的signal函数调用结果并无区别。<br>下面我们来使用sigaction处理僵尸进程。<br>完整代码：<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/process/remove_zombie.c">remove_zombie</a><br>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[centos ~/net_test/10]$ ./remove_zombie </span><br><span class="line">child pid is [18016]wait...</span><br><span class="line">this is chile process</span><br><span class="line">this is child process</span><br><span class="line">wait...</span><br><span class="line">wait...</span><br><span class="line">child process pid is [18015]exit ok.return [1]</span><br><span class="line">wait...</span><br><span class="line">wait...</span><br></pre></td></tr></table></figure>
<p>可以看到我们优雅的处理了结束的子进程，并拿到了子进程返回的值。</p>
<h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><p>进程间可以通过管道来实现通信，下面给出函数签名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> filedes[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 0 ，失败时返回 -1</span></span><br><span class="line"><span class="comment">filedes[0]: 通过管道接收数据时使用的文件描述符，即管道出口</span></span><br><span class="line"><span class="comment">filedes[1]: 通过管道传输数据时使用的文件描述符，即管道入口</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>先来看个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="comment">// 创建管道,fds[0]:消息出口; fds[1]:消息入口;</span></span><br><span class="line">    pipe(fds);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意,子进程复制的并非管道，而是用于管道I/O的文件描述符</span></span><br><span class="line">        write(fds[<span class="number">1</span>], str, <span class="keyword">sizeof</span>(str));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        read(fds[<span class="number">0</span>], message, BUF_SIZE);</span><br><span class="line">        <span class="built_in">puts</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整程序：<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/process_communication/pipe1.c">pipe1</a><br>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[centos ~/net_test/11]$ ./pipe1</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>可以看到简单的完成了进程间的一发一收的通信，再来看下一个程序实现全双工通信。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;welcome in&quot;</span>;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    pipe(fds);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        write(fds[<span class="number">1</span>], str1, <span class="keyword">sizeof</span>(str1));</span><br><span class="line">        <span class="comment">// 下面这个&quot;sleep(2);&quot;的代码若注释掉,会导致程序无限等待,原因如下:</span></span><br><span class="line">        <span class="comment">// 数据进入管道后成为无主数据.也就是通过read函数先读取数据的进程将得到数据.即使该进程将数据传到了管道</span></span><br><span class="line">        <span class="comment">// 因此,注释掉&quot;sleep(2);&quot;,接下来子进程将读回自己向管道发送的数据.</span></span><br><span class="line">        <span class="comment">// 结果,父进程调用read函数后将元限期等待数据进入管道.</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        read(fds[<span class="number">0</span>], message, BUF_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process read message : %s\n&quot;</span>, message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        read(fds[<span class="number">0</span>], message, BUF_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process read message : %s\n&quot;</span>, message);</span><br><span class="line">        write(fds[<span class="number">1</span>], str2, <span class="keyword">sizeof</span>(str2));</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整程序：<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/process_communication/pipe2.c">pipe2</a><br>这种方式对时序的要求很严格，若注释掉<code>sleep(2)</code>，会导致程序无限等待，这是由于数据进入管道后成为无主数据.也就是通过read函数先读取数据的进程将得到数据.即使该进程将数据传到了管道，因此,注释掉”sleep(2);”,接下来子进程将读回自己向管道发送的数据。结果,父进程调用read函数后将元限期等待数据进入管道.</p>
<p>那要是实现双向通信的管道该怎么做呢，声明两个管道即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> fds1[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> fds2[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;welcome in&quot;</span>;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    pipe(fds1);</span><br><span class="line">    pipe(fds2);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        read(fds1[<span class="number">0</span>], message, BUF_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process read message : %s\n&quot;</span>, message);</span><br><span class="line">        write(fds2[<span class="number">1</span>], str2, <span class="keyword">sizeof</span>(str2));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        write(fds1[<span class="number">1</span>], str1, <span class="keyword">sizeof</span>(str1));</span><br><span class="line">        read(fds2[<span class="number">0</span>], message, BUF_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process read message : %s\n&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整程序：<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/process_communication/pipe3.c">pipe3</a></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>创建进程、进程间的数据交换、上下文切换等过程开销比较大，其中【上下文切换】的系统开销最大，具体是指运行程序前需要将相应进程信息读入内存，如果运行进程A后紧接着需要运行进程B，就应该将进程A相关信息移出内存，并读入进程B相关信息。</p>
<p>每个进程的内存空间都由保存全局变量的【数据区】、向malloc等函数动态分配提供空间的堆（Heap）、函数运行时间使用的栈（Stack）构成。每个进程都有独立的这种空间，进程结构如下：<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="进程结构"></p>
<p>线程是为了解决：为了得到多条代码执行流而复制整个内存区域的负担太重。有如下优点：</p>
<ul>
<li>上下文切换时不需要切换数据区和堆</li>
<li>可以利用数据区和堆交换数据</li>
</ul>
<p>线程内存结构如下：<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="线程结构"><br>综上：</p>
<ul>
<li>进程：在操作系统构成单独执行流的单位</li>
<li>线程：在进程构成单独执行流的单位</li>
</ul>
<p>下面来讨论下线程相关的代码实现。<br>创建线程的函数签名如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *<span class="keyword">restrict</span> thread,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *),</span></span><br><span class="line"><span class="params">                   <span class="type">void</span> *<span class="keyword">restrict</span> arg)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 0 ，失败时返回 -1</span></span><br><span class="line"><span class="comment">thread : 保存新创建线程 ID 的变量地址值。线程与进程相同，也需要用于区分不同线程的 ID</span></span><br><span class="line"><span class="comment">attr : 用于传递线程属性的参数，传递 NULL 时，创建默认属性的线程</span></span><br><span class="line"><span class="comment">start_routine : 相当于线程 main 函数的、在单独执行流中执行的函数地址值（函数指针）</span></span><br><span class="line"><span class="comment">arg : 通过第三个参数传递的调用函数时包含传递参数信息的变量地址值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>其中<code>start_routine</code>参数用来指定线程执行时的入口。<br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/thread/thread1.c">thread1</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc thread1.c -o tr1 -lpthread # 线程相关代码编译时需要添加 -lpthread 选项声明需要连接到线程库</span><br></pre></td></tr></table></figure>
<p>上面的代码中在主线程中使用sleep等待子线程的执行完毕，实际开发中需要使用<code>pthread_join</code>函数来等待子进程的执行完成，防止住进程在子进程执行完毕前退出，导致程序的中止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **status)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 0 ，失败时返回 -1</span></span><br><span class="line"><span class="comment">thread : 该参数值 ID 的线程终止后才会从该函数返回</span></span><br><span class="line"><span class="comment">status : 保存线程的 main 函数返回值的指针的变量地址值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/thread/thread2.c">thread2</a></p>
<p>存在并发的场景，自然存在临界区的概念，临界区：函数内同时运行多个线程引起问题的多条语句构成的代码块。根据是否线程安全，函数可分成两类：</p>
<ul>
<li>线程安全函数</li>
<li>非线程安全函数</li>
</ul>
<p>大多数标准函数都是线程安全函数。操作系统在定义非线程安全函数的同时，提供了具有相同功能的线程安全的函数，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *hostname)</span>;</span><br></pre></td></tr></table></figure>
<p>上述函数的线程安全版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyname_r</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> hostent *result,</span></span><br><span class="line"><span class="params">                                <span class="type">char</span> *buffer,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> intbuflen,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> *h_errnop)</span>;</span><br></pre></td></tr></table></figure>
<p>通常后缀是_r。<br>在编译的时候指定宏，可以自动把非线程安全函数替换成线程安全函数，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -D_REENTRANT thread.c -o thread -lpthread</span><br></pre></td></tr></table></figure>
<p>看下面的例子：<br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/thread/thread3.c">thread3</a><br>执行成果符合预期<code>55</code>。<br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/thread/thread4.c">thread4</a><br>执行结果不符合预期<code>0</code>，且不稳定，这是因为发生了竞态。</p>
<p>讨论一下锁和信号。<br><strong>锁</strong><br>互斥锁（英语：英语：Mutual exclusion，缩写 Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全域变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区域（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 0，失败时返回其他值</span></span><br><span class="line"><span class="comment">mutex : 创建互斥量时传递保存互斥量的变量地址值，销毁时传递需要销毁的互斥量地址</span></span><br><span class="line"><span class="comment">attr : 传递即将创建的互斥量属性，没有特别需要指定的属性时传递 NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 0 ，失败时返回其他值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">//临界区开始</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//临界区结束</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p>代码实现：<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/thread/mutex.c">mutex</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">死锁产生条件：</span><br><span class="line">1. 互斥条件：一个资源每次只能被一个进程使用，如果其他进程想要使用该资源，就必须等待。</span><br><span class="line">2. 请求与保持条件：一个进程在持有某个资源的同时，又请求其他资源，但是这些资源已经被其他进程占用了，因此该进程会被阻塞，但是它又不释放已经持有的资源。</span><br><span class="line">3. 不剥夺条件：已经分配给进程的资源不能被强制性地剥夺，只能在进程使用完之后自动释放。</span><br><span class="line">4. 循环等待条件：若干个进程之间形成一种头尾相接的循环等待资源的关系，即进程 A 等待进程 B 占用的资源，进程 B 等待进程 C 占用的资源，进程 C 等待进程 A 占用的资源，形成了一个死循环。</span><br></pre></td></tr></table></figure>

<p><strong>信号</strong><br>信号量（英语：Semaphore）又称为信号标，是一个同步对象，用于保持在0至指定最大值之间的一个计数值。当线程完成一次对该semaphore对象的等待（wait）时，该计数值减一；当线程完成一次对semaphore对象的释放（release）时，计数值加一。当计数值为0，则线程等待该semaphore对象不再能成功直至该semaphore对象变成signaled状态。semaphore对象的计数值大于0，为signaled状态；计数值等于0，为nonsignaled状态.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 0 ，失败时返回其他值</span></span><br><span class="line"><span class="comment">sem : 创建信号量时保存信号量的变量地址值，销毁时传递需要销毁的信号量变量地址值</span></span><br><span class="line"><span class="comment">pshared : 传递其他值时，创建可由多个继承共享的信号量；传递 0 时，创建只允许 1 个进程内部使用的信号量。需要完成同一进程的线程同步，故为0</span></span><br><span class="line"><span class="comment">value : 指定创建信号量的初始值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 0 ，失败时返回其他值</span></span><br><span class="line"><span class="comment">sem : 传递保存信号量读取值的变量地址值，传递给 sem_post 的信号量增1，传递给 sem_wait 时信号量减一</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;sem);<span class="comment">//信号量变为0...</span></span><br><span class="line"><span class="comment">// 临界区的开始</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//临界区的结束</span></span><br><span class="line">sem_post(&amp;sem);<span class="comment">//信号量变为1...</span></span><br></pre></td></tr></table></figure>
<p>调用 sem_wait 函数进入临界区的线程在调用 sem_post 函数前不允许其他线程进入临界区。信号量的值在 0 和 1 之间跳转，因此，具有这种特性的机制称为【二进制信号量】。<br>代码实现：<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/thread/semaphore.c">semaphore</a></p>
<p>进程的销毁方式：</p>
<ul>
<li>调用pthread_join函数</li>
<li>调用pthread_detach函数</li>
</ul>
<p><code>pthread_join</code>函数。调用该函数时，不仅会等待线程终止，还会引导线程销毁。但该函数的问题是，线程终止前，调用该函数的线程将进入<code>阻塞</code>状态。而调用<code>pthread_detach</code>函数不会引起线程终止或进入阻塞状态，可以通过该函数引导销毁线程创建的内存空间。调用该函数后不能再针对相应线程调用<code>pthread_join</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> th)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 0 ，失败时返回其他值</span></span><br><span class="line"><span class="comment">thread : 终止的同时需要销毁的线程 ID</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>先来讨论一下linux中的文件描述符，程序运行起来后会按序给文件描述符分配编号，<br>分配给标准输入输出及标准错误的文件描述符：</p>
<table>
<thead>
<tr>
<th>文件描述符</th>
<th>对象</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>标准输入：Standard Input</td>
</tr>
<tr>
<td>1</td>
<td>标准输出：Standard Output</td>
</tr>
<tr>
<td>2</td>
<td>标准错误：Standard Error</td>
</tr>
</tbody></table>
<p>文件打开模式：</p>
<table>
<thead>
<tr>
<th>打开模式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>O_CREAT</td>
<td>必要时创建文件</td>
</tr>
<tr>
<td>O_TRUNC</td>
<td>删除全部现有数据</td>
</tr>
<tr>
<td>O_APPEND</td>
<td>维持现有数据，保存到其后面</td>
</tr>
<tr>
<td>O_RDONLY</td>
<td>只读打开</td>
</tr>
<tr>
<td>O_WRONLY</td>
<td>只写打开</td>
</tr>
<tr>
<td>O_RDWR</td>
<td>读写打开</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> flag)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回文件描述符，失败时返回-1</span></span><br><span class="line"><span class="comment">path : 文件名的字符串地址</span></span><br><span class="line"><span class="comment">flag : 文件打开模式信息</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回写入的字节数 ，失败时返回 -1</span></span><br><span class="line"><span class="comment">fd : 显示数据传输对象的文件描述符</span></span><br><span class="line"><span class="comment">buf : 保存要传输数据的缓冲值地址</span></span><br><span class="line"><span class="comment">nbytes : 要传输数据的字节数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回接收的字节数（但遇到文件结尾则返回 0），失败时返回 -1</span></span><br><span class="line"><span class="comment">fd : 显示数据接收对象的文件描述符</span></span><br><span class="line"><span class="comment">buf : 要保存接收的数据的缓冲地址值。</span></span><br><span class="line"><span class="comment">nbytes : 要接收数据的最大字节数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 0 ，失败时返回 -1</span></span><br><span class="line"><span class="comment">fd : 需要关闭的文件或套接字的文件描述符</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>因此我们使用的文件描述符是从3开始的，证明下：<br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/fd_seri.c">fd_seri</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[centos ~/net_test/00]$ ./fd</span><br><span class="line">file descriptor 1: 3</span><br><span class="line">file descriptor 2: 4</span><br><span class="line">file descriptor 3: 5</span><br></pre></td></tr></table></figure>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>我们都知道在linux中一切皆文件，套接字socket也是文件的一种，因此在网络数据传输中自然可以使用I&#x2F;O相关的函数。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回文件描述符，失败时返回-1</span></span><br><span class="line"><span class="comment">domain: 套接字中使用的协议族（Protocol Family）</span></span><br><span class="line"><span class="comment">type: 套接字数据传输的类型信息</span></span><br><span class="line"><span class="comment">protocol: 计算机间通信中使用的协议信息</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>接下来逐个介绍参数：<br><strong>domain:Protocol Family</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>协议族</th>
</tr>
</thead>
<tbody><tr>
<td>PF_INET</td>
<td>IPV4 互联网协议族</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>IPV6 互联网协议族</td>
</tr>
<tr>
<td>PF_LOCAL</td>
<td>本地通信 Unix 协议族</td>
</tr>
<tr>
<td>PF_PACKET</td>
<td>底层套接字的协议族</td>
</tr>
<tr>
<td>PF_IPX</td>
<td>IPX Novel 协议族</td>
</tr>
</tbody></table>
<p><strong>type：套接字类型</strong><br>套接字类型指的是套接字的数据传输方式，是通过 socket 函数的第二个参数进行传递，只有这样才能决定创建的套接字的数据传输方式。已经通过第一个参数传递了协议族信息，为什么还要决定数据传输方式？问题就在于，决定了协议族并不能同时决定数据传输方式。换句话说， socket 函数的第一个参数 PF_INET 协议族中也存在多种数据传输方式。</p>
<ol>
<li>SOCK_STREAM<br>面向连接的套接字，可靠地、按序传递的、基于字节的面向连接的数据传输方式的套接字。（TCP）<br>收发数据的套接字内部有缓冲（buffer），简言之就是字节数组。只要不超过数组容量，那么数据填满缓冲后过 1 次 read 函数的调用就可以读取全部，也有可能调用多次来完成读取。如果读取速度比数据传入过来的速度慢，则缓冲可能被填满，但是这时也不会丢失数据，因为传输套接字此时会停止数据传输，所以面向连接的套接字不会发生数据丢失。<br>总结特点如下：</li>
</ol>
<ul>
<li>传输过程中数据不会消失</li>
<li>按序传输数据</li>
<li>传输的数据不存在数据边界（Boundary）</li>
</ul>
<ol start="2">
<li>SOCK_DGRAM<br>面向消息的套接字，比面向连接的套接字更具哟传输速度，但可能丢失，总结特点：<code>不可靠的、不按序传递的、以数据的高速传输为目的套接字</code>（UDP）<br>特点如下：</li>
</ol>
<ul>
<li>强调快速传输而非传输有序</li>
<li>传输的数据可能丢失也可能损毁</li>
<li>传输的数据有边界</li>
<li>限制每次传输数据的大小</li>
</ul>
<p><strong>protocol：协议的最终选择</strong><br>socket 函数的第三个参数决定最终采用的协议，可以应对同一协议族中存在的多个数据传输方式相同的协议，所以数据传输方式相同，但是协议不同，需要用第三个参数指定具体的协议信息。</p>
<h4 id="套接字的可选项"><a href="#套接字的可选项" class="headerlink" title="套接字的可选项"></a>套接字的可选项</h4><table>
<thead>
<tr>
<th>协议层</th>
<th>选项名</th>
</tr>
</thead>
<tbody><tr>
<td>SOL_SOCKET</td>
<td>SO_SNDBUF</td>
</tr>
<tr>
<td>SOL_SOCKET</td>
<td>SO_RCVBUF</td>
</tr>
<tr>
<td>SOL_SOCKET</td>
<td>SO_REUSEADDR</td>
</tr>
<tr>
<td>SOL_SOCKET</td>
<td>SO_KEEPALIVE</td>
</tr>
<tr>
<td>SOL_SOCKET</td>
<td>SO_BROADCAST</td>
</tr>
<tr>
<td>SOL_SOCKET</td>
<td>SO_DONTROUTE</td>
</tr>
<tr>
<td>SOL_SOCKET</td>
<td>SO_OOBINLINE</td>
</tr>
<tr>
<td>SOL_SOCKET</td>
<td>SO_ERROR</td>
</tr>
<tr>
<td>SOL_SOCKET</td>
<td>SO_TYPE</td>
</tr>
<tr>
<td>IPPROTO_IP</td>
<td>IP_TOS</td>
</tr>
<tr>
<td>IPPROTO_IP</td>
<td>IP_TTL</td>
</tr>
<tr>
<td>IPPROTO_IP</td>
<td>IP_MULTICAST_TTL</td>
</tr>
<tr>
<td>IPPROTO_IP</td>
<td>IP_MULTICAST_LOOP</td>
</tr>
<tr>
<td>IPPROTO_IP</td>
<td>IP_MULTICAST_IF</td>
</tr>
<tr>
<td>IPPROTO_TCP</td>
<td>TCP_KEEPALIVE</td>
</tr>
<tr>
<td>IPPROTO_TCP</td>
<td>TCP_NODELAY</td>
</tr>
<tr>
<td>IPPROTO_TCP</td>
<td>TCP_MAXSEG</td>
</tr>
</tbody></table>
<p>读取配置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">void</span> *optval, <span class="type">socklen_t</span> *optlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 0 ，失败时返回 -1</span></span><br><span class="line"><span class="comment">sock: 用于查看选项套接字文件描述符</span></span><br><span class="line"><span class="comment">level: 要查看的可选项协议层</span></span><br><span class="line"><span class="comment">optname: 要查看的可选项名</span></span><br><span class="line"><span class="comment">optval: 保存查看结果的缓冲地址值</span></span><br><span class="line"><span class="comment">optlen: 向第四个参数传递的缓冲大小。调用函数候，该变量中保存通过第四个参数返回的可选项信息的字节数。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>修改配置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 0 ，失败时返回 -1</span></span><br><span class="line"><span class="comment">sock: 用于更改选项套接字文件描述符</span></span><br><span class="line"><span class="comment">level: 要更改的可选项协议层</span></span><br><span class="line"><span class="comment">optname: 要更改的可选项名</span></span><br><span class="line"><span class="comment">optval: 保存更改结果的缓冲地址值</span></span><br><span class="line"><span class="comment">optlen: 向第四个参数传递的缓冲大小。调用函数后，该变量中保存通过第四个参数返回的可选项信息的字节数。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>exp：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设置IO缓冲：SO_SNDBUF &amp; SO_RCVBUF</span><br><span class="line">设置地址重用：SO_REUSEADDR</span><br><span class="line">关闭Nagle算法：TCP_NODELAY</span><br></pre></td></tr></table></figure>
<p>获取IO缓冲大小完整代码：<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/get_buf.c">get_buf</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[centos ~/net_test/08]$ ./get </span><br><span class="line">input buf size: 131072</span><br><span class="line">output buf size: 16384</span><br></pre></td></tr></table></figure>

<h2 id="四层网络模型"><a href="#四层网络模型" class="headerlink" title="四层网络模型"></a>四层网络模型</h2><p>我们来看一下四层网络模型：<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/tcp%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B.png" alt="四层网络模型"><br>我们来自底向上的简单介绍一下各个层。</p>
<h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>主要负责数据在网络中的传输，网络接口层是物理链接领域标准化的结果，也是最基本的领域，专门定义LAN、WAN、MAN等网络标准。若两台主机通过网络进行数据交换，则需要物理连接，链路层就负责这些标准。</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>IP协议就位于这一层。<br>IP 是 Internet Protocol（网络协议）的简写，是为收发网络数据而分配给计算机的值。端口号并非赋予计算机的值，而是为了区分程序中创建的套接字而分配给套接字的序号。换句话说就是通过IP定位到一台计算机，这样数据就可以找到需要传输的位置，通过端口号来确定需要接收数据的进程，（进程监听端口号），这样就实现了两台计算机上不同进程间交换数据；<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png" alt="数据传输过程"><br>IP地址分成两类：</p>
<ul>
<li>IPV4:4字节地址族；</li>
<li>IPV6:16字节地址族；</li>
</ul>
<p>目前通用的是IPV4，IPV6的普及还需要一段时间。<br>IPV4标准的4字节IP地址分成<strong>网络地址</strong>和<strong>主机地址</strong>，同时还分成ABCD四类IP地址，如下图：<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/IP%E5%88%86%E7%B1%BB.png" alt="IP分类"></p>
<ul>
<li>A类地址首字节范围：0～127；</li>
<li>B类地址的首字节范围：128～191；</li>
<li>C类地址的首字节范围：192～223；</li>
</ul>
<p>通过IP地址我们可以找到确定的计算机，下面通过端口号就可以确定对应的应用程序了，端口号由16位构成，可分配的端口号范围是0～65535，其中0～1023是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/TCP/UDP%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8#0%E5%88%B01023%E5%8F%B7%E7%AB%AF%E5%8F%A3">知名端口</a>，一般分配给特定的应用程序；</p>
<p>网络编程中使用如下结构体表示IP地址:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;  <span class="comment">//地址族（Address Family）</span></span><br><span class="line">    <span class="type">uint16_t</span> sin_port;       <span class="comment">//16 位 TCP/UDP 端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">//32位 IP 地址</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>];        <span class="comment">//不使用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr; <span class="comment">//32位IPV4地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们来详细介绍一下结构体中的各个字段：</p>
<ul>
<li>sin_family</li>
</ul>
<table>
<thead>
<tr>
<th>地址族（Address Family）</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>AF_INET</td>
<td>IPV4用的地址族</td>
</tr>
<tr>
<td>AF_INET6</td>
<td>IPV6用的地址族</td>
</tr>
<tr>
<td>AF_LOCAL</td>
<td>本地通信中采用的 Unix 协议的地址族</td>
</tr>
</tbody></table>
<ul>
<li>sin_port<br>保存16位端口号，注意这里使用网络序保存</li>
<li>sin_addr<br>保存32位IP地址信息，注意这里使用网络序保存</li>
<li>sin_zero<br>无特殊含义，只是为结构体 sockaddr_in 结构体变量地址值将以如下方式传递给 bind 函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line">serverAddr.sin_family = AF_INET;</span><br><span class="line">serverAddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">serverAddr.sin_port = htons(atoi(<span class="string">&quot;8000&quot;</span>));</span><br><span class="line"></span><br><span class="line">bind(serverSocket, (<span class="keyword">struct</span> sockaddr *) &amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr));</span><br></pre></td></tr></table></figure>
<p>这里sockaddr结构体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family; <span class="comment">//地址族</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];       <span class="comment">//地址信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">此结构体 sa_data 保存的地址信息中需要包含IP地址和端口号，剩余部分应该填充0，</span><br><span class="line">但是这样对于包含地址的信息非常麻烦，所以出现了 sockaddr_in 结构体，然后强制转换成 sockaddr 类型，</span><br><span class="line">则生成符合 bind 条件的参数。</span><br></pre></td></tr></table></figure>

<p>上文中我们提到了网络序，这里我们介绍一下大端存储和小端存储。<br>对于不同的CPU对4字节整数的存储是不同的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 小端存储</span><br><span class="line">00000000 00000000 00000000 00000001</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 大端存储</span><br><span class="line">00000001 00000000 00000000 00000000</span><br></pre></td></tr></table></figure>
<ul>
<li>大端序：高位字节存放到低位地址</li>
<li>小端序：高位字节存放到高位地址</li>
</ul>
<p>因此在通过网络传输数据时必须约定统一的方式，这种约定被称为网络字节序，统一成大端序。即先把数据数组转化成大端序格式再进行网络传输。</p>
<p>c语言中提供了转换字节序的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">htons</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span>)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span>)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">htonl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>这个很好记忆：</p>
<ul>
<li>h：host</li>
<li>n：net</li>
<li>l：long</li>
<li>s：short</li>
</ul>
<p>如<code>htons</code>是把一个short类型的数据从主机序转换成网络序。</p>
<p>这里列举两个127.0.0.1形式的string转4字节的整数类型数据的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="built_in">string</span>)</span>;</span><br><span class="line"><span class="comment">//成功时返回 32 位大端序整数型值，失败时返回 INADDR_NONE</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="built_in">string</span>, <span class="keyword">struct</span> in_addr *addr)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 1 ，失败时返回 0</span></span><br><span class="line"><span class="comment">string: 含有需要转换的IP地址信息的字符串地址值</span></span><br><span class="line"><span class="comment">addr: 保存转换结果的 in_addr 结构体变量的地址值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>还有一个函数与上面两个函数的功能正好相反：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr adr)</span>;</span><br><span class="line"><span class="comment">//成功时返回保存转换结果的字符串地址值，失败时返回 NULL 空指针</span></span><br></pre></td></tr></table></figure>
<p>该函数将通过参数传入的整数型IP地址转换为字符串格式并返回。但要小心，返回值为 char 指针，返回字符串地址意味着字符串已经保存在内存空间，但是该函数未向程序员要求分配内存，而是再内部申请了内存保存了字符串。也就是说调用了该函数后要立即把信息复制到其他内存空间。因为，若再次调用 inet_ntoa 函数，则有可能覆盖之前保存的字符串信息。总之，再次调用 inet_ntoa 函数前返回的字符串地址是有效的。若需要<strong>长期保存</strong>，则应该<strong>将字符串复制到其他内存空间</strong>。</p>
<p>IP 是面向消息的、不可靠的协议。每次传输数据时会帮我们选择路径，但并不一致。如果传输过程中发生错误，则选择其他路径，但是如果发生数据丢失或错误，则无法解决。换言之，IP协议无法应对数据错误。</p>
<p>上面简要介绍了IP协议相关的知识，下面我们来讨论传输层的相关知识；</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>根据数据传输方式的不同，基于网络协议的套接字一般分为 TCP 套接字和 UDP 套接字。</p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP是Transmission Control Protocol（传输控制协议）的简写，意为【对数据传输过程的控制】。<br>上面说过，IP层只关注一个数据包（数据传输基本单位）的传输过程。因此，即使传输多个数据包，每个数据包也是由IP层实际传输的，也就是说传输顺序及传输本身是不可靠的。若只利用IP层传输数据，则可能导致后传输的数据包B比先传输的数据包A提早到达。另外，传输的数据包A、B、C中可能只收到A和C，甚至收到的C可能已经损毁。</p>
<p>如果交换数据的过程中可以确认对方已经收到数据，并重传丢失的数据，那么即便IP层不保证数据传输，这类通信也是可靠的，这就是TCP的作用。<br>在介绍具体的调用程序前，我们先来讨论一下相关的概念；</p>
<h5 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h5><p>为了保证可靠传输，引入了三次握手及确认机制和停止等待协议；<br><strong>三次握手</strong><br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="tcp三次握手"><br>上图中的各个阶段服务器和客户端的状态需要注意，在TCP第二次握手这里还有<strong>FLOOD攻击</strong>，即client发送大量的syn但不回复ack，这就可能造成server端内存耗尽；<br>这个问题出现的原因是：<br>client与server第一次握手后，server端需要维护一个半连接队列，这个队列长度是有上限的，瓶颈在于内存大小，这个半连接队列的作用是维护server端与client端的连接状态，用来判断syn与ack是否来自同一个client，其中使用四元组来存储（源地址、源端口、本地地址、本地端口），通过比对来实现匹配；<br>问题的本质就是这个队列会耗尽server端的内存，那么可不可以不维护这个队列，同时还能实现syn与ack的匹配呢？<br>可以的，linux中引入了syncookie的机制，这个机制是默认开启的，在队列内存储的四元组数量达到上限的3&#x2F;4时会启用syncookie机制；<br>linux内核将这个四元组在第二次握手的时候返回给client，自己不进行存储，在第三次握手的时候client将对应的信息再发送回来，再进行比对，这样就将瓶颈从内存转移到了cpu；<br>也可以通过延缓tcb分配的方式进行解决：<br>SYN Cache技术：<br>这种技术是在收到SYN数据报文时不急于去分配TCB，而是先回应一个SYN ACK报文，并在一个专用HASH表（Cache）中保存这种半开连接信息，直到收到正确的回应ACK报文再分配TCB。在FreeBSD系统中这种Cache每个半开连接只需使用160字节，远小于TCB所需的736个字节。在发送的SYN ACK中需要使用一个己方的Sequence Number，这个数字不能被对方猜到，否则对于某些稍微智能一点的SYNFlood攻击软件来说，它们在发送SYN报文后会发送一个ACK报文，如果己方的Sequence Number被对方猜测到，则会被其建立起真正的连接。因此一般采用一些加密算法生成难于预测的Sequence Number。<br>SYN Cookie技术：<br>对于SYN攻击，SYN Cache虽然不分配TCB，但是为了判断后续对方发来的ACK报文中的Sequence Number的正确性，还是需要使用一些空间去保存己方生成的Sequence Number等信息，也造成了一些资源的浪费。Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS、时间等，在收到对方的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（SequenceNumber-1）相同，从而决定是否分配TCB资源。</p>
<p><strong>停止等待协议</strong><br>“停止等待协议”指送完一个分组就停止发送,等待对方的确认,只有对方确认过,才发送下一个分组。<br>这里我们介绍一下<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E7%B4%8D%E6%A0%BC%E7%AE%97%E6%B3%95">Nagle算法</a>：<br>TCP默认会开启Nagle算法，Nagle算法做了两件事：</p>
<ol>
<li>只有上一个分组得到确认，才会发送下一个分组；</li>
<li>收集多个“小分组”，在一个确认到来时一起发送；</li>
</ol>
<p>Nagle算法主要是为了防止数据包过多而发生网络过载，见下图：<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/Nagle%E7%AE%97%E6%B3%95.png" alt="Nagle算法"><br>但是Nagle算法并不是什么情况下都适用，网络流量未受太大影响时，不使用Nagle算法要比使用它时传输速度快。最典型的就是「传输大文数据」。将文件数据传入输出缓冲不会花太多时间，因此，不使用Nagle算法，也会在装满输出缓冲时传输数据包。这不仅不会增加数据包的数量，反而在无需等待ACK的前提下连续传输，因此可以大大提高传输速度。<br>查看Nagle算法的开启状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opt_len = <span class="keyword">sizeof</span>(opt_val);</span><br><span class="line">getsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (<span class="type">void</span> *)&amp;opt_val, &amp;opt_len);</span><br></pre></td></tr></table></figure>
<p>关闭Nagle算法：（默认开启）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> opt_val = <span class="number">1</span>;</span><br><span class="line">setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (<span class="type">void</span> *)&amp;opt_val, <span class="keyword">sizeof</span>(opt_val));</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">由于Nagle是组合多个数据包一起进行发送，这里又要考虑粘包问题，这里我们来讨论下粘包问题：</span><br><span class="line">what：</span><br><span class="line">TCP粘包是指发送方发送的若干数据到接收方时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</span><br><span class="line">why：</span><br><span class="line">- 发送方</span><br><span class="line">开启Nagle算法。</span><br><span class="line">- 接收方</span><br><span class="line">TCP接收到分组时，并不会立刻送至应用层处理，或者说，应用层并不一定会立即处理；实际上，TCP将收到的分组保存至接收缓存里，然后应用程序主动从缓存里读收到的分组。这样一来，如果TCP接收分组的速度大于应用程序读分组的速度，多个包就会被存至缓存，应用程序读时，就会读到多个首尾相接粘到一起的包。</span><br><span class="line">when：</span><br><span class="line">多个分组本毫不相干，甚至是并列的关系，我们就一定要处理粘包问题了。比如，我当时要接收的每个分组都是一个有固定格式的商品信息，如果不处理粘包问题，每个读进来的分组我只会处理最前边的那个商品，后边的就会被丢弃。这显然不是我要的结果。</span><br><span class="line">how：</span><br><span class="line">- 发送方</span><br><span class="line">关闭Nagle算法。</span><br><span class="line">- 接收方</span><br><span class="line">接收方要在应用层进行处理。</span><br><span class="line">格式化数据：每条数据有固定的格式（开始符、结束符），这种方法简单易行，但选择开始符和结束符的时候一定要注意每条数据的内部一定不能出现开始符或结束符；</span><br><span class="line">发送长度：发送每条数据的时候，将数据的长度一并发送，比如可以选择每条数据的前4位是数据的长度，应用层处理时可以根据长度来判断每条数据的开始和结束；</span><br></pre></td></tr></table></figure>
<p><strong>连续ARQ协议与滑动窗口机制</strong><br>虽然停止等待协议可以保证可靠连接，但是缺造成了网络带宽浪费；<br>为了解决带宽浪费，引入连续ARQ协议和滑动窗口机制，即client和server各维护接受窗口和发送窗口，两个窗口的大小动态调整；（滑动窗口协议可以保证数据包的按序接收、流量控制、防止部分带宽浪费）这里窗口的大小又涉及到拥塞控制，窗口太大可能将网络带宽占满，产生丢包，太小又会出现网络带宽浪费，所以这里引入拥塞避免算法，传统的算法有：reno和cubic；<br>reno和cubic其原理类似，都是慢开始拥塞避免和快重传快回复；<br>这两种算法最常用，但是由于其是在试探网络带宽，一旦出现了拥塞避免，窗口急剧减小，可能需要很长时间才能恢复；（若带宽很大，但是延时时间很长，如两地的物理距离很长，这时窗口的尺寸增加就会很慢，带宽一直利用不充分）<br>为了解决这种情况Google提出了bbr拥塞避免算法，bbr算法不再是试探窗口大小，而是采用带宽延时积去动态计算窗口大小，而带宽的计算可以通过发送的数据包大小除以发送时间来计算，延时可以通过发送与回包的时间差计算；<br>（这里我理解滑动窗口及相对应的拥塞避免其实就是希望在充分利用网络带宽和不丢包两个问题中找到最优解，及在等待上一次发包的回包的时间内，充分利用这段时间，发送尽可能多的数据包）<br>这里可能还会出现网络带宽很大，同时延时也很大，但是网络中没有丢包，这里如何设置server端的发送窗口，使延时满足性能要求呢？<br>这里可以通过计算这个带宽延时积（延时一般是一个RTT），我理解和上面的问题一样，就是充分利用带宽；<br>将server端的发送窗口设置成带宽延时积大小，同时发送端的发送速率还收到接收端的接收窗口大小制约，这时需要把发送端的接收窗口大小设置成2倍的带宽延时积，理论上可以解决上述问题；</p>
<p><strong>实现</strong><br>回到正题，TCP的三次握手到底发生了什么，其中又有哪些细节与问题点呢？<br>首先server端想要监听一个端口，并建立与client的连接，需要以下步骤：<br>（1）创建socket<br>（2）socket bind一个端口<br>（3）listen<br>（4）accept<br>介绍下上面几个函数的签名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"><span class="comment">//成功时返回文件描述符，失败时返回-1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *myaddr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="comment">//成功时返回0，失败时返回-1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="comment">//成功时返回0，失败时返回-1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd,<span class="keyword">struct</span> sockaddr *addr,<span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="comment">//成功时返回文件描述符，失败时返回-1</span></span><br></pre></td></tr></table></figure>
<p>accept会阻塞住，直到accept成功；<br>对于客户端，与服务端相比，区别就在于「请求连接」，它是创建客户端套接字后向服务端发起的连接请求。服务端调用listen函数后创建连接请求等待队列，之后客户端即可请求连接。<br>这个等待队列会引入listen backlog问题。<br>listen backlog问题：<br>server端的accpet过程是先接受一个连接，将这个连接从listen状态转成establish状态，这个转换的过程中监听的端口类似于阻塞住，这时候若再来连接，就要进入等待队列，这个等待队列是有上限的，如果连接数超过这个上限那就无法进行连接了，一般这个上限值是不用优化的，因为一般出现这样的情况需要扩容、在client减少重试次数、减少这个等待队列长度，以防止发生雪崩；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sock, <span class="keyword">struct</span> sockaddr *servaddr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回0，失败返回-1</span></span><br><span class="line"><span class="comment">sock:客户端套接字文件描述符</span></span><br><span class="line"><span class="comment">servaddr: 保存目标服务器端地址信息的变量地址值</span></span><br><span class="line"><span class="comment">addrlen: 第二个结构体参数 servaddr 变量的字节长度</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>客户端在调用connect函数时自动分配主机的IP，随机分配端口，因此无需调用标记的bind函数进行分配。<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB.png" alt="函数调用关系"><br>附上简单的服务端、客户端程序：<br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/tcp/hello_server.c">server</a><br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/tcp/hello_client.c">client</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gcc hello_server.c -o server</span><br><span class="line">gcc hello_client.c -o client</span><br><span class="line"></span><br><span class="line">./server 8000</span><br><span class="line">./client 127.0.0.1 8000</span><br><span class="line"></span><br><span class="line">[centos ~/net_test/01]$ ./client 127.0.0.1 8000</span><br><span class="line">message is:hello world!</span><br></pre></td></tr></table></figure>
<p>上面简单实现了一次服务器和客户端的数据传输，下面我们来实现一个回声服务器。<br><strong>回声服务器</strong><br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/tcp/echo_server.c">echo_server</a><br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/tcp/echo_client.c">echo_client</a><br>上述的代码实现了一个回声服务器，并通过q&#x2F;Q退出。<br>讨论一下这里的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line">    <span class="keyword">while</span> ((strLen = read(clientSocket, message, BUF_SIZE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        write(clientSocket, message, strLen);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// client</span></span><br><span class="line">    <span class="type">int</span> writeLen = write(clientSocket, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">    <span class="type">int</span> readLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (readLen &lt; writeLen) &#123;</span><br><span class="line">        <span class="type">int</span> strLen = read(clientSocket, &amp;message[readLen], BUF_SIZE - <span class="number">1</span>);</span><br><span class="line">        readLen += strLen;</span><br><span class="line">    &#125;</span><br><span class="line">    message[readLen] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这里是为了解决下面的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">之前我们说过TCP不存在数据边界，因此多次调用write函数传递的字符串有可能一次性传递到服务端。</span><br><span class="line">此时客户端有可能从服务端收到多个字符串，这不是我们想要的结果。还需要考虑服务器的如下情况：字符串太长，需要分2个包发送！</span><br><span class="line">服务端希望通过调用1次 write 函数传输数据，但是如果数据太大，操作系统就有可能把数据分成多个数据包发送到客户端。</span><br><span class="line">另外，在此过程中，客户端可能在尚未收到全部数据包时就调用read函数。</span><br><span class="line"></span><br><span class="line">上面的代码服务端循环写入，客户端循环读取，当客户端的数据读取的长度和写入的长度相等时，停止读取，保证读取和写入的数据一致；</span><br></pre></td></tr></table></figure>

<p>前面说过TCP套接字的收发无边界，服务器即使调用1次write函数传输40字节的数据，客户端也有可能通过4次read函数调用每次读取10字节。但此处也有一些疑问，服务器一次性传输了40字节，而客户端竟然可以缓慢的分批接受。客户端接受10字节后，剩下的30字节在何处等候呢？下面我们来讨论下TCP的I&#x2F;O缓冲特性；<br>write函数调用后并不是立即传输数据，同时read函数调用后也不是马上接收数据，如下图所示，write函数调用瞬间，数据将移至输出缓冲；read函数调用瞬间，从输入缓冲读取数据。<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/TCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84IO%E7%BC%93%E5%86%B2.png" alt="TCP套接字的IO缓冲"></p>
<p>IO缓冲特性如下：</p>
<ul>
<li>IO缓冲在每个TCP套接字中单独存在；</li>
<li>IO缓冲在创建套接字时自动生成；</li>
<li>即使关闭套接字也会继续传递输出缓冲中遗留的数据；</li>
<li>关闭套接字将丢失输入缓冲中的数据；</li>
</ul>
<p>若输入缓冲是50字节，但是传输了100字节的数据，TCP使用前面说过的滑动窗口来应对这类问题，保证不会因为缓冲溢出而丢失数据。</p>
<p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/TCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E8%BF%87%E7%A8%8B.png" alt="TCP套接字的数据交换过程"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACK号 = SEQ号 + 传递的字节数 + 1</span><br></pre></td></tr></table></figure>
<p>ACK号的增量是传输的数据字节数。假设每次ACK号不加传输的字节数，这样虽然可以确认数据包的传输，但无法明确100个字节全都正确传递还是丢失了一部分，最后 + 1是为了告知对方下次要传递的SEQ号。</p>
<h5 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h5><p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="tcp四次挥手"><br>两台主机通过套接字建立后进入可交换数据的状态，也叫做流的状态。每个主机会有单独的输入流和输出流，如下图：<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%AD%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%B5%81.png" alt="套接字中的两个流"><br>如何优雅的实现断开连接呢？<br>看shutdown的函数签名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> howto)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 0 ，失败时返回 -1</span></span><br><span class="line"><span class="comment">sock: 需要断开套接字文件描述符</span></span><br><span class="line"><span class="comment">howto: 传递断开方式信息</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这个函数的第二个参数：</p>
<ul>
<li>SHUT_RD : 断开输入流</li>
<li>SHUT_WR : 断开输出流</li>
<li>SHUT_RDWR : 同时断开 I&#x2F;O 流</li>
</ul>
<p>若向 shutdown 的第二个参数传递SHUT_RD，则断开输入流，套接字无法接收数据。即使输入缓冲收到数据也会抹去，而且无法调用相关函数。如果向 shutdown 的第二个参数传递SHUT_WR，则中断输出流，也就无法传输数据。若如果输出缓冲中还有未传输的数据，则将传递给目标主机。最后，若传递关键字SHUT_RDWR，则同时中断 I&#x2F;O 流。这相当于分 2 次调用 shutdown ，其中一次以SHUT_RD为参数，另一次以SHUT_WR为参数。</p>
<p>我们之前使用<code>close()</code>函数关闭连接，为什么还要引入半关闭呢？<br>比如服务器向客户端发送文件，客户端在接受完文件后向服务器回复“已收到”，这时调用<code>close()</code>在关闭IO流的同时也会向对方发送EOF，但是没法收到对方的回复信息，这时调用<code>shutdown</code>函数，只关闭输出流，这样就即发送了EOF，又保留了输入流。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/close/file_server.c">file_server</a><br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/close/file_client.c">file_client</a></p>
<p>TIME_WAIT状态的讨论：<br>假设主机A向主机B传输ACK消息后立即消除套接字。但最后这条ACK消息在传递途中丢失，未能传给主机B。这时会发生什么?主机B会认为之前向己发送的FIN消息未能抵达主机A，继而试图重传。但此时主机A已是完全终止的状态，因此主机B永远无法收到从王机A最后传来的ACK消息。相反，若主机A的套接字处在Time-wait状态，则会向主机B重传最后的ACK消息， 主机B也可以正常终止。基于这些考虑，先传输FIN消息的主机应经过Time-wait过程；<br>所以主动关闭连接的一方一般会进入TIME_WAIT状态，这里我们模拟一下进入Time-wait的过程，服务端ctrl+c结束进程，相当于向客户端发送FIN，这时再次重启服务端会报错<code>bind error</code>，而ctrl+c终止客户端进程就不会，这是因为客户端的端口是随机分配的，所以不存在端口处于TIME_WAIT状态而绑定失败的情况；<br>可以通过更改SO_REUSEADDR的状态，将TIME_WAIT状态下的套接字重新分配给新的套接字。<br>下面来看个实现的例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[centos ~/net_test/03]$ ./server 8000</span><br><span class="line">connect client 0</span><br><span class="line">^C</span><br><span class="line">[centos ~/net_test/03]$ ./server 8000</span><br><span class="line">bind error </span><br></pre></td></tr></table></figure>
<p>解决方案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置端口复用,避开TIME_WAIT状态</span></span><br><span class="line"><span class="type">int</span> option;</span><br><span class="line"><span class="type">socklen_t</span> optLen = <span class="keyword">sizeof</span>(option);</span><br><span class="line">option = <span class="number">1</span>;<span class="comment">//true</span></span><br><span class="line">setsockopt(serverSocket,SOL_SOCKET,SO_REUSEADDR,(<span class="type">void</span>*)&amp;option,optLen);</span><br></pre></td></tr></table></figure>
<p>完整代码：<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/tcp/reuseaddr_echo_server.c">reuseaddr_echo_server</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 查看端口占用的进程</span><br><span class="line">lsof -i:[port]</span><br><span class="line">// 查出pid</span><br><span class="line">kill -9 [pid]</span><br></pre></td></tr></table></figure>

<h5 id="服务端进阶编程"><a href="#服务端进阶编程" class="headerlink" title="服务端进阶编程"></a>服务端进阶编程</h5><p>根据前面介绍的操作系统知识和网络编程知识我们来优化服务器。</p>
<h6 id="多进程并发服务器"><a href="#多进程并发服务器" class="headerlink" title="多进程并发服务器"></a>多进程并发服务器</h6><p>服务端父进程受理连接请求，子进程执行具体的业务逻辑，这样的好处是可以同时为多个客户端提供服务。<br>客户端将读写分离，父进程负责写入数据，子进程负责读取数据，这样的好处是分割后，不同进程分别负责输入输出，这样，无论客户端是否从服务器端接收完数据都可以进程传输，同时可以提高频繁交换数据的程序性能。</p>
<ul>
<li>服务端程序：<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/tcp/echo_mpserver.c">echo_mpserver</a></li>
<li>客户端程序：<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/tcp/echo_mpclient.c">echo_mpclient</a></li>
</ul>
<p>这里有要注意的点是，服务端在进入子进程时要<code>close</code>监听连接的socket（serverSocket），因为serverSocket是父进程创建的套接字，子进程不需要监听该套接字，若子进程不关闭serverSocket，子进程就会继续监听serverSocket，导致多个进程同时监听一个serverSocket，引发竞争条件。同时关闭serverSocket也可以释放系统资源，子进程关闭serverSocket并不会影响父进程的监听，因为子进程关闭serverSocket只是减少了对该文件描述符的引用，但是父进程对其还有引用，当引用是0时，操作系统才会回收资源。</p>
<h6 id="多线程并发服务器"><a href="#多线程并发服务器" class="headerlink" title="多线程并发服务器"></a>多线程并发服务器</h6><p>多个客户端之间可以交换信息的简单聊天程序：<br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/chat_server.c">chat_server</a><br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/chat_client.c">chat_client</a><br>服务端的代码中访问全局变量<code>clientCnt</code>和<code>clientSockets</code>的代码是<code>临界区</code>，如：</p>
<ul>
<li>线程 A 从数组 clnt_socks 中删除套接字信息，同时线程 B 读取 clnt_cnt 变量</li>
<li>线程 A 读取变量 clnt_cnt ，同时线程 B 将套接字信息添加到 clnt_socks 数组</li>
</ul>
<p>因此，在对临界区的代码加锁。</p>
<h6 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h6><p><strong>IO函数</strong></p>
<p><strong>1. send&amp;recv</strong><br>先来看几个IO函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回发送的字节数，失败时返回 -1</span></span><br><span class="line"><span class="comment">sockfd: 表示与数据传输对象的连接的套接字和文件描述符</span></span><br><span class="line"><span class="comment">buf: 保存待传输数据的缓冲地址值</span></span><br><span class="line"><span class="comment">nbytes: 待传输字节数</span></span><br><span class="line"><span class="comment">flags: 传输数据时指定的可选项信息</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回接收的字节数（收到 EOF 返回 0），失败时返回 -1</span></span><br><span class="line"><span class="comment">sockfd: 表示数据接受对象的连接的套接字文件描述符</span></span><br><span class="line"><span class="comment">buf: 保存接受数据的缓冲地址值</span></span><br><span class="line"><span class="comment">nbytes: 可接收的最大字节数</span></span><br><span class="line"><span class="comment">flags: 接收数据时指定的可选项参数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上面两个函数的最后一个参数是收发数据的可选项，该选项可以用位或运算符(|)同时传递多个信息，选项如下：</p>
<table>
<thead>
<tr>
<th>可选项（Option）</th>
<th>含义</th>
<th>send</th>
<th>recv</th>
</tr>
</thead>
<tbody><tr>
<td>MSG_OOB</td>
<td>用于传输带外数据（Out-of-band data）</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>MSG_PEEK</td>
<td>验证输入缓冲中是否存在接受的数据</td>
<td>X</td>
<td>O</td>
</tr>
<tr>
<td>MSG_DONTROUTE</td>
<td>数据传输过程中不参照本地路由（Routing）表，在本地（Local）网络中寻找目的地</td>
<td>O</td>
<td>X</td>
</tr>
<tr>
<td>MSG_DONTWAIT</td>
<td>调用 I&#x2F;O 函数时不阻塞，用于使用非阻塞（Non-blocking）I&#x2F;O</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>MSG_WAITALL</td>
<td>防止函数返回，直到接收到全部请求的字节数</td>
<td>X</td>
<td>O</td>
</tr>
</tbody></table>
<p><strong>2. 收发紧急消息(MSG_OOB)</strong><br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/oob/oob_send.c">oob_send</a><br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/oob/oob_receive.c">oob_receive</a><br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/oob_result.png" alt="oob_result"><br>可以看到连续执行几次的结果不同，而且并没有完整读出我们传输的紧急消息，通过MSG_OOB并不会加快传输速度，而通过信号处理函数urg_handler也只能读取一个字节。剩余数据只能通过未设置MSG_OOB可选项的普通输入函数读取。<br>MSG_OOB的真正意义在于督促接收者处理消息，TCP保持传输数据特性依然成立，TCP的紧急消息无法保证及时到达，但可以要求及时被处理。<br>详细过程见下图：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send(sock, <span class="string">&quot;890&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;890&quot;</span>), MSG_OOB);</span><br></pre></td></tr></table></figure>
<p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/%E7%B4%A7%E6%80%A5%E6%B6%88%E6%81%AF%E4%BC%A0%E8%BE%93%E9%98%B6%E6%AE%B5%E7%9A%84%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2.png" alt="紧急消息传输阶段的输出缓冲"><br>向主机传输的信息是：紧急指针指向的偏移量为3之前的部分就是紧急消息。<br>也就是说，实际只用了一个字节表示紧急消息，通过下图TCP数据包的结构看的更加清楚：<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/%E8%AE%BE%E7%BD%AEURG%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85.png" alt="设置URG的数据包"><br>这个数据包的TCP头部包含以下信息：</p>
<ul>
<li>URG&#x3D;1:载有紧急消息的数据包；</li>
<li>URG指针：紧急指针位于偏移量是3的位置；</li>
</ul>
<p>指定MSG_OOB选项的数据包本身就是紧急数据包，并通过紧急指针表示紧急消息所在的位置。</p>
<p>注意上面程序中的<code>fcntl</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fcntl(recv_sock, F_SETOWN, getpid());</span><br></pre></td></tr></table></figure>


<p><strong>3. 检查输入缓冲（MSG_PEEK）</strong><br>同时设置 MSG_PEEK 选项和 MSG_DONTWAIT 选项，以验证输入缓冲是否存在接收的数据。设置 MSG_PEEK 选项并调用 recv 函数时，即使读取了输入缓冲的数据也不会删除。因此，该选项通常与 MSG_DONTWAIT 合作，用于以非阻塞方式验证待读数据是否存在<br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/oob/peek_receive.c">peek_receive</a><br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/oob/peek_send.c">peek_send</a></p>
<p><strong>4. writev&amp;readv</strong><br>通过writev函数可以将分散保存在多个缓冲中的数据一并发送，通过readv函数可以由多个缓冲分别接收。因此，使用这2个函数可以减少I&#x2F;O函数的调用次数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> filedes, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回发送的字节数，失败时返回 -1</span></span><br><span class="line"><span class="comment">filedes: 表示数据传输对象的套接字文件描述符。但该函数并不仅限于套接字，因此，可以像 read 一样向向其传递文件或标准输出描述符.</span></span><br><span class="line"><span class="comment">iov: iovec 结构体数组的地址值，结构体 iovec 中包含待发送数据的位置和大小信息</span></span><br><span class="line"><span class="comment">iovcnt: 向第二个参数传递数组长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> *iov_base; <span class="comment">//缓冲地址</span></span><br><span class="line">    <span class="type">size_t</span> iov_len; <span class="comment">//缓冲大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> filedes, <span class="type">const</span> <span class="keyword">struct</span> iovc *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回接收的字节数，失败时返回 -1</span></span><br><span class="line"><span class="comment">filedes: 表示数据传输对象的套接字文件描述符。但该函数并不仅限于套接字，因此，可以像 write 一样向向其传递文件或标准输出描述符.</span></span><br><span class="line"><span class="comment">iov: iovec 结构体数组的地址值，结构体 iovec 中包含待数据保存的位置和大小信息</span></span><br><span class="line"><span class="comment">iovcnt: 第二个参数中数组的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>完整代码：<br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/oob/readv.c">readv</a><br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/oob/writev.c">writev</a></p>
<p>执行结果:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[centos ~/net_test/13/tt]$ ./wv</span><br><span class="line">abc123</span><br><span class="line">write bytes :6</span><br></pre></td></tr></table></figure>

<p><strong>5. 标准IO函数与系统函数</strong><br>除了使用系统的read、write函数收发数据，还可以使用标准的IO函数；<br>标准IO函数优点：</p>
<ul>
<li>具有良好的系统移植性；(这些函数都是按照ANSIC标准定义的，不局限于网络编程，适用于所有编程领域)</li>
<li>可以利用缓冲提高性能；</li>
</ul>
<p>标准IO函数缺点：</p>
<ul>
<li>不容易进行双向通信；</li>
<li>有时可能频繁调用fflush函数；（刷新缓冲区）</li>
<li>需要以FILE结构体指针的形式返回文件描述符；</li>
</ul>
<p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/%E7%BC%93%E5%86%B2%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="缓冲的关系"></p>
<p>标准IO函数与系统函数的对比：<br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/stdIO/stdcpy.c">stdcpy</a><br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/stdIO/syscpy.c">syscpy</a><br>代码中复制news.txt文件来对标准IO函数和系统函数进行对比，随着文件的增加，性能差距也就越明显。</p>
<p>由于标准IO函数需要使用FILE类型的结构体指针，下面介绍一下文件描述符与FILE结构体指针的相互转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">fdopen</span><span class="params">(<span class="type">int</span> fildes, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回转换的 FILE 结构体指针，失败时返回 NULL</span></span><br><span class="line"><span class="comment">fildes ： 需要转换的文件描述符</span></span><br><span class="line"><span class="comment">mode ： 将要创建的 FILE 结构体指针的模式信息</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fileno</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回文件描述符，失败时返回 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>使用标准IO函数改造回声服务器：<br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/stdIO/echo_std_server.c">echo_std_server</a><br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/stdIO/echo_std_client.c">echo_std_client</a><br>上面的代码中有两处细节值得讨论一下，在服务端中的代码中写入时调用了<code>fflush</code>函数，这是因为标准IO函数内部使用了缓冲来提高性能，需要调用<code>fflush</code>函数保证数据立即写入；其次，在客户端中的代码中，之前的代码需要在接收数据的char数组末尾添加“0”来转换成字符串，而使用标准IO函数却不需要这一步骤，这是因为标准IO函数可以使用字符串作单位交换数据。</p>
<p>上面的<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/stdIO/stdcpy.c">stdcpy</a>、<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/stdIO/stdcpy.c">stdcpy</a>我们分离了IO，有如下好处：</p>
<ul>
<li>将 FILE 指针按读模式和写模式加以区分；</li>
<li>可以通过区分读写模式降低实现难度；</li>
<li>通过区分 I&#x2F;O 缓冲提高缓冲性能；</li>
</ul>
<p>之前的代码<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/tcp/echo_mpserver.c">echo_mpserver</a>、<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/tcp/echo_mpclient.c">echo_mpclient</a>客户端中也使用了IO分离，有如下好处：</p>
<ul>
<li>通过分开输入过程（代码）和输出过程降低实现难度</li>
<li>与输入无关的输出操作可以提高速度</li>
</ul>
<p>我们之前讨论过半关闭<code>shutdown</code>，只关闭输出流，即发送了EOF，又保留了输入流。对于适配标准IO函数的<code>FILE</code>结构体指针该怎么实现呢？看下面的程序：<br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/stdIO/sep_client.c">sep_client</a><br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/stdIO/sep_server.c">sep_server</a><br>server:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FILE *readFd = fdopen(clientSocket, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">FILE *writeFd = fdopen(clientSocket, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;hello world\n&quot;</span>, writeFd);</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;my name is bank\n&quot;</span>, writeFd);</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;nice to meet you\n&quot;</span>, writeFd);</span><br><span class="line">fflush(writeFd);</span><br><span class="line">fclose(writeFd);</span><br><span class="line">fgets(message, BUF_SIZE, readFd);</span><br><span class="line"><span class="built_in">fputs</span>(message, <span class="built_in">stdout</span>);</span><br><span class="line">fclose(readFd);</span><br></pre></td></tr></table></figure>
<p>client:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FILE *readFd = fdopen(clientSocket, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">FILE *writeFd = fdopen(clientSocket, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fgets(message, <span class="keyword">sizeof</span>(message), readFd) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stdout</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;thank you&quot;</span>, writeFd);</span><br><span class="line">fflush(writeFd);</span><br><span class="line"></span><br><span class="line">fclose(readFd);</span><br></pre></td></tr></table></figure>
<p>按照理解加入了半关闭的代码，使用<code>fclose</code>，分别关闭用于写入、读取的<code>FILE</code>结构体指针，来测试一下，观察服务端是否可以收到客户端的回复，执行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[centos ~/net_test/15]$ ./sep_server 8000</span><br><span class="line">connect client</span><br><span class="line"></span><br><span class="line">[centos ~/net_test/15]$ ./sep_client 1 8000</span><br><span class="line">connected...</span><br><span class="line">hello world</span><br><span class="line">my name is bank</span><br><span class="line">nice to meet you</span><br></pre></td></tr></table></figure>
<p>可以看到，服务端并没有收到客户端的回复，我们目前的半关闭写法是有问题的，看下图：<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/FILE%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="FILE指针的关系"><br>两个指针都是基于同一文件描述符创建的。因此，针对于任何一个 FILE 指针调用 fclose 函数都会关闭文件描述符。<br>因此我们可以复制一个文件描述符，只需要创建 FILE 指针前先复制文件描述符即可。复制后另外创建一个文件描述符，然后利用各自的文件描述符生成读模式的 FILE 指针和写模式的 FILE 指针。这就为半关闭创造好了环境，因为销毁所有文件描述符候才能销毁套接字，如下图：<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/FILE%E5%8D%8A%E5%85%B3%E9%97%AD%E6%A8%A1%E5%9E%8B.png" alt="FILE半关闭模型"><br>服务端完整实现：<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/stdIO/sep_server2.c">sep_server2</a><br>执行结果:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[centos ~/net_test/15]$ ./sep_server2 8000</span><br><span class="line">connect client</span><br><span class="line">thank you</span><br><span class="line"></span><br><span class="line">[centos ~/net_test/15]$ ./sep_client 1 8000</span><br><span class="line">connected...</span><br><span class="line">hello world</span><br><span class="line">my name is bank</span><br><span class="line">nice to meet you</span><br></pre></td></tr></table></figure>

<p><strong>IO多路复用</strong><br>并发服务器在有连接到来的时候就会创建一个新的进程，进程的创建、销毁、通信对于系统的开销很大，使用IO多路复用技术可以解决这个问题。<br><strong>1. select</strong><br>这部分内容比较多，先来简单介绍一下select：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> maxfd, fd_set *readset, fd_set *writeset,</span></span><br><span class="line"><span class="params">           fd_set *exceptset, <span class="type">const</span> <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回大于 0 的值，失败时返回 -1</span></span><br><span class="line"><span class="comment">maxfd: 监视对象文件描述符数量</span></span><br><span class="line"><span class="comment">readset: 将所有关注「是否存在待读取数据」的文件描述符注册到 fd_set 型变量，并传递其地址值。</span></span><br><span class="line"><span class="comment">writeset: 将所有关注「是否可传输无阻塞数据」的文件描述符注册到 fd_set 型变量，并传递其地址值。</span></span><br><span class="line"><span class="comment">exceptset: 将所有关注「是否发生异常」的文件描述符注册到 fd_set 型变量，并传递其地址值。</span></span><br><span class="line"><span class="comment">timeout: 调用 select 函数后，为防止陷入无限阻塞的状态，传递超时(time-out)信息</span></span><br><span class="line"><span class="comment">返回值: 发生错误时返回 -1,超时时返回0,。因发生关注的时间返回时，返回大于0的值，该值是发生事件的文件描述符数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> tv_sec;</span><br><span class="line">    <span class="type">long</span> tv_usec;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用过程如下：<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/select%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png" alt="select函数调用过程"></p>
<ol>
<li>设置文件描述符<br>利用select可同时监听多个文件描述符，可按照接收、传输、异常进行区分。</li>
</ol>
<ul>
<li><code>FD_ZERO(fd_set *fdset)</code>：将 fd_set 变量所指的位全部初始化成0</li>
<li><code>FD_SET(int fd,fd_set *fdset)</code>：在参数 fdset 指向的变量中注册文件描述符 fd 的信息</li>
<li><code>FD_CLR(int fd,fd_set *fdset)</code>：从参数 fdset 指向的变量中清除文件描述符 fd 的信息</li>
<li><code>FD_ISSET(int fd,fd_set *fdset)</code>：若参数 fdset 指向的变量中包含文件描述符 fd 的信息，则返回「真」</li>
</ul>
<ol start="2">
<li>设置监听范围及超时<br><code>文件描述符的监视范围</code>和 select 的第一个参数有关。实际上，select 函数要求通过第一个参数传递监视对象文件描述符的数量。因此，需要得到注册在 fd_set 变量中的文件描述符数。但每次新建文件描述符时，其值就会增加 1 ，故只需将最大的文件描述符值加 1 再传递给 select 函数即可。加 1 是因为文件描述符的值是从 0 开始的。<br><code>超时</code>：本来 select 函数只有在监视文件描述符发生变化时才返回。如果未发生变化，就会进入阻塞状态。指定超时时间就是为了防止这种情况的发生。通过<code>timeval</code>结构体变量，将秒数填入 tv_sec 的成员，将微妙数填入 tv_usec 的成员，然后将结构体的地址值传递到 select 函数的最后一个参数。此时，即使文件描述符未发生变化，只要过了指定时间，也可以从函数中返回。不过这种情况下， select 函数返回 0 。因此，可以通过返回值了解原因。如果不想设置超时，则传递 NULL 参数。</li>
<li>调用select函数查看结果<br>select函数返回正整数时，向select函数的第二到第四个参数传递的fd_set变量中将发生变化，如下图：<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/fd_set%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%98%E5%8C%96.png" alt="fd_set变量的变化"></li>
</ol>
<p>select函数的例子如下：<br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/select/select.c">select</a><br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/select/echo_select_server.c">echo_select_server</a></p>
<p><strong>2. epoll</strong><br>基于 select 的 I&#x2F;O 复用技术服务端，其中有不合理的设计如下：</p>
<ul>
<li>调用 select 函数后常见的针对所有文件描述符的循环语句</li>
<li>每次调用 select 函数时都需要向该函数传递监视对象信息</li>
</ul>
<p>可以看<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/select/echo_select_server.c">echo_select_server</a>的代码，调用 select 函数后，并不是把发生变化的文件描述符单独集中在一起，而是通过作为监视对象的 fd_set 变量的变化，找出发生变化的文件描述符（54、55行）。同时，作为监视对象的 fd_set 会发生变化，所以调用 select 函数前应该复制并保存原有信息，并在每次调用 select 函数时传递新的监视对象信息（45行）。<br>select 性能上最大的弱点是：每次传递监视对象信息，准确的说，select 是监视套接字变化的函数。而套接字是操作系统管理的，所以 select 函数要借助操作系统才能完成功能。<br>为了解决上面的问题，来讨论下epoll，相比之下，epoll的优点如下：</p>
<ul>
<li>无需编写以监视状态变化为目的的针对所有文件描述符的循环语句</li>
<li>调用对应于 select 函数的 epoll_wait 函数时无需每次传递监视对象信息</li>
</ul>
<p><code>声明</code>select函数中为了保存监视对象的文件描述符，直接声明了fd_set变量，但epoll方式下的操作系统负责保存监视对象文件描述符，因此需要向操作系统请求创建保存文件描述符的空间，此时用的函数就是epoll_create。<br><code>添加&amp;删除</code>select函数使用FD_SET、FD_CLR函数来添加、删除文件描述符，而epoll使用epoll_ctr来请求操作系统完成。<br><code>监听</code>select方式中通过fd_set变量查看监视对象的状态变化，而epoll方式通过如下结构体epoll_event将发生变化的文件描述符单独集中在一起。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">__uint32_t</span> events;</span><br><span class="line">    <span class="type">epoll_data_t</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">__uint32_t</span> u32;</span><br><span class="line">    <span class="type">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>
<p>来看下epoll的相关函数签名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 epoll 的文件描述符，失败时返回 -1</span></span><br><span class="line"><span class="comment">size：epoll 实例的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>通过参数size传递的值决定epoll例程的大小，但该值只是向操作系统提出的建议。size并不用来决定epoll的大小，而仅供操作系统参考.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 0 ，失败时返回 -1</span></span><br><span class="line"><span class="comment">epfd：用于注册监视对象的 epoll 例程的文件描述符</span></span><br><span class="line"><span class="comment">op：用于指定监视对象的添加、删除或更改等操作</span></span><br><span class="line"><span class="comment">fd：需要注册的监视对象文件描述符</span></span><br><span class="line"><span class="comment">event：监视对象的事件类型</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>第二个参数的含义：</p>
<ul>
<li>EPOLL_CTL_ADD：将文件描述符注册到epoll例程</li>
<li>EPOLL_CTL_DEL：从epoll例程中删除文件描述符</li>
<li>EPOLL_CTL_MOD：更改注册的文件描述符的关注事件发生情况</li>
</ul>
<p>在看下最后一个参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">...</span><br><span class="line">event.events=EPOLLIN;<span class="comment">//发生需要读取数据的情况时</span></span><br><span class="line">event.data.fd=sockfd;</span><br><span class="line">epoll_ctl(epfd,EPOLL_CTL_ADD,sockfd,&amp;event);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>EPOLLIN：需要读取数据的情况</li>
<li>EPOLLOUT：输出缓冲为空，可以立即发送数据的情况</li>
<li>EPOLLPRI：收到 OOB 数据的情况</li>
<li>EPOLLRDHUP：断开连接或半关闭的情况，这在边缘触发方式下非常有用</li>
<li>EPOLLERR：发生错误的情况</li>
<li>EPOLLET：以边缘触发的方式得到事件通知</li>
<li>EPOLLONESHOT：发生一次事件后，相应文件描述符不再收到事件通知。因此需要向epoll_ctl函数的第二个参数传递EPOLL_CTL_MOD，再次设置事件。</li>
</ul>
<p>可以通过位或运算同时传递多个上述参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回发生事件的文件描述符个数，失败时返回 -1</span></span><br><span class="line"><span class="comment">epfd : 表示事件发生监视范围的 epoll 例程的文件描述符</span></span><br><span class="line"><span class="comment">events : 保存发生事件的文件描述符集合的结构体地址值</span></span><br><span class="line"><span class="comment">maxevents : 第二个参数中可以保存的最大事件数</span></span><br><span class="line"><span class="comment">timeout : 以 1/1000 秒为单位的等待时间，传递 -1 时，一直等待直到发生事件</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>调用方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> event_cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">ep_events</span>;</span></span><br><span class="line">...</span><br><span class="line">ep_events=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event)*EPOLL_SIZE);<span class="comment">//EPOLL_SIZE是宏常量</span></span><br><span class="line">...</span><br><span class="line">event_cnt=epoll_wait(epfd,ep_events,EPOLL_SIZE,<span class="number">-1</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>注意，第二个参数所指缓冲需要动态分配。<br>调用函数后，返回发生事件的文件描述符个数，同时在第二个参数指向的缓冲中保存发生事件的文件描述符集合。因此，无需像select一样插入针对所有文件描述符的循环。</p>
<p>下面我们来实现一个基于epoll的回声服务器：<br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/epoll/epoll_server.c">epoll_server</a></p>
<p>边缘触发&amp;水平触发<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F.png" alt="触发方式"><br>epoll默认采用的是水平触发，只要缓冲区有数据就会一直提示有事件发生，见如下代码：<br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/epoll/epoll_eplt_server.c">epoll_eplt_server</a><br>代码中把接收数据的数字大小设成4，防止一次将缓冲区中的数据全部读出。<br>执行结果：<br>server:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[centos ~/net_test/16/new]$ ./epoll_eplt_serve 8000</span><br><span class="line">epoll_wait notify</span><br><span class="line">connect client 5</span><br><span class="line">epoll_wait notify</span><br><span class="line">epoll_wait notify</span><br><span class="line">epoll_wait notify</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>client:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[centos ~/net_test/16/new]$ ./client 127.0.0.1 8000</span><br><span class="line">Connected...........</span><br><span class="line">Input message(Q to quit): hello world</span><br><span class="line">Message from server: hello world</span><br><span class="line">Input message(Q to quit): </span><br></pre></td></tr></table></figure>
<p>可以看到，epoll有多次的事件通知。</p>
<p>接下来将事件的触发方式改成边缘触发，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.events = EPOLLIN|EPOLLET;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/epoll/epoll_epet_test_server.c">epoll_epet_test_server</a><br>测试结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[centos ~/net_test/16/new]$ ./client 127.0.0.1 8001</span><br><span class="line">Connected...........</span><br><span class="line">Input message(Q to quit): hello world</span><br><span class="line">Message from server: hellInput message(Q to quit): how are you</span><br><span class="line">Message from server: o woInput message(Q to quit): </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[centos ~/net_test/16/new]$ ./epoll_epet_test_server</span><br><span class="line">epoll_wait notify</span><br><span class="line">connect client 5</span><br><span class="line">epoll_wait notify</span><br><span class="line">epoll_wait notify</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到每次的数据读取只注册了一次事件。<br>下面来实现一个边缘触发的服务器模型，边缘触发条件下，以阻塞方式工作的read&amp;write函数有可能引起服务端的长时间停顿。因此，边缘触发方式中一定要采用非阻塞read&amp;write 函数。代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fields, <span class="type">int</span> cmd, ...)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 cmd 参数相关值，失败时返回 -1</span></span><br><span class="line"><span class="comment">filedes : 属性更改目标的文件描述符</span></span><br><span class="line"><span class="comment">cmd : 表示函数调用目的</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flag = fcntl(fd,F_GETFL,<span class="number">0</span>);</span><br><span class="line">fcntl(fd, F_SETFL, flag | O_NONBLOCK);</span><br></pre></td></tr></table></figure>
<p>通过第一条语句，获取之前设置的属性信息，通过第二条语句在此基础上添加非阻塞<code>O_NONBLOCK</code>标志。调用read&#x2F;write函数时，无论是否存在数据，都会形成非阻塞文件（套接字）。<br>完整代码：<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/epoll/epoll_epet_server.c">epoll_epet_server</a></p>
<h5 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h5><p>待完善</p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BC%A0%E8%BE%93%E4%B8%ADUDP%E5%92%8CIP%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="数据包传输中UDP和IP的作用"><br>从图中可以看出，IP的作用就是让离开主机B的UDP数据包准确传递到主机A。但是把UDP数据包最终交给主机A的某一UDP套接字的过程是由UDP完成的。UDP的最重要的作用就是根据端口号将传到主机的数据包交付给最终的UDP套接字。<br>TCP中，套接字之间应该是一对一的关系。若要向10个客户端提供服务，除了守门的服务器套接字之外，还需要10个服务器套接字。但在UDP中，不管是服务器端还是客户端都只需要1个套接字。只需要一个UDP套接字就可以向任意主机传输数据。<br>创建好TCP套接字以后，传输数据时无需加上地址信息。因为TCP套接字将保持与对方套接字的连接。换言之，TCP套接字知道目标地址信息。但UDP套接字不会保持连接状态（UDP套接字只有简单的邮筒功能），因此每次传输数据时都需要添加目标的地址信息。这相当于寄信前在信件中填写地址。接下来是UDP的相关函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sock, <span class="type">void</span> *buff, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">               <span class="keyword">struct</span> sockaddr *to, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回发送的字节数，失败时返回 -1</span></span><br><span class="line"><span class="comment">sock: 用于传输数据的 UDP 套接字</span></span><br><span class="line"><span class="comment">buff: 保存待传输数据的缓冲地址值</span></span><br><span class="line"><span class="comment">nbytes: 待传输的数据长度，以字节为单位</span></span><br><span class="line"><span class="comment">flags: 可选项参数，若没有则传递 0</span></span><br><span class="line"><span class="comment">to: 存有目标地址的 sockaddr 结构体变量的地址值</span></span><br><span class="line"><span class="comment">addrlen: 传递给参数 to 的地址值结构体变量长度</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sock, <span class="type">void</span> *buff, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> sockaddr *from, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回接收的字节数，失败时返回 -1</span></span><br><span class="line"><span class="comment">sock: 用于传输数据的 UDP 套接字</span></span><br><span class="line"><span class="comment">buff: 保存待传输数据的缓冲地址值</span></span><br><span class="line"><span class="comment">nbytes: 待传输的数据长度，以字节为单位</span></span><br><span class="line"><span class="comment">flags: 可选项参数，若没有则传递 0</span></span><br><span class="line"><span class="comment">from: 存有发送端地址信息的 sockaddr 结构体变量的地址值</span></span><br><span class="line"><span class="comment">addrlen: 保存参数 from 的结构体变量长度的变量地址值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>看下回声服务器的UDP实现：<br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/udp/echo_udp_server.c">echo_udp_server</a><br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/udp/echo_udp_client.c">echo_udp_client</a><br>可以看到代码中并没有<code>bind</code>的过程，这是因为在调用sendto函数时自动分配IP和端口号，因此，UDP客户端中通常没有额外的地址分配过程。</p>
<p>UDP和TCP不同，是有数据边界的，因此输入函数和输出函数的调用次数必须完全一致，来看个例子：<br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/udp/bound_host_server.c">bound_host_server</a><br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/udp/bound_host_client.c">bound_host_client</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[net_test/06]$ </span><span class="language-bash">./server 8000</span></span><br><span class="line">message 1 is hello</span><br><span class="line">message 2 is world</span><br><span class="line">message 3 is look</span><br></pre></td></tr></table></figure>
<p>上面说过，调用sendto函数的时候自动分配IP和端口，通过sendto函数传输数据大概分成下面3个阶段：</p>
<ol>
<li>向UDP套接字注册目标IP和端口号；</li>
<li>传输数据；</li>
<li>删除UDP套接字中注册的目标地址；</li>
</ol>
<p>每次调用 sendto 函数时重复上述过程。每次都变更目标地址，因此可以重复利用同一 UDP 套接字向不同目标传递数据。这种未注册目标地址信息的套接字称为未连接套接字，反之，注册了目标地址的套接字称为连接 connected 套接字。显然，UDP 套接字默认属于未连接套接字。当一台主机向另一台主机传输很多信息时，上述的三个阶段中，第一个阶段和第三个阶段占整个通信过程中近三分之一的时间，缩短这部分的时间将会大大提高整体性能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line"><span class="comment">// struct sockaddr_in clientAddr;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;serverAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serverAddr));</span><br><span class="line">serverAddr.sin_family = AF_INET;</span><br><span class="line">serverAddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">serverAddr.sin_port = htons(atoi(<span class="string">&quot;8000&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// UDP也分成未连接UDP和已连接UDP;</span></span><br><span class="line"><span class="comment">// 若是未连接UDP,则在sendto函数调用的时候绑定IP和端口</span></span><br><span class="line"><span class="comment">// 这里创建已连接UDP,UDP绑定IP和端口,可以提高性能,不必每次调用sendto时都绑定、解绑</span></span><br><span class="line">connect(clientSocket, (<span class="keyword">struct</span> sockaddr *) &amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr));</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/udp/echo_udp_con_client.c">echo_udp_con_client</a></p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>选择数据传输路径、数据确认过程都被隐藏到套接字内部。向程序员提供的工具就是套接字，只需要利用套接字编出程序即可。编写软件的过程中，需要根据程序的特点来决定服务器和客户端之间的数据传输规则，这便是应用层协议。<br>UDP中的服务端和客户端不像TCP那样在连接状态下交换数据，因此与TCP不同，无需经过连接过程。也就是说，不必调用TCP连接过程中调用的listen和accept函数。UDP中只有创建套接字和数据交换的过程。</p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/dns%E7%B3%BB%E7%BB%9F.png" alt="DNS系统"><br>DNS用来通过域名来解析IP地址，DNS系统类似一个大型的分布式数据系统，一般域名确定后不会轻易改变，但是IP地址却会经常发生变化，所以在程序中使用域名，通过DNS系统来解析IP地址是比较好的方法；</p>
<ol>
<li>根域名服务器<br>因特网上有13个根域名服务器， 其中大部分分布在北美洲；</li>
<li>顶级域名服务器<br>顶级域名服务器负责顶级域名，如com，org，edu和gov和所有国家的顶级域名如cn，uk，jp；</li>
<li>权威域名服务器<br>在因特网上具有公共可访问的主机的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址，由组织机构的权威域名服务器保存这些DNS记录；</li>
<li>本地域名服务器<ul>
<li>主机和本地域名服务器一般是相邻的，当主机发出DNS请求的时候，该请求会被发往本地DNS服务器，它起着代理的作用，并将该请求转发到DNS服务器层次结构中</li>
<li>本地DNS服务器可以通过缓存主机名&#x2F;IP地址，减少对相同主机名的查询而消耗的时间，改善延时和性能。</li>
</ul>
</li>
</ol>
<p>因此，一次DNS解析的过程如下：</p>
<ul>
<li>递归查询：<ol>
<li>主机首先向其本地域名服务器进行递归查询。</li>
<li>本地域名服务器收到递归查询的委托后，也采用递归查询的方式向某个根域名服务器查询。</li>
<li>根域名服务器收到递归查询的委托后，也采用递归查询的方式向某个顶级域名服务器查询。</li>
<li>顶级域名服务器收到递归查询的委托后，也采用递归查询的方式向某个权限域名服务器查询。<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/dns%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2.png" alt="DNS递归查询"></li>
</ol>
</li>
<li>迭代查询：<ol>
<li>主机首先向其本地域名服务器进行递归查询。</li>
<li>本地域名服务器采用迭代查询，它先向某个根域名服务器查询。</li>
<li>根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器的IP地址。</li>
<li>本地域名服务器向顶级域名服务器进行迭代查询。</li>
<li>顶级域名服务器告诉本地域名服务器，下一次应查询的权限域名服务器的IP地址。</li>
<li>本地域名服务器向权限域名服务器进行迭代查询。</li>
<li>权限域名服务器告诉本地域名服务器所查询的域名的IP地址。</li>
<li>本地域名服务器最后把查询的结果告诉主机。<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/dns%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2.png" alt="DNS迭代查询"></li>
</ol>
</li>
</ul>
<p>这里介绍一个c函数，用来通过url获取IP地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> hostent* <span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *hostname)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>	*h_name;	<span class="comment">/* official name of host */</span></span><br><span class="line">	<span class="type">char</span>	**h_aliases;	<span class="comment">/* alias list */</span></span><br><span class="line">	<span class="type">int</span>	h_addrtype;	<span class="comment">/* host address type */</span></span><br><span class="line">	<span class="type">int</span>	h_length;	<span class="comment">/* length of address */</span></span><br><span class="line">	<span class="type">char</span>	**h_addr_list;	<span class="comment">/* list of addresses from name server */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也可以通过IP地址获取域相关信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> hostent* <span class="title function_">gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *hostname,<span class="type">socklen_t</span> len,<span class="type">int</span> family)</span>;</span><br></pre></td></tr></table></figure>
<p>示例程序：<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/dns/url_to_ip.c">url_to_ip.c</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc url_to_ip.c -o url_to_ip</span><br></pre></td></tr></table></figure>
<p>这里有一个经典的问题，在浏览器中输入一个url，会经历哪些过程，这里后续写一篇blog详细介绍一下；</p>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>HyperTextTransferProtocol 直译为‘超文本传输协议’</p>
<ol>
<li>超文本：指文字、图片、视频、音频等的混合体，比如最熟悉的html</li>
<li>传输：http是一个“双向协议”，传输的是请求方和响应方之间的数据，不限制请求方和响应方之间的角色，传递的过程中可以存在任意“中间人”。</li>
<li>协议：协是两个或多个参与者之间的交流，议是指对参与者之间的约定和规范。所以，http协议可以理解为作用在计算机之间，使用计算机能够理解的语言确立计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</li>
</ol>
<p>这里实现一个简单的基于HTTP协议的服务端，向客户端传回html文件：<br><a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/http/web_server.c">web_server</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc web_server.c -D_REENTRANT -o server -lpthread</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1:8000/index.html</span><br></pre></td></tr></table></figure>
<p>http请求格式:<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/http%E8%AF%B7%E6%B1%82%E6%A0%BC%E5%BC%8F.png" alt="http请求格式"><br>http响应格式:<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/http%E5%93%8D%E5%BA%94%E6%A0%BC%E5%BC%8F.png" alt="http响应格式"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对网络编程的基础部分进行了讨论，同时介绍了操作系统相关的知识，本文的每一个章节继续深挖下去都有很多的知识可以研究，这里仅仅是对基础的部分展开了讨论，后续可以结合本文的基础知识继续进行研究。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">bank</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/06/06/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/">http://example.com/2023/06/06/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">bank blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/11/linux%E5%86%85%E6%A0%B8%E7%AD%96%E7%95%A5/" title="linux内核"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">linux内核</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/25/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/" title="代码整洁之道"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">代码整洁之道</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">bank</div><div class="author-info__description">行至水穷处,坐看云起时</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83"><span class="toc-number">1.</span> <span class="toc-text">网络编程的一些思考</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">僵尸进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">信号处理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#signal"><span class="toc-number">1.1.1.3.1.</span> <span class="toc-text">signal</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sigaction"><span class="toc-number">1.1.1.3.2.</span> <span class="toc-text">sigaction</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">进程间通信</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.1.3.</span> <span class="toc-text">文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">1.1.4.</span> <span class="toc-text">套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%8F%AF%E9%80%89%E9%A1%B9"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">套接字的可选项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">四层网络模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82"><span class="toc-number">1.2.1.</span> <span class="toc-text">网络接口层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">1.2.2.</span> <span class="toc-text">网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IP%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">IP协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">1.2.3.</span> <span class="toc-text">传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">建立连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.3.1.2.</span> <span class="toc-text">断开连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9B%E9%98%B6%E7%BC%96%E7%A8%8B"><span class="toc-number">1.2.3.1.3.</span> <span class="toc-text">服务端进阶编程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.2.3.1.3.1.</span> <span class="toc-text">多进程并发服务器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.2.3.1.3.2.</span> <span class="toc-text">多线程并发服务器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">1.2.3.1.3.3.</span> <span class="toc-text">IO多路复用</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%93%E5%8C%85"><span class="toc-number">1.2.3.1.4.</span> <span class="toc-text">抓包</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">UDP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">1.2.4.</span> <span class="toc-text">应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">DNS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">HTTP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/08/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%BC%96%E5%86%99%E6%96%B9%E6%B3%95/" title="测试用例编写方法">测试用例编写方法</a><time datetime="2023-11-08T11:22:27.040Z" title="发表于 2023-11-08 19:22:27">2023-11-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/23/%E4%BD%BF%E7%94%A8golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84rpc/" title="使用golang实现简单的rpc">使用golang实现简单的rpc</a><time datetime="2023-10-23T13:46:47.443Z" title="发表于 2023-10-23 21:46:47">2023-10-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/18/%E4%BD%BF%E7%94%A8golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84orm/" title="使用golang实现简单的orm">使用golang实现简单的orm</a><time datetime="2023-09-18T14:15:39.197Z" title="发表于 2023-09-18 22:15:39">2023-09-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/18/linux%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/" title="linux命令记录">linux命令记录</a><time datetime="2023-09-18T08:18:35.307Z" title="发表于 2023-09-18 16:18:35">2023-09-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/10/%E4%BD%BF%E7%94%A8golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/" title="使用golang实现简单的分布式缓存">使用golang实现简单的分布式缓存</a><time datetime="2023-09-10T05:40:09.505Z" title="发表于 2023-09-10 13:40:09">2023-09-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By bank</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>