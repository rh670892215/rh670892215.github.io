<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>linux内核 | bank blog</title><meta name="author" content="bank"><meta name="copyright" content="bank"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="article">
<meta property="og:title" content="linux内核">
<meta property="og:url" content="http://example.com/2023/07/11/linux%E5%86%85%E6%A0%B8%E7%AD%96%E7%95%A5/index.html">
<meta property="og:site_name" content="bank blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-07-11T13:23:19.933Z">
<meta property="article:modified_time" content="2023-07-26T13:26:25.882Z">
<meta property="article:author" content="bank">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/07/11/linux%E5%86%85%E6%A0%B8%E7%AD%96%E7%95%A5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'linux内核',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-26 21:26:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="bank blog"><span class="site-name">bank blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">linux内核</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-11T13:23:19.933Z" title="发表于 2023-07-11 21:23:19">2023-07-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-26T13:26:25.882Z" title="更新于 2023-07-26 21:26:25">2023-07-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/os/">os</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>83分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="linux内核"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer"/>
<span id="more"></span>

<h1 id="linux内核"><a href="#linux内核" class="headerlink" title="linux内核"></a>linux内核</h1><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="系统指令"><a href="#系统指令" class="headerlink" title="系统指令"></a>系统指令</h3><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">top - 21:30:37 up 597 days,  6:38,  0 users,  load average: 68.76, 57.83, 57.39</span><br><span class="line">Tasks:  10 total,   1 running,   9 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s): 41.7 us,  8.3 sy,  0.1 ni, 44.8 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  5.1 si,  0.0 st</span></span><br><span class="line">KiB Mem : 19707564+total,  4198476 free, 84425392 used, 10845178+buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used. 89777152 avail Mem </span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                            </span><br><span class="line">    303 mqq       20   0 1382892 234556  19256 S  13.0  0.1   9009:54 operation_trace                                                    </span><br><span class="line">  77433 mqq       20   0 1018064  57600  27708 S   1.7  0.0  30:40.80 coa                                                                </span><br><span class="line">      1 mqq       20   0  706864   5648   2516 S   0.0  0.0   7:55.48 entry                                                              </span><br><span class="line">     14 mqq       20   0  115276   2616   2268 S   0.0  0.0   0:00.00 sh                                                                 </span><br><span class="line">     37 mqq       20   0  706196   3256   1708 S   0.0  0.0  12:41.55 beein_watchdog                                                     </span><br><span class="line">    304 mqq       20   0  107904   1812   1708 S   0.0  0.0   0:00.00 tee                                                                </span><br><span class="line">  77432 mqq       20   0   11656   2812   2536 S   0.0  0.0   0:00.00 sh                                                                 </span><br><span class="line">2106560 mqq       20   0  115412   3532   3044 S   0.0  0.0   0:00.03 bash                                                               </span><br><span class="line">2168159 mqq       20   0  157564   4280   3724 R   0.0  0.0   0:00.02 top                                                                </span><br><span class="line">2739459 mqq       20   0  115412   3404   2916 S   0.0  0.0   0:00.02 bash</span><br></pre></td></tr></table></figure>
<p>top指令可以称得上是最常用的性能调试指令了，下面对每部分的参数进行讨论。<br>统计信息区前五行是系统的整体信息。<br>第一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">21:30:37                                当前时间</span><br><span class="line">up 597 days,  6:38,                     系统已运行时间</span><br><span class="line">0 users,                                当前登陆用户数</span><br><span class="line">load average: 68.76, 57.83, 57.39       系统负载，即任务队列中R状态的进程个数。三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。三个值越来越高，说明系统负载在下降</span><br></pre></td></tr></table></figure>
<p>第二行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tasks:  10 total,   1 running,   9 sleeping,   0 stopped,   0 zombie</span><br><span class="line">total：     进程总数</span><br><span class="line">running：   正在运行的进程数</span><br><span class="line">sleeping：  休眠中的进程数</span><br><span class="line">stopped：   停止的进程数</span><br><span class="line">zombie：    僵尸进程数</span><br></pre></td></tr></table></figure>
<p>第三行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%Cpu(s): 41.7 us,  8.3 sy,  0.1 ni, 44.8 id,  0.0 wa,  0.0 hi,  5.1 si,  0.0 st</span><br><span class="line">us：用户态占用CPU百分比</span><br><span class="line">sy：内核态占用CPU百分比</span><br><span class="line">ni：nice进程（低优先级进程）占用CPU百分比</span><br><span class="line">id：空闲CPU百分比</span><br><span class="line">wa：等待IO的CPU百分比</span><br><span class="line">hi：硬中断CPU占用百分比</span><br><span class="line">si：软中断CPU占用百分比</span><br><span class="line">st：虚拟机CPU占用百分比</span><br></pre></td></tr></table></figure>
<p>第四行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KiB Mem : 19707564+total,  4198476 free, 84425392 used, 10845178+buff/cache</span><br><span class="line">Mem:</span><br><span class="line">total:      物理内存总量</span><br><span class="line">free:       空闲内存总量</span><br><span class="line">used:       使用的物理内存总量</span><br><span class="line">buff/cache: 操作系统对于文件系统的缓存</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里的buff/cache有必要讨论一下，在linux2.6之前，buf是写缓冲，而cache是读缓存，是分开存储的。在linux2.6之后，文件的读缓冲和写缓存合并到一起了，cache指的是page cache，缓存文件的实际数据，而buf指的是buffer cache，用来将page标记为不同的缓冲区，并记录是哪一个缓冲区被修改了。这样，内核在后续执行脏数据的回写（writeback）时，就不用将整个page写回，而只需要写回修改的部分即可，也就是说buffer cache记录问价的元信息，如目录项缓存、inode缓存。</span><br></pre></td></tr></table></figure>

<p>第五行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KiB Swap:        0 total,        0 free,        0 used. 89777152 avail Mem</span><br><span class="line">Swap: </span><br><span class="line">total：         交换区总量</span><br><span class="line">used：          使用的交换区总量</span><br><span class="line">free：          空闲交换区总量</span><br><span class="line">avail Mem：</span><br></pre></td></tr></table></figure>
<p>进程信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PID：                 进程的标识符。</span><br><span class="line">USER：                运行进程的用户名。</span><br><span class="line">PR（优先级）：          进程的优先级。</span><br><span class="line">NI（Nice值）：         进程的优先级调整值。</span><br><span class="line">VIRT（虚拟内存）：      进程使用的虚拟内存大小。</span><br><span class="line">RES（常驻内存）：       进程实际使用的物理内存大小。</span><br><span class="line">SHR（共享内存）：       进程共享的内存大小。</span><br><span class="line">S：                   进程状态。</span><br><span class="line">%CPU：                进程占用 CPU 的使用率。</span><br><span class="line">%MEM：                进程占用内存的使用率。</span><br><span class="line">TIME+：               进程的累计 CPU 时间。</span><br></pre></td></tr></table></figure>

<p>这里介绍一下进程的各种状态，可通过如下指令进行查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">man ps</span><br><span class="line">/STAT</span><br></pre></td></tr></table></figure>
<p><img src="/linux%E5%86%85%E6%A0%B8.resources/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="进程状态"></p>
<ul>
<li>R：执行</li>
<li>S：可中断的休眠状态</li>
<li>D：不可中断的休眠状态</li>
<li>T：暂停状态  （Ctrl+z或kill -19）</li>
<li>Z：僵尸状态zombie（僵尸进程太多可能导致pid号用尽，没法开新进程）</li>
<li>X：不可见状态</li>
</ul>
<p>D状态是一种特殊的状态，当进程在执行内存检查或回收的时候、IO时，就会置成D状态，防止被打断，丢失数据。<br>————————————————————————————————————————————</p>
<ul>
<li>L：有线程的进程</li>
<li>&lt;：高优先级</li>
<li>NI：低优先级</li>
<li>S：session的leader（有子进程的进程）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">孤儿进程：</span><br><span class="line">子进程未退出，但是父进程退出了，子进程就会变成孤儿进程，这时子进程会由1号进程接管，1号进程作为孤儿进程的父进程，这也是解决僵尸进程的一种办法，kill掉僵尸进程的父进程，使其由1号进程接管，大多数情况下1号进程可以回收这些僵尸进程。</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看可以向进程发送的信号</span></span><br><span class="line">kill -l</span><br></pre></td></tr></table></figure>
<p><img src="/linux%E5%86%85%E6%A0%B8.resources/kill.png" alt="kill"></p>
<h4 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -P [cpu编号] [每隔几s采样一次]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[/usr/local/trpc/log]$ </span><span class="language-bash">sar -P 0 1</span></span><br><span class="line">Linux 5.4.119-1-tlinux4-0007 (9-138-158-64)     07/12/2023      _x86_64_        (90 CPU)</span><br><span class="line"></span><br><span class="line">10:46:27 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle</span><br><span class="line">10:46:28 PM       0     25.25      0.00     13.13      3.03      0.00     58.59</span><br><span class="line">10:46:29 PM       0     28.72      0.00      9.57      0.00      0.00     61.70</span><br><span class="line">10:46:30 PM       0     43.43      0.00      9.09      0.00      0.00     47.47</span><br></pre></td></tr></table></figure>

<h4 id="mpstat"><a href="#mpstat" class="headerlink" title="mpstat"></a>mpstat</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpstat [-P] [每隔几s采样一次]</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[/usr/local/trpc/log]$ </span><span class="language-bash">mpstat 1</span></span><br><span class="line">Linux 5.4.119-1-tlinux4-0007 (9-138-158-64)     07/12/2023      _x86_64_        (90 CPU)</span><br><span class="line"></span><br><span class="line">10:48:37 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">10:48:38 PM  all   30.92    0.09    6.90    0.08    0.00    4.26    0.00    0.00    0.00   57.75</span><br><span class="line">10:48:39 PM  all   26.39    0.00    8.70    0.00    0.00    4.13    0.00    0.00    0.00   60.78</span><br><span class="line">10:48:40 PM  all   33.28    0.00    6.91    0.01    0.00    4.34    0.00    0.00    0.00   55.46</span><br><span class="line">10:48:41 PM  all   30.26    0.00    6.84    0.08    0.00    4.19    0.00    0.00    0.00   58.63</span><br><span class="line">10:48:42 PM  all   30.79    0.00    9.33    0.00    0.00    4.14    0.00    0.00    0.00   55.74</span><br><span class="line">10:48:43 PM  all   30.22    0.00    6.20    0.01    0.00    4.23    0.00    0.00    0.00   59.34</span><br><span class="line">10:48:44 PM  all   27.21    0.00    6.28    0.00    0.00    4.29    0.00    0.00    0.00   62.21</span><br></pre></td></tr></table></figure>

<p>irq：硬中断<br>soft：软中断</p>
<p>以网卡接收数据包为例，cpu把一次网卡数据接收分成中断的上半部和下半部，其中上半部是硬中断<code>irq</code>，只负责数据的接收，具体的协议解包等操作放在中断的下半部进行处理，其中软中断是中断下半部的一种实现方式。</p>
<h4 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h4><h4 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h4><h4 id="cat-x2F-proc-x2F-cpuinfo"><a href="#cat-x2F-proc-x2F-cpuinfo" class="headerlink" title="cat &#x2F;proc&#x2F;cpuinfo"></a>cat &#x2F;proc&#x2F;cpuinfo</h4><p>查看CPU硬件配置信息，<br>bogomips：CPU每秒钟可以跑多少百万的CPU指令(整数运算单元)，相对比较客观的对CPU运算能力的评估。</p>
<h3 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h3><p>NUMA技术</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numactl -H</span><br><span class="line"></span><br><span class="line">numastat</span><br></pre></td></tr></table></figure>

<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断：CPU的异步机制，一般由CPU外围的硬件来实现中断，如键盘、网卡，中断发送给中断控制器，中断控制器再向CPU发信号。<br>查看系统中支持哪些中断设备：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/interrupt</span><br></pre></td></tr></table></figure>
<p><img src="/linux%E5%86%85%E6%A0%B8.resources/%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87.png" alt="中断设备"><br>可以看到两张网卡分别被cpu0、cpu1响应了中断。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /proc/irq</span><br></pre></td></tr></table></figure>
<p><img src="/linux%E5%86%85%E6%A0%B8.resources/%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" alt="中断设备文件描述符"><br>根据中断设备的编号，可以看到中断设备的详细配置信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/irq/[num]/smp_affinity</span><br></pre></td></tr></table></figure>
<p>上述目录下的文件可以看到当前设备的cpu亲缘性，可以通过echo执行自定义CPU亲缘性，一般用于追求极致性能。<br><img src="/linux%E5%86%85%E6%A0%B8.resources/%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87cpu%E4%BA%B2%E7%BC%98%E6%80%A7.png" alt="中断设备cpu亲缘性"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat 1</span><br></pre></td></tr></table></figure>
<p>in：中断次数<br>cs：上下文切换次数<br><img src="/linux%E5%86%85%E6%A0%B8.resources/vmstat.png" alt="vmstat"></p>
<p>时钟信号中断频率：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /boot/config-5.4.119-1-tlinux4-0008 | grep HZ</span><br></pre></td></tr></table></figure>
<p><img src="/linux%E5%86%85%E6%A0%B8.resources/%E7%A1%AC%E4%BB%B6%E5%A7%8B%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD.png" alt="硬件始时钟中断"><br>如图可以看出，系统中当前的始终中断频率是每秒钟250次。通过调整这个值可以调整服务器更倾向于高响应速度和高吞吐量，比如上图中的系统，就被配置成了高吞吐量，时钟中断频率较低，减少上下文切换的次数。（时间片轮转，时间片较大）</p>
<h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><p><strong>O1调度器</strong><br>进程可分成如下两类：</p>
<ul>
<li>IO消耗型进程</li>
<li>CPU消耗型进程</li>
</ul>
<p>而<code>O1调度器</code>倾向于IO消耗型，cpu消耗型的时间片缩短，放大IO消耗型的时间片，可以设置NI（静态优先级）范围-20~19。如下图：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man nice</span><br></pre></td></tr></table></figure>
<p><img src="/linux%E5%86%85%E6%A0%B8.resources/nice.png" alt="nice"><br>NI（静态优先级），nice值，值越大优先级越低，可以通过<code>renice</code>对其进行调整，同时设置好NI之后内核会根据实际情况调整PR（动态优先级）<br>新版本（Linux2.几之后）优先级分成0-139，之前的-20-19对应100-139,0-99是实时进程优先级（同样值越大优先级越低），使用<code>chrt</code>可以建该进程设置成实时进程优先级；（实时进程很快），切换成实时进程不再使用O1调度算法，使用RR、FIFO<br><img src="/linux%E5%86%85%E6%A0%B8.resources/chrt.png" alt="chrt"><br>对于老版本的服务器，<code>top</code>命令中展示的<code>PR</code>值可能会动态调整，最多在<code>-5 ~ +5</code>之间浮动，如：IO消耗性进程PR值-5，CPU消耗性进程PR值+5。但是对于新版本的服务器就不会动态调整了，因为不再使用O1调度器了。</p>
<p><strong>CFS调度器</strong><br>完全公平调度保证该进程在预期时间内一定能被执行，<br><code>/proc/sys/kernel/sched_latency_ns</code>文件下存储了这个预期时间,具体的时间片是这个时间除以所有R状态的进程个数；<br>同时<code>/proc/sys/kernel/sched_min_granularity_ns</code>文件下存储了最小时间片（进程得到的最小执行时间）<br>当第一步计算的每个进程的执行时间小于第二个时间时，将第二个时间当做时间片；<br><img src="/linux%E5%86%85%E6%A0%B8.resources/cfs.png" alt="cfs"><br>单位：ns</p>
<p>底层使用红黑树，key为进程占用cpu时间，占用cpu时间少的进程会被添加到左子树，也就越先优先调度，执行之后其执行时间增加，再加回红黑树；对于IO型进程，经常会主动让出cpu等待IO，其占用cpu的时间就较短，所以其被优先调度的几率就越高，也就天然形成IO消耗型进程优先级更高，这也就导致了上面说过的内核不再动态调整进程优先级了，因为在调度算法层面解决了使IO消耗型进程优先级较高的问题。</p>
<p>每个cpu内部都有一个这样的红黑树，通过计算整个红黑树的一个标准值，将标准值赋给这个key值；（否则可能会导致一个父进程通过不断开启新的子进程来达到一直占用cpu的目的）</p>
<h3 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h3><p>首先来讨论一下cgroup，路径<code>/sys/fs/cgroup</code>下面可以设置资源隔离。<br><strong>配置进程的cpu亲缘性</strong><br>在<code>/sys/fs/cgroup/cpuset</code>路径下新建文件夹表示就是新建了一个用户组，系统会自动在文件夹中生成各种文件，通过配置文件的内容，可以对用户组进行配置。如：<br><img src="/linux%E5%86%85%E6%A0%B8.resources/cgroup.png" alt="cgroup"><br>配置<code>cpuset.cpus</code>文件表示该用户组的进程运行在哪个cpu上，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1,2&quot;</span> &gt; cpuset.cpus</span><br></pre></td></tr></table></figure>

<p><code>cpuset.mems</code>文件，指定改用户组的进程在哪个numa节点上运行，一般与<code>cpuset.cpus</code>文件搭配使用，如果<code>cpuset.mems</code>文件不配置，cpuset.cpus文件的配置不生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1,2&quot;</span> &gt; cpuset.cpus</span><br></pre></td></tr></table></figure>

<p>指定cpu运行指定进程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cgexec -g cpuset:bankren ./prime &amp;&gt; /dev/null &amp;</span><br></pre></td></tr></table></figure>
<p>代码地址：<a href=""></a><br>执行结果：<br><img src="/linux%E5%86%85%E6%A0%B8.resources/cgroup_res.png" alt="cgroup_res"><br>可以看到只有配置的1,2号的cpu存在占用。</p>
<p><strong>配置进程占用cpu的上限（配额）</strong><br><code>cat cpu.cfs_period_us</code>：cpu在1s内被分成多少份；<br><code>cat cpu.cfs_quota_us</code>：进程执行多长时间就必须要让出cpu<br>注意上面的参数是设置的单个cpu，要想实现设置进程占整个系统cpu的份额，需要<code>cpu.cfs_quota_us</code>再乘上全部的cpu数量；<br>见如下的测试，实现进程只占用50%的cpu，测试的机器有8个cpu：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /sys/fs/cgroup/cpu</span><br><span class="line"><span class="built_in">mkdir</span> bank</span><br><span class="line"><span class="built_in">echo</span> 400000 &gt; cpu.cfs_quota_us</span><br><span class="line">cgexec -g cpu:bank ./prime &amp;&gt; /dev/null &amp;</span><br></pre></td></tr></table></figure>
<p>参数<code>400000</code>的确定方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos /sys/fs/cgroup/cpu/bank]<span class="comment"># cat cpu.cfs_period_us</span></span><br><span class="line">100000</span><br><span class="line">[root@VM-236-124-centos /sys/fs/cgroup/cpu/bank]<span class="comment"># cat cpu.cfs_quota_us</span></span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<p>100000 * 0.5 * 8 &#x3D; 400000</p>
<p><img src="/linux%E5%86%85%E6%A0%B8.resources/50percent_cpu.png" alt="50percent_cpu"></p>
<p><strong>配置进程的cpu占用比例</strong><br>设置两个进程占用cpu的比率是2:1。<br>设置<code>cpu.shares</code>文件的值，默认是1024，设置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos /sys/fs/cgroup/cpu/bank]<span class="comment"># echo 2048 &gt; cpu.shares</span></span><br><span class="line">[root@VM-236-124-centos /sys/fs/cgroup/cpu/bank]<span class="comment"># cat cpu.shares</span></span><br><span class="line">2048</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cgexec -g cpu:bank ./prime &amp;&gt; /dev/null &amp;</span><br><span class="line">cgexec -g cpu:sam ./prime &amp;&gt; /dev/null &amp;</span><br></pre></td></tr></table></figure>
<p><img src="/linux%E5%86%85%E6%A0%B8.resources/cpu_shares.png" alt="cpu_shares"></p>
<p>tip：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/fs/cgroup/cpu/bank/tasks </span><br></pre></td></tr></table></figure>
<p>查看<code>cgroup</code>是<code>bank</code>下有哪些进程在执行。</p>
<p>查看进程的相关信息，下面路径下的文件存储了进程相关的各种信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /proc/[pid]</span><br></pre></td></tr></table></figure>

<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p><img src="/linux%E5%86%85%E6%A0%B8.resources/linux_io.png" alt="linux_io"></p>
<h3 id="系统指令-1"><a href="#系统指令-1" class="headerlink" title="系统指令"></a>系统指令</h3><h4 id="iotop"><a href="#iotop" class="headerlink" title="iotop"></a>iotop</h4><p>TID 线程id<br>PRIO IO优先级<br> <br>ionice 调整IO优先级<br>idel<br>best-effort：最佳效果<br>rt 		：实时</p>
<h4 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -x 1 </span><br></pre></td></tr></table></figure>
<p><img src="/linux%E5%86%85%E6%A0%B8.resources/iostat.png" alt="iostat"></p>
<p>关注iowait指IO等待消耗的cpu，越小越好</p>
<ul>
<li><code>avgrq-sz</code> IO请求平均大小, 比较大的情况下, 顺序读写比较多</li>
<li><code>avgqu-sz</code> IO请求队列长度, 如果比较大, 表示当前IO请求比较多</li>
<li><code>await</code> IO等待时间</li>
<li><code>%util</code> 评估IO负载</li>
</ul>
<p>一般看<code>%util</code>的值，如果比较高，说明IO负载较高，但是如果使用了raid或ssd，这个值可能不准，因为ssd的底层原理和raid类似，都是连接多块小硬盘，组合成一块大的硬盘，在读写时多块小硬盘同时读写，但是这时<code>%util</code>统计的是一块硬盘的值，因此，如果<code>%util</code>的值到了100%，也不一定是IO负载拉满了。</p>
<p><code>await</code>的评估可以参看这篇<a target="_blank" rel="noopener" href="https://cseweb.ucsd.edu//classes/wi01/cse102/sol2.pdf">文章</a></p>
<h4 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -tt -p [pid]</span><br></pre></td></tr></table></figure>
<p>查看指定进程的系统调用。</p>
<h4 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lsof -p 查看指定进程的IO情况,下面指令中的 $$ 表示查看当前bash的进程</span></span><br><span class="line"><span class="comment"># 第一个 $ 是取变量的值,第二个 $ 是指当前的bash</span></span><br><span class="line">lsof -p $$</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos /data/home]<span class="comment"># lsof -p $$</span></span><br><span class="line">COMMAND   PID USER   FD   TYPE             DEVICE  SIZE/OFF       NODE NAME</span><br><span class="line">bash    23095 root  cwd    DIR             253,17      4096    6029314 /data/home/bankren</span><br><span class="line">bash    23095 root  rtd    DIR              253,1      4096          2 /</span><br><span class="line">bash    23095 root  txt    REG              253,1    922792     526169 /usr/bin/bash</span><br><span class="line">bash    23095 root  mem    REG              253,1 106176928     416765 /usr/lib/locale/locale-archive</span><br><span class="line">bash    23095 root  mem    REG              253,1   2156344     412728 /usr/lib64/libc-2.17.so</span><br><span class="line">bash    23095 root  mem    REG              253,1     19248     416908 /usr/lib64/libdl-2.17.so</span><br><span class="line">bash    23095 root  mem    REG              253,1    174576     413623 /usr/lib64/libtinfo.so.5.9</span><br><span class="line">bash    23095 root  mem    REG              253,1     15480     413373 /usr/lib64/libonion_security.so.1.0.19</span><br><span class="line">bash    23095 root  mem    REG              253,1     16697     403808 /usr/lib64/libonion_block_security.so.1.0.7</span><br><span class="line">bash    23095 root  mem    REG              253,1    163312     412076 /usr/lib64/ld-2.17.so</span><br><span class="line">bash    23095 root  mem    REG              253,1    217032     542309 /var/db/nscd/passwd</span><br><span class="line">bash    23095 root  mem    REG              253,1     26970     413427 /usr/lib64/gconv/gconv-modules.cache</span><br><span class="line">bash    23095 root    0u   CHR              136,0       0t0          3 /dev/pts/0</span><br><span class="line">bash    23095 root    1u   CHR              136,0       0t0          3 /dev/pts/0</span><br><span class="line">bash    23095 root    2u   CHR              136,0       0t0          3 /dev/pts/0</span><br><span class="line">bash    23095 root    3u  unix 0xffff8883c8225580       0t0 1009536501 socket</span><br><span class="line">bash    23095 root  255u   CHR              136,0       0t0          3 /dev/pts/0</span><br></pre></td></tr></table></figure>
<ul>
<li>COMMAND：进程的名称。</li>
<li>PID：进程的进程ID。</li>
<li>USER：进程的用户名称。</li>
<li>FD：文件描述符，表示文件的打开方式。常见的值包括：<ul>
<li>cwd：当前工作目录。</li>
<li>txt：进程的可执行文件。</li>
<li>mem：进程的内存映像。</li>
<li>REG：普通文件。</li>
<li>DIR：目录。</li>
<li>PIPE：命名管道。</li>
<li>unix：UNIX域套接字。</li>
<li>IPv4：IPv4套接字。</li>
<li>IPv6：IPv6套接字。</li>
</ul>
</li>
<li>TYPE：文件类型，表示文件的具体类型。常见的值包括：<ul>
<li>REG：普通文件。</li>
<li>DIR：目录。</li>
<li>CHR：字符设备。</li>
<li>BLK：块设备。</li>
<li>FIFO：命名管道。</li>
<li>SOCK：套接字。</li>
</ul>
</li>
<li>DEVICE：设备号，表示文件所在的设备。</li>
<li>SIZE&#x2F;OFF：文件大小或偏移量。</li>
<li>NODE：文件的节点号。</li>
<li>NAME：文件的路径和名称。</li>
</ul>
<h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> [file_path]</span><br></pre></td></tr></table></figure>

<h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 2 open</span><br></pre></td></tr></table></figure>

<p>直接调用open不加参数就是一般IO, 都会经过page cache来访问磁盘</p>
<ul>
<li><code>O_SYNC</code> 同步等待内存写道磁盘再返回</li>
<li><code>O_DERECT</code> 直接IO, 不经过page cache</li>
<li><code>O_ASYNC</code> 异步读取, 信号驱动，如果使用需要注册信号处理函数，实现异步</li>
<li><code>O_DSYNC</code> 只同步文件数据（内容）, 不同步元数据（属性信息）</li>
<li><code>O_NOATIME</code> 不记录文件访问时间<br>对于O_NOATIME，当读取文件时为了记录文件的访问时间，其实也是有写操作的，可以通过<code>stat [file_path]</code>进行查看，如果读操作十分频繁可以通过这个选项来提高性能，不进行隐藏的写操作。不记录文件访问时间。</li>
</ul>
<p>write-through &amp; sync IO    : write-through &#x3D; sync IO<br>write-back 写回, 内核把内存数据写到硬盘</p>
<h4 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h4><p><code>sync</code>全局同步，触发全局的buf&#x2F;cache中文件的写回;<br><code>fsync &lt;fd&gt;</code> 只针对某个文件同步，写回;<br><code>fdatasync</code> 只同步数据内容，写回;<br>文件的存储分成两部分，1. 文件实际数据；2. 文件元信息，如属性信息等。对于<code>fdatasync</code>就是只同步第一部分的文件实际数据，而不同步属性信息；</p>
<h4 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h4><p><code>mount</code>命令可以用于查看当前系统中已经挂载的文件系统列表。如果不指定任何参数，mount命令会列出当前系统中已经挂载的所有文件系统。</p>
<p>上面针对某个文件或者某些文件的设置，都可以通过<code>mount</code>指令设置在整个磁盘上所有文件的读写特性，如：</p>
<ul>
<li><code>noatime</code> 挂载的时候设置不写atime </li>
<li><code>ro</code> 只读 </li>
<li><code>Sync</code> 同步挂载</li>
</ul>
<h3 id="linux-IO体系结构"><a href="#linux-IO体系结构" class="headerlink" title="linux IO体系结构"></a>linux IO体系结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/filesystems </span><br></pre></td></tr></table></figure>
<p>查看支持的文件系统。</p>
<h4 id="ext4文件系统"><a href="#ext4文件系统" class="headerlink" title="ext4文件系统"></a>ext4文件系统</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpe2fs /dev/vba1</span><br></pre></td></tr></table></figure>
<p>查看文件系统指定分区等属性，其中<code>/dev/vba1</code>是文件系统分区，可以通过<code>mount</code>指令查看。<br>dumpe2fs执行结果：<br><img src="/linux%E5%86%85%E6%A0%B8.resources/dumpe2fs.png" alt="dumpe2fs"></p>
<p>这些信息存在分区的第一个块里, superblock, 其他的group也能会存储superblock的backup但不是每个group中都有。<br>分区分为很多个block group, 原因如下：</p>
<ol>
<li>同一个文件尽量存在相同的block里面，提高局部性，减少磁盘寻址时间；</li>
<li>方便动态扩充；</li>
<li>减少了磁盘碎片的产生；</li>
</ol>
<p>其中<code>jurnal</code>是日志信息，记录操作过程, 提高文件系统的检测速度, 只扫描日志文件即可，不必将全部的<code>inode</code>和<code>block</code>全部扫描一遍，并不保证文件不丢失, 只保证inode与data一致。</p>
<p>文件系统的结构如下：<br><img src="/linux%E5%86%85%E6%A0%B8.resources/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.png" alt="文件系统结构"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看系统中inode的使用情况</span></span><br><span class="line"><span class="built_in">df</span> -i</span><br><span class="line"><span class="comment"># 查看系统中block的使用情况</span></span><br><span class="line"><span class="built_in">df</span></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos /data/home]<span class="comment"># df -i</span></span><br><span class="line">Filesystem       Inodes  IUsed    IFree IUse% Mounted on</span><br><span class="line">devtmpfs        2011316   1460  2009856    1% /dev</span><br><span class="line">tmpfs           2015628      3  2015625    1% /dev/shm</span><br><span class="line">tmpfs           2015628   1298  2014330    1% /run</span><br><span class="line">tmpfs           2015628     17  2015611    1% /sys/fs/cgroup</span><br><span class="line">/dev/vda1       6553600 181394  6372206    3% /</span><br><span class="line">/dev/vdb1      13107200   4618 13102582    1% /data</span><br><span class="line">[root@VM-236-124-centos /data/home]<span class="comment"># df</span></span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">devtmpfs         8045264       0   8045264   0% /dev</span><br><span class="line">tmpfs            8062512   10244   8052268   1% /dev/shm</span><br><span class="line">tmpfs            8062512  280104   7782408   4% /run</span><br><span class="line">tmpfs            8062512       0   8062512   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1      103081200 8533824  90253172   9% /</span><br><span class="line">/dev/vdb1      206291944  292420 195497432   1% /data</span><br></pre></td></tr></table></figure>

<p>inode和block的结构如下：<br><img src="/linux%E5%86%85%E6%A0%B8.resources/ext4%E7%9A%84inode%E7%BB%93%E6%9E%84.png" alt="ext4的inode结构"><br>我们来看下linux内核的<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.4.119/source/fs/ext4/ext4.h">源码</a>，（5.4.119版本）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_inode</span> &#123;</span></span><br><span class="line">	__le16	i_mode;		<span class="comment">/* File mode */</span></span><br><span class="line">	__le16	i_uid;		<span class="comment">/* Low 16 bits of Owner Uid */</span></span><br><span class="line">	__le32	i_size_lo;	<span class="comment">/* Size in bytes */</span></span><br><span class="line">	__le32	i_atime;	<span class="comment">/* Access time */</span></span><br><span class="line">	__le32	i_ctime;	<span class="comment">/* Inode Change time */</span></span><br><span class="line">	__le32	i_mtime;	<span class="comment">/* Modification time */</span></span><br><span class="line">	__le32	i_dtime;	<span class="comment">/* Deletion Time */</span></span><br><span class="line">	__le16	i_gid;		<span class="comment">/* Low 16 bits of Group Id */</span></span><br><span class="line">	__le16	i_links_count;	<span class="comment">/* Links count */</span></span><br><span class="line">	__le32	i_blocks_lo;	<span class="comment">/* Blocks count */</span></span><br><span class="line">	__le32	i_flags;	<span class="comment">/* File flags */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__le32  l_i_version;</span><br><span class="line">		&#125; linux1;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u32  h_i_translator;</span><br><span class="line">		&#125; hurd1;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u32  m_i_reserved1;</span><br><span class="line">		&#125; masix1;</span><br><span class="line">	&#125; osd1;				<span class="comment">/* OS dependent 1 */</span></span><br><span class="line">	__le32	i_block[EXT4_N_BLOCKS];<span class="comment">/* Pointers to blocks */</span></span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>
<p>开始的几个字段存储了inode的元信息，我们来看<code>__le32	i_block[EXT4_N_BLOCKS];</code>，对于<code>EXT4_N_BLOCKS的</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Constants relative to the data blocks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EXT4_NDIR_BLOCKS		12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EXT4_IND_BLOCK			EXT4_NDIR_BLOCKS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EXT4_DIND_BLOCK			(EXT4_IND_BLOCK + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EXT4_TIND_BLOCK			(EXT4_DIND_BLOCK + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EXT4_N_BLOCKS			(EXT4_TIND_BLOCK + 1)</span></span><br></pre></td></tr></table></figure>
<p>EXT4_N_BLOCKS &#x3D; 15，其中前12个是直接指针，直接指向block块，第13是一级指针，第14是二级指针，第15是三级指针，以一级指针为例，就是这个指针指向的块（4kb）被全部划分成了指针（4字节），每个指针简介指向一个block，由block存储实际的数据。</p>
<p>一个指针是4字节：</p>
<ul>
<li>一级：1k * 4k	                &#x3D;&gt;    4M</li>
<li>二级：1k * 1k * 4k	        &#x3D;&gt;    4G</li>
<li>三级：1 k* 1k * 1k * 4k	    &#x3D;&gt;    4T</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改文件的操作权限,通过 + 实现添加不配置</span></span><br><span class="line">chattr</span><br><span class="line">- a:文件只能追加</span><br><span class="line">- i:文件不可修改、不可删除</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件的操作权限</span></span><br><span class="line">lsattr</span><br></pre></td></tr></table></figure>

<h4 id="xfs文件系统"><a href="#xfs文件系统" class="headerlink" title="xfs文件系统"></a>xfs文件系统</h4><h3 id="linux-IO调度"><a href="#linux-IO调度" class="headerlink" title="linux IO调度"></a>linux IO调度</h3><p>查看系统挂载的全部磁盘：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 系统挂载的全部磁盘</span></span><br><span class="line"><span class="built_in">cd</span> /sys/class/block</span><br><span class="line">[root@VM-236-124-centos /sys/class/block]<span class="comment"># ls</span></span><br><span class="line">loop0  loop3  loop6  nbd1   nbd12  nbd15  nbd4  nbd7  ram0   ram11  ram14  ram3  ram6  ram9  vda1</span><br><span class="line">loop1  loop4  loop7  nbd10  nbd13  nbd2   nbd5  nbd8  ram1   ram12  ram15  ram4  ram7  sr0   vdb</span><br><span class="line">loop2  loop5  nbd0   nbd11  nbd14  nbd3   nbd6  nbd9  ram10  ram13  ram2   ram5  ram8  vda   vdb1</span><br></pre></td></tr></table></figure>

<p>选取一个磁盘后，进入目录<code>queue</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos /sys/class/block/vda/queue]<span class="comment"># ls</span></span><br><span class="line">add_random            fua                 max_discard_segments    nbd_ignore_blksize_set  rotational          write_same_max_bytes</span><br><span class="line">chunk_sectors         hw_sector_size      max_hw_sectors_kb       nomerges                rq_affinity         write_zeroes_max_bytes</span><br><span class="line">dax                   io_poll             max_integrity_segments  nr_requests             scheduler           zoned</span><br><span class="line">discard_granularity   io_poll_delay       max_sectors_kb          nr_zones                wbt_class_conf</span><br><span class="line">discard_max_bytes     iosched             max_segments            optimal_io_size         wbt_class_lat_usec</span><br><span class="line">discard_max_hw_bytes  iostats             max_segment_size        physical_block_size     wbt_lat_usec</span><br><span class="line">discard_zeroes_data   logical_block_size  minimum_io_size         read_ahead_kb           write_cache</span><br><span class="line">````</span><br><span class="line">查看支持的调度策略，即目前使用的策略：</span><br><span class="line">```bash</span><br><span class="line">[root@VM-236-124-centos /sys/class/block/vda/queue]<span class="comment"># cat scheduler</span></span><br><span class="line">[mq-deadline] kyber bfq none</span><br></pre></td></tr></table></figure>
<p>修改调度策略的参数，这个路径下的文件会根据调度策略的不同自动更新：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos /sys/class/block/vda/queue]<span class="comment"># cd iosched</span></span><br><span class="line">[root@VM-236-124-centos /sys/class/block/vda/queue/iosched]<span class="comment"># ls</span></span><br><span class="line">fifo_batch  front_merges  read_expire  write_expire  writes_starved</span><br></pre></td></tr></table></figure>


<p>下面来讨论一下几种IO调度策略：（下面的调度策略都是对于机械硬盘来说的，对于SSD有无调度策略对性能几乎没有影响）</p>
<h4 id="CFQ"><a href="#CFQ" class="headerlink" title="CFQ"></a>CFQ</h4><p><img src="/linux%E5%86%85%E6%A0%B8.resources/cfq.png" alt="cfq"><br>完全公平队列，公平是针对进程来说的，也就是让进程公平的占用IO资源。<br>IO资源有两个单位：</p>
<ul>
<li>数据读写带宽，单位时间内的数据读写数据量。</li>
<li>数据读写的IOPS，单位时间内的读写次数。</li>
</ul>
<p>由于顺序读写和随机读写的性能差异，使用上面两个单位去评测进程对IO资源的占用都不是很准确，所以对进程占用IO的时间进行调度才是相对比较公平的，也就是说CFQ给进程尽量分配相同大小的块设备时间片。<br>进程IO优先级：</p>
<ul>
<li>RT：实时（Real Time）</li>
<li>BE：最佳效果（Best Try）</li>
<li>IDLE：闲置（idle）</li>
</ul>
<h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>首先<code>cfq</code>通过<code>cfq_group</code>，实现cgroup的资源隔离，cfq使用红黑树来维护多个cfg_group，使用每个group的的IO占用时间作为key，来维护红黑树，对于每个group的资源限制，通过控制不同group的IO占用时间key的增长速率来实现，<code>举个例子：A占用IO资源33%，B占用IO资源66%，则此时A再红黑树中key的增长速率就是B的两倍，即若A、B都占用了1s的IO时间，则在红黑树中A得key记2，B记1，这样就实现了资源的控制</code>。</p>
<p>每个<code>cfq_group</code>下都有7个<code>service tree</code>，其源码结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cfq_rb_root</span> <span class="title">service_trees</span>[2][3];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cfq_rb_root</span> <span class="title">service_tree_idle</span>;</span></span><br></pre></td></tr></table></figure>
<p>对于<code>service_trees</code>，是一个二维数组，维护了<code>RT</code>、<code>BE</code>两个优先级队列，其中每个维度内又针对<code>SYNC</code>、<code>SYNC_NOIDLE</code>、<code>ASYNC</code>三种不同类型的请求，维护了三颗红黑树。<br>对于<code>service_tree_idle</code>，是用来给<code>IDLE</code>类型的请求进行排队用的红黑树。</p>
<ul>
<li><code>SYNC</code>：同步请求类型，表示IO请求需要等待设备完成之后才能返回</li>
<li><code>SYNC_NOIDLE</code>：同步非空闲请求类型，表示IO请求需要等待设备完成之后才能返回，并且不允许设备在空闲时进行IO操作</li>
<li><code>ASYNC</code>：异步请求类型，表示IO请求可以立即返回，而不需要等待设备完成</li>
<li><code>IDLE</code>：空闲请求类型，表示IO请求只有在设备处于空闲状态时才会执行</li>
</ul>
<p>入队策略：</p>
<ul>
<li>如果请求是同步顺序请求，就入队SYNC队列；</li>
<li>如果请求是同步随机请求，则入队SYNC_NOIDLE队列，以判断下一个请求是否是顺序请求；</li>
<li>所有的异步写操作请求将入队ASYNC的service tree，并且针对这个队列没有空转等待机制；</li>
</ul>
<p>对于三种优先级类型的service tree，根据类型的优先级做选择进行调度，其中<code>RT &gt; BE &gt; IDEL</code>，也就是说RT里有，就会一直处理RT，RT没了再处理BE。每个service tree都是一个元素是<code>cfq_queue</code>的红黑树，每个<code>cfq_queue</code>对应一个进程的全部IO操作，其key是这个队列<code>cfq_queue</code>的IO服务时间，通过红黑树找到IO服务时间占用最短的队列进行服务，以此来保证“公平”。</p>
<p>选取好待服务的<code>cfq_queue</code>队列后，接下来处理这个队列中的IO请求。cfq会将队列中的每一个请求分别加入fifo和安访问扇区作为key的红黑树，默认从红黑树中取请求进行处理，当请求的延时时间达到deadline时，就从红黑树中取等待时间最长的进行处理，以保证请求不被饿死。</p>
<h6 id="参数调整"><a href="#参数调整" class="headerlink" title="参数调整"></a>参数调整</h6><table>
<thead>
<tr>
<th>参数名</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>back_seek_max</td>
<td>磁头可以向后寻址的最大范围，默认值为16M</td>
<td></td>
</tr>
<tr>
<td>back_seek_penalty</td>
<td>向后寻址的惩罚系数。这个值是跟向前寻址进行比较的</td>
<td></td>
</tr>
<tr>
<td>fifo_expire_async</td>
<td>设置异步请求的超时时间</td>
<td></td>
</tr>
<tr>
<td>fifo_expire_sync</td>
<td>设置同步请求的超时时间</td>
<td></td>
</tr>
<tr>
<td>slice_idle</td>
<td>等待时间,让cfq在切换cfq_queue或service tree的时候等待一段时间，目的是提高机械硬盘的吞吐量</td>
<td></td>
</tr>
<tr>
<td>group_idle</td>
<td>当cfq要切换cfq_group的时候的等待一段时间</td>
<td></td>
</tr>
<tr>
<td>low_latency</td>
<td>开启或关闭cfq的低延时（low latency）模式的开关</td>
<td></td>
</tr>
<tr>
<td>target_latency</td>
<td>low_latency的值为开启状态时，cfq将根据这个值重新计算每个进程分配的IO时间片长度</td>
<td></td>
</tr>
<tr>
<td>quantum</td>
<td>当一个cfq_queue队列被调度处理时，它可以被分配的处理总时间是通过这个值来作为一个计算参数指定的公式：time_slice &#x3D; slice_sync + (slice_sync&#x2F;5 * (4 - prio))</td>
<td>对同步请求有效</td>
</tr>
<tr>
<td>slice_async</td>
<td>同上</td>
<td>对异步请求有效</td>
</tr>
<tr>
<td>slice_async_rq</td>
<td>在一个slice的时间范围内，一个队列最多可以处理的异步请求个数</td>
<td></td>
</tr>
</tbody></table>
<h4 id="DEADLINE"><a href="#DEADLINE" class="headerlink" title="DEADLINE"></a>DEADLINE</h4><p>在保证IO最大吞吐量（尽量采用顺序IO）的情况下，尽量使请求在一个期限内不会被饿死。</p>
<h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p><code>deadline</code>调度器实现了两种队列，一种对请求按照扇区进行排序，使用红黑树进行组织，<code>sort_list</code>；一种对请求按照访问时间进行排序，使用链表进行组织，<code>fifo_list</code>。<br>实际上<code>deadline</code>内部对读写进行分离，原因是读操作比较轻量，<code>deadline</code>会优先处理读请求，因此<code>deadline</code>有四个队列：</p>
<ol>
<li>按照扇区访问顺序排序的读队列；</li>
<li>按照扇区访问顺序排序的写队列；</li>
<li>按照访问时间排序的读队列；</li>
<li>按照访问时间排序的写队列；</li>
</ol>
<p>实际调度的流程如下所示：<br><img src="/linux%E5%86%85%E6%A0%B8.resources/deadline%E6%B5%81%E7%A8%8B.png" alt="deadline流程"></p>
<h5 id="参数调整-1"><a href="#参数调整-1" class="headerlink" title="参数调整"></a>参数调整</h5><table>
<thead>
<tr>
<th>参数名</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>read_expire</td>
<td>读请求超时实际</td>
<td>单位：ms</td>
</tr>
<tr>
<td>write_expire</td>
<td>写请求超时时间</td>
<td>单位：ms</td>
</tr>
<tr>
<td>fifo_batch</td>
<td>处理sort_list的时候，一批请求的处理数量</td>
<td>增大这个值可以增大吞吐量，但会导致处理饥饿请求的时间变长，反之亦然</td>
</tr>
<tr>
<td>writes_starved</td>
<td>处理读写请求优先级的参数</td>
<td>在出队第一步时使用，判断当读队列不为空时，写队列的饥饿程度是否足够高，使deadline放弃读请求的处理而处理写请求，检查存在写请求时参数starved加1，当starved &gt;&#x3D; writes_starved的时候，deadline才会去处理写请求</td>
</tr>
<tr>
<td>front_merges</td>
<td>新请求入队列时，若与当前扇区很接近则可以进行合并，合并时可以向前、向后合并</td>
<td>默认支持向前合并，设置成0是关闭</td>
</tr>
</tbody></table>
<h4 id="BFQ"><a href="#BFQ" class="headerlink" title="BFQ"></a>BFQ</h4><h4 id="kyber"><a href="#kyber" class="headerlink" title="kyber"></a>kyber</h4><h3 id="资源隔离-1"><a href="#资源隔离-1" class="headerlink" title="资源隔离"></a>资源隔离</h3><p>设置IO资源隔离的路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /sys/fs/cgroup/blkio</span><br><span class="line"><span class="built_in">mkdir</span> bankren</span><br><span class="line"><span class="built_in">cd</span> bankren</span><br></pre></td></tr></table></figure>
<p>配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos /sys/fs/cgroup/blkio/bankren]<span class="comment"># ls</span></span><br><span class="line">blkio.bfq.ioprio_class                blkio.latency                              blkio.throttle.stat</span><br><span class="line">blkio.bfq.io_service_bytes            blkio.reset_stats                          blkio.throttle.write_bps_device</span><br><span class="line">blkio.bfq.io_service_bytes_recursive  blkio.throttle.buffered_write_bps          blkio.throttle.write_iops_device</span><br><span class="line">blkio.bfq.io_serviced                 blkio.throttle.io_service_bytes            cgroup.clone_children</span><br><span class="line">blkio.bfq.io_serviced_recursive       blkio.throttle.io_service_bytes_recursive  cgroup.priority</span><br><span class="line">blkio.bfq.weight                      blkio.throttle.io_serviced                 cgroup.procs</span><br><span class="line">blkio.bfq.weight_device               blkio.throttle.io_serviced_recursive       io.pressure</span><br><span class="line">blkio.cost.stat                       blkio.throttle.read_bps_device             notify_on_release</span><br><span class="line">blkio.cost.weight                     blkio.throttle.read_iops_device            tasks</span><br><span class="line">blkio.diskstats                       blkio.throttle.readwrite_bps_device</span><br><span class="line">blkio.diskstats_recursive             blkio.throttle.readwrite_iops_device</span><br><span class="line">[root@VM-236-124-centos /sys/fs/cgroup/blkio/bankren]<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<ul>
<li>blkio.throttle.read_bps_device：用于限制块设备IO读取速率的字节数&#x2F;秒。</li>
<li>blkio.throttle.read_iops_device：用于限制块设备IO读取速率的IOPS（每秒IO操作数）。</li>
<li>blkio.throttle.write_bps_device：用于限制块设备IO写入速率的字节数&#x2F;秒。</li>
<li>blkio.throttle.write_iops_device：用于限制块设备IO写入速率的IOPS（每秒IO操作数）。</li>
</ul>
<h4 id="实验："><a href="#实验：" class="headerlink" title="实验："></a>实验：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos ~]<span class="comment"># dd if=/dev/zero of=/home/testfile bs=1M count=1024</span></span><br><span class="line">1024+0 records <span class="keyword">in</span></span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB) copied, 0.523492 s, 2.1 GB/s</span><br></pre></td></tr></table></figure>
<p>先来看一下，不做限制的写入，写入1GB的数据到文件，可以看到写入数据很快，这也证明了系统缓存的存在，是先把文件写入内存，然后再由内核异步写入磁盘。<br>下面来配置<code>cgroup</code>组；<br>首先查看一下设备编号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看系统中的block</span></span><br><span class="line"><span class="built_in">df</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看对应block的设备号</span></span><br><span class="line"><span class="built_in">ls</span> -l [block]</span><br><span class="line"><span class="comment"># 主设备号：使用那个驱动</span></span><br><span class="line"><span class="comment"># 从设备号：使用这个驱动下的第几个设备</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos /sys/fs/cgroup/blkio/bankren]<span class="comment"># df</span></span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">devtmpfs         8045264       0   8045264   0% /dev</span><br><span class="line">tmpfs            8062512   10244   8052268   1% /dev/shm</span><br><span class="line">tmpfs            8062512  271912   7790600   4% /run</span><br><span class="line">tmpfs            8062512       0   8062512   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1      103081200 9582476  89204520  10% /</span><br><span class="line">/dev/vdb1      206291944  292420 195497432   1% /data</span><br><span class="line">[root@VM-236-124-centos /sys/fs/cgroup/blkio/bankren]<span class="comment"># ls -l /dev/vda1</span></span><br><span class="line">brw-rw---- 1 root disk 253, 1 Sep  6  2022 /dev/vda1</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos /sys/fs/cgroup/blkio/bankren]<span class="comment"># echo $[10*1024*1024]</span></span><br><span class="line">10485760</span><br></pre></td></tr></table></figure>


<p>快速计算：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $[1+1]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清除文件系统缓存（全局回收）</span></span><br><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br><span class="line"></span><br><span class="line">1:回收page cache</span><br><span class="line">2:回收buffer cache</span><br><span class="line">3:全局回收，回收page cache和buffer cache</span><br></pre></td></tr></table></figure>

<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="系统指令-2"><a href="#系统指令-2" class="headerlink" title="系统指令"></a>系统指令</h3><h4 id="top-1"><a href="#top-1" class="headerlink" title="top"></a>top</h4><p>见CPU中的top命令解析。</p>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos /dev/shm]<span class="comment"># free</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:       16125028      543192    12972972      284908     2608864    15117052</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure>
<p><code>available</code>:系统可用的内存空间。<br><code>buff/cache</code>:对于这个指标的含义在cpu篇的top指令中已做介绍，这里不再赘述。<br><code>shared</code>:</p>
<h4 id="sar-1"><a href="#sar-1" class="headerlink" title="sar"></a>sar</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -r 1</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos /dev/shm]<span class="comment"># sar -r 1</span></span><br><span class="line">Linux 5.4.119-1-tlinux4-0008 (VM-236-124-centos)        07/18/2023      _x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">08:00:34 PM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">08:00:35 PM  12980908   3144120     19.50    294144   2021972   2224680     13.80   1109636   1488612        48</span><br><span class="line">08:00:36 PM  12981004   3144024     19.50    294148   2021976   2224680     13.80   1109500   1488616       140</span><br><span class="line">08:00:37 PM  12981004   3144024     19.50    294156   2021968   2224680     13.80   1109500   1488616       140</span><br><span class="line">08:00:38 PM  12981004   3144024     19.50    294156   2021976   2224680     13.80   1109508   1488616       156</span><br><span class="line">08:00:39 PM  12980988   3144040     19.50    294156   2021976   2224680     13.80   1109508   1488616       156</span><br><span class="line">08:00:40 PM  12980208   3144820     19.50    294156   2021976   2233952     13.85   1109812   1488616       156</span><br><span class="line">08:00:41 PM  12980216   3144812     19.50    294160   2021976   2233952     13.85   1109668   1488616       156</span><br><span class="line">08:00:42 PM  12980428   3144600     19.50    294160   2021976   2233952     13.85   1109512   1488616        68</span><br><span class="line">08:00:43 PM  12980428   3144600     19.50    294160   2021976   2233952     13.85   1109512   1488616        68</span><br><span class="line">08:00:44 PM  12980428   3144600     19.50    294160   2021976   2233952     13.85   1109512   1488616        52</span><br><span class="line">08:00:45 PM  12980656   3144372     19.50    294160   2021980   2225956     13.80   1109744   1488620        56</span><br><span class="line">^C</span><br><span class="line"></span><br><span class="line">08:00:45 PM  12980656   3144372     19.50    294164   2021980   2225956     13.80   1109744   1488620       116</span><br><span class="line">Average:     12980661   3144367     19.50    294157   2021976   2228756     13.82   1109596   1488616       109</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>名字</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>kbmemfree</td>
<td>空闲内存</td>
<td></td>
</tr>
<tr>
<td>kbmemused</td>
<td>已使用内存</td>
<td></td>
</tr>
<tr>
<td>%memused</td>
<td>已使用内存百分比</td>
<td></td>
</tr>
<tr>
<td>kbbuffers</td>
<td>buffer cache大小</td>
<td></td>
</tr>
<tr>
<td>kbcached</td>
<td>page cache大小</td>
<td></td>
</tr>
<tr>
<td>kbcommit</td>
<td>系统承诺给进程的内存</td>
<td></td>
</tr>
<tr>
<td>%commit</td>
<td>系统承诺给进程的内存百分比</td>
<td>由于是承诺的数字不是展示占用的，所以可能超过100%</td>
</tr>
<tr>
<td>kbactive</td>
<td>活跃内存</td>
<td></td>
</tr>
<tr>
<td>kbinact</td>
<td>非活跃内存</td>
<td></td>
</tr>
<tr>
<td>kbdirty</td>
<td>脏内存</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -B 1</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos /dev/shm]<span class="comment"># sar -B 1</span></span><br><span class="line">Linux 5.4.119-1-tlinux4-0008 (VM-236-124-centos)        07/18/2023      _x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">08:29:40 PM  pgpgin/s pgpgout/s   fault/s  majflt/s  pgfree/s pgscank/s pgscand/s pgsteal/s    %vmeff</span><br><span class="line">08:29:41 PM      0.00      0.00     32.00      0.00   1454.00      0.00      0.00      0.00      0.00</span><br><span class="line">08:29:42 PM      0.00      8.00   1574.00      0.00   1279.00      0.00      0.00      0.00      0.00</span><br><span class="line">08:29:43 PM      0.00      4.00     18.00      0.00     24.00      0.00      0.00      0.00      0.00</span><br><span class="line">08:29:44 PM      0.00      0.00   1624.00      0.00   2371.00      0.00      0.00      0.00      0.00</span><br><span class="line">08:29:45 PM      0.00     92.00     29.00      0.00     29.00      0.00      0.00      0.00      0.00</span><br><span class="line">^C</span><br><span class="line">08:29:46 PM      0.00      0.00     62.96      0.00     37.04      0.00      0.00      0.00      0.00</span><br><span class="line">Average:         0.00     18.77    597.65      0.00    934.48      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure>
<p>具体各个指标的含义可以通过<code>man</code>指令来看。<br>这里来讨论一下<code>fault</code>，<code>fault = minor fault + major fault</code></p>
<ul>
<li><code>minor fault</code>:虚地址没映射到物理内存数（在频繁申请内存时可能会出现）。<br>比如int a;没有初始化赋值，在使用a的时候就会出现minor fault</li>
<li><code>major fault</code>:进程在访问数据时，内存上已经没有了，必须到硬盘上找。（类似于缺页中断）<br>90%的情况，该指标高都出现在swap之后。</li>
</ul>
<p>针对进程查看上面的两个指标：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -p [pid] -o min_flt,maj_flt</span><br></pre></td></tr></table></figure>

<p><code>pgscank</code>:kswapd守护进程每秒扫描的页面数量，查看哪些内存可以回收，扫描不活跃的内存交换出去，这个指标比较高代表内存吃紧，需要开始考虑交换了。<br><code>pgscand</code>:每秒直接扫描的页面数量。在Linux内核中，有一个名为”page scanner”的守护进程，用于扫描内存中的页面，以释放内存资源。”pgscand&#x2F;s”指标表示这个守护进程每秒直接扫描的页面数量，即不包括通过kswapd等其他守护进程间接扫描的页面，也就是说这里扫描的是page cache。</p>
<p>来看下linux的内存回收的过程。linux在以下两种情况时会触发内存回收：</p>
<ol>
<li>为了对任何时刻突发到来的内存申请提供支持，内核有一个周期性的内存回收机制（kswapd守护进程）；</li>
<li>有大于空闲内存的申请到来时，会强制进行内存回收；</li>
</ol>
<p>在回收时，内核会扫描匿名页中inactive链表和active链表、文件页的inactive链表和active链表，也就分别对应了后续的swap操作和page cache回收操作。（如下面的结构体所示）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LRU_BASE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LRU_ACTIVE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LRU_FILE 2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">lru_list</span> &#123;</span></span><br><span class="line">        LRU_INACTIVE_ANON = LRU_BASE,</span><br><span class="line">        LRU_ACTIVE_ANON = LRU_BASE + LRU_ACTIVE,</span><br><span class="line">        LRU_INACTIVE_FILE = LRU_BASE + LRU_FILE,</span><br><span class="line">        LRU_ACTIVE_FILE = LRU_BASE + LRU_FILE + LRU_ACTIVE,</span><br><span class="line">        LRU_UNEVICTABLE,</span><br><span class="line">        NR_LRU_LISTS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其具体的扫描过程是，首先扫描每个zone上的cgroup组。然后再以cgroup的内存为单元进行page链表的扫描。内核会先扫描anon的active链表，将不频繁的放进inactive链表中，然后扫描inactive链表，将里面活跃的移回active中。进行swap的时候，先对inactive的页进行换出。如果是file的文件映射page页，则判断其是否为脏数据，如果是脏数据就写回，不是脏数据可以直接释放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里zone的含义是指内存的分区管理。Linux将内存分成多个区，主要有直接访问区(DMA)、一般区(Normal)和高端内存区(HighMemory)</span><br></pre></td></tr></table></figure>

<p>那么kswapd守护进程在何时进行内存回收呢？<br>内核中有min、low、high的三个水位标记，可通过如下指令查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/zoneinfo</span><br></pre></td></tr></table></figure>
<p><img src="/linux%E5%86%85%E6%A0%B8.resources/zoneinfo.png" alt="zoneinfo"><br>当系统剩余内存低于watermark[low]的时候，内核的kswapd开始起作用，进行内存回收。直到剩余内存达到watermark[high]的时候停止。如果内存消耗导致剩余内存达到了或超过了watermark[min]时，就会触发直接回收（direct reclaim）<br><code>/proc/sys/vm/min_free_kbytes</code>文件中的值是系统中watermark[min]的值（内核可能针对内存情况对实际watermark[min]的值进行调整），内核通过内存的情况计算出low、high的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">linux在内存吃紧的时候有两种策略对内存进行回收：</span><br><span class="line">1. swap操作</span><br><span class="line">2. 回收page cache</span><br><span class="line">其中swap操作主要回收匿名页。没有文件背景的页面，即匿名页（anonymous page），如堆，栈，数据段等，不是以文件形式存在，因此无法和磁盘文件交换，但可以通过硬盘上划分额外的swap交换分区或使用交换文件进行交换。</span><br><span class="line">这两个操作是同步进行的，也就对应了上面的kswapd守护进程和page scanner守护进程，对于优先进行swap交换还是优先回收page cache可以通过下面的文件进行配置：</span><br><span class="line"></span><br><span class="line">cat  /proc/sys/vm/swappiness</span><br><span class="line">60</span><br><span class="line"></span><br><span class="line">值越大代表swap交换得到内存的几率越大。</span><br><span class="line">整个权重值是100， 100-文件中的值 是从page cache中回收内存的权重，也就是说文件中的值代表swap的权重。</span><br><span class="line">注意就算这个值调整成0也并不意味着不进行swap操作，当回收page cache不足以满足内存需求的时候，同样会swap。</span><br></pre></td></tr></table></figure>
<p>可以通过下面的指令查看系统中正在使用的交换空间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon -s</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">但是cache真的能被全部回收吗？(后续可以补充一个实验)</span><br><span class="line">答案是不是的，</span><br><span class="line">- tmpfs中存储的文件会占用cache空间，除非文件删除否则这个cache不会被自动释放。</span><br><span class="line">- 使用shmget方式申请的共享内存会占用cache空间，除非共享内存被ipcrm或者使用shmctl去IPC_RMID，否则相关的cache空间都不会被自动释放。</span><br><span class="line">- 使用mmap方法申请的MAP_SHARED标志的内存会占用cache空间，除非进程将这段内存munmap，否则相关的cache空间都不会被自动释放。</span><br><span class="line"></span><br><span class="line">实际上shmget、mmap的共享内存，在内核层都是通过tmpfs实现的，tmpfs实现的存储用的都是cache。</span><br></pre></td></tr></table></figure>

<h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><h4 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos /dev/shm]<span class="comment"># vmstat 1</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy <span class="built_in">id</span> wa st</span><br><span class="line"> 0  0      0 12967136 296484 2317676    0    0     0     8    0    0  0  0 100  0  0</span><br><span class="line"> 0  0      0 12967412 296484 2317728    0    0     0     0 1936 3216  1  0 99  0  0</span><br><span class="line"> 0  0      0 12967412 296484 2317728    0    0     0     0 1863 3217  0  0 100  0  0</span><br><span class="line"> 0  0      0 12967412 296488 2317728    0    0     0    64 1889 3223  0  0 100  0  0</span><br><span class="line"> 0  0      0 12967444 296488 2317728    0    0     0   136 1984 3228  1  0 99  0  0</span><br><span class="line"> 1  0      0 12967420 296488 2317728    0    0     0     4 2070 3314  1  0 99  0  0</span><br><span class="line"> 0  0      0 12967688 296488 2317728    0    0     0     0 1907 3247  0  0 100  0  0</span><br></pre></td></tr></table></figure>
<p>这里<code>cs</code>是指上下文切换次数，如中断或进程切换会导致上下文切换。</p>
<h4 id="cat-x2F-proc-x2F-meminfo"><a href="#cat-x2F-proc-x2F-meminfo" class="headerlink" title="cat &#x2F;proc&#x2F;meminfo"></a>cat &#x2F;proc&#x2F;meminfo</h4><p>查看系统的内存占用情况。</p>
<h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p>32位操作系统内存布局：<br><img src="/linux%E5%86%85%E6%A0%B8.resources/32%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="32位操作系统内存布局"></p>
<p>64位操作系统内存布局：<br><img src="/linux%E5%86%85%E6%A0%B8.resources/64%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="64位操作系统内存布局"></p>
<h3 id="内存申请"><a href="#内存申请" class="headerlink" title="内存申请"></a>内存申请</h3><p>申请内存方式：<br>int a;<br>malloc() -&gt; brk（堆）<br>     &gt;128kb -&gt; mmap<br>mmap内存映射：可以映射文件到内存，之后读取文件可以直接访问内存，很快</p>
<h3 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h3><p>三级页表，待完善</p>
<h3 id="内存分配系统"><a href="#内存分配系统" class="headerlink" title="内存分配系统"></a>内存分配系统</h3><h4 id="buddy系统"><a href="#buddy系统" class="headerlink" title="buddy系统"></a>buddy系统</h4><p>给用户进程分配内存使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos ~]<span class="comment"># cat /proc/buddyinfo </span></span><br><span class="line">Node 0, zone      DMA      0      0      0      1      1      1      1      1      0      1      3 </span><br><span class="line">Node 0, zone    DMA32   1853   2058   1861   1616   1202    962    657    425    257    223    324 </span><br><span class="line">Node 0, zone   Normal    218    336   2091  14406  15425   9723   6814   4604   2123    512     38</span><br></pre></td></tr></table></figure>
<ul>
<li>DMA：物理地址小于等于16MB的内存区域。</li>
<li>DMA32：物理地址大于16MB小于等于4GB的内存区域。</li>
<li>Normal：物理地址大于4GB的内存区域。</li>
</ul>
<p>每个区域有11个参数，分别表示有2的n次方个页面可以被分配：<br>按一页一个内存块分配，有多少个连续内存块可以分配       <code>4k * 1</code><br>按两页一个内存块分配，有多少个连续内存块可以分配       <code>4k * 2</code><br>按四页一个内存块分配，有多少个连续内存块可以分配	   <code>4k * 4</code><br>….<br><img src="/linux%E5%86%85%E6%A0%B8.resources/buddy.png" alt="buddy"></p>
<h4 id="slab系统"><a href="#slab系统" class="headerlink" title="slab系统"></a>slab系统</h4><p>给内核态分配内存使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/slabinfo</span><br></pre></td></tr></table></figure>
<p>如：kmalloc-8 链表 内核要使用8k内存时，在这个链表申请一个节点<br>查看内核的内存占用情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slabtop</span><br></pre></td></tr></table></figure>
<p>如果free的used很高，但是ps里占用都很低。就要考虑可能是内核用的，ps看不到。这时看slabtop。</p>
<p>内存回收：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /proc/sys/vm</span><br></pre></td></tr></table></figure>
<ul>
<li><code>dirty_ratio</code>:单个进程中的脏数据比率阈值，单个进程中的脏数据比率占到全部内存的40%，则出发全局回写。</li>
<li><code>dirty_background_ratio</code>:内存中的脏数据比率阈值，内存中的脏数据比率占到全部内存的10%，则出发全局回写。</li>
<li><code>dirty_expire_centisecs</code>:超时时间，单位1&#x2F;100s，脏数据在内存中超过30s就触发写回。</li>
<li><code>dirty_writeback_centisecs</code>:内核检测内存中脏数据的时间间隔，每5s检查一次内存中有无脏数据需要写回。</li>
</ul>
<p>swap机制：<br>当前内存中不活跃的部分换出到硬盘。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看swap空间</span></span><br><span class="line">swapon -s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭swap空间</span></span><br><span class="line">swapoff [filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启swap空间</span></span><br><span class="line">swapon [filename]</span><br></pre></td></tr></table></figure>

<p>OOM：out of memory<br>内核在内存空间不够时，若对buffer&#x2F;cache进行回收、进行swap操作内存还是不够时，会触发OOM killer。<br>内核会对每个进程进行评分，选取评分最高的进程进行killer，评分可通过如下指令查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/[pid]/oom_score</span><br></pre></td></tr></table></figure>

<p>查看摸某个进程的内存地址空间占用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pmap [pid]</span><br></pre></td></tr></table></figure>

<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h3><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -antp</span><br><span class="line">netstat -anup</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网络相关操作的计数器</span></span><br><span class="line">netstat -s</span><br></pre></td></tr></table></figure>
<p>注意<code>ListenOverflows</code>，这个计数器表示服务端listen，客户端来连接，但是服务端没有及时aceept，可以通过这个计数器来查看服务器的状态，如果这个值比较高，可能是：</p>
<ol>
<li>服务器cpu占用较高；</li>
<li>业务进程处理较慢；</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看路由表</span></span><br><span class="line">netstat -nr</span><br></pre></td></tr></table></figure>
<p>注意上面的指令查的路由表是不全的，可以通过如下指令查看一共有多少路由表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos ~]<span class="comment"># cat /etc/iproute2/rt_tables </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># reserved values</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">255     <span class="built_in">local</span></span><br><span class="line">254     main</span><br><span class="line">253     default</span><br><span class="line">0       unspec</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># local</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#1      inr.ruhep</span></span><br></pre></td></tr></table></figure>
<p>可以再根据路由表的名字或编号来查询路由表的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route show table <span class="built_in">local</span></span><br></pre></td></tr></table></figure>

<p>这么多张路由表哪个先查，哪个后查呢，可以查看路由规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos ~]<span class="comment"># ip rule show</span></span><br><span class="line">0:      from all lookup <span class="built_in">local</span> </span><br><span class="line">32766:  from all lookup main </span><br><span class="line">32767:  from all lookup default </span><br></pre></td></tr></table></figure>
<p>编号越小的表查询的优先级越高。</p>
<h4 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos ~]<span class="comment"># ss -antp</span></span><br><span class="line">State       Recv-Q Send-Q                       Local Address:Port                                      Peer Address:Port              </span><br><span class="line">LISTEN      0      100                              127.0.0.1:42222                                                *:*                   <span class="built_in">users</span>:((&quot;TsysAgent&quot;,pid=<span class="number">8299</span>,fd=<span class="number">4</span>))</span><br><span class="line">LISTEN      0      128                                      *:36000                                                *:*                   <span class="built_in">users</span>:((&quot;sshd&quot;,pid=<span class="number">12541</span>,fd=<span class="number">3</span>))</span><br><span class="line">LISTEN      0      4096                                     *:48369                                                *:*                   <span class="built_in">users</span>:((&quot;TsysProxy&quot;,pid=<span class="number">18394</span>,fd=<span class="number">5</span>))</span><br><span class="line">ESTAB       0      0                            9.134.236.124:55148                                      9.151.52.38:9988                <span class="built_in">users</span>:((&quot;secu-tcs-agent&quot;,pid=<span class="number">31920</span>,fd=<span class="number">9</span>))</span><br><span class="line">ESTAB       0      0                            9.134.236.124:60578                                      9.134.205.9:9922                <span class="built_in">users</span>:((&quot;agent&quot;,pid=<span class="number">8823</span>,fd=<span class="number">3</span>))</span><br><span class="line">ESTAB       0      256                          9.134.236.124:36000                                      10.78.28.29:52716               <span class="built_in">users</span>:((&quot;sshd&quot;,pid=<span class="number">14865</span>,fd=<span class="number">3</span>),(&quot;sshd&quot;,pid=<span class="number">14855</span>,fd=<span class="number">3</span>))</span><br><span class="line">LISTEN      0      4096                                  [::]:8011                                              [::]:*                   <span class="built_in">users</span>:((&quot;rrnet_reciever&quot;,pid=<span class="number">17986</span>,fd=<span class="number">3</span>))</span><br><span class="line">LISTEN      0      4096                                  [::]:8013                                              [::]:*                   <span class="built_in">users</span>:((&quot;rrnet_reciever&quot;,pid=<span class="number">1686</span>,fd=<span class="number">3</span>))</span><br><span class="line">LISTEN      0      4096                                  [::]:9011                                              [::]:*                   <span class="built_in">users</span>:((&quot;rrnet_reciever&quot;,pid=<span class="number">17986</span>,fd=<span class="number">7</span>))</span><br><span class="line">LISTEN      0      4096                                  [::]:9013                                              [::]:*                   <span class="built_in">users</span>:((&quot;rrnet_reciever&quot;,pid=<span class="number">1686</span>,fd=<span class="number">7</span>))</span><br></pre></td></tr></table></figure>
<p><code>ss</code>指令兼容<code>netstat</code>指令的参数，建议使用ss指令。<br>上面的输出，若处于<code>LISTEN</code>状态的<code>Send-Q</code>不是零，则这个值表示这个<code>socket</code>的<code>backup</code>（全连接队列数）是多大。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看详细信息</span></span><br><span class="line">ss -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看定时器</span></span><br><span class="line">ss -o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看连接占用的内存</span></span><br><span class="line">ss -m</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看每个端口对应的名字</span></span><br><span class="line">vim /etc/services</span><br></pre></td></tr></table></figure>

<h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><p>可以通过</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>
<p>查看网卡的相关信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网卡配置</span></span><br><span class="line">ethtool -k eth1</span><br></pre></td></tr></table></figure>

<h4 id="sar-2"><a href="#sar-2" class="headerlink" title="sar"></a>sar</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网卡的状态</span></span><br><span class="line">sar -n DEV 1</span><br></pre></td></tr></table></figure>
<p>关注前四个参数，每秒网卡接收包数、发送包数、接收字节数、发送字节数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网卡的错误状态</span></span><br><span class="line">sar -n EDEV 1</span><br></pre></td></tr></table></figure>

<h4 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h4><p>抓包指令</p>
<h3 id="traffic-control-流量控制"><a href="#traffic-control-流量控制" class="headerlink" title="traffic control 流量控制"></a>traffic control 流量控制</h3><p>在讨论下面的tcp前，先来讨论下linux内核对网卡队列的控制。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看正在使用的队列规则及配置</span></span><br><span class="line">tc qd show</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos ~]<span class="comment"># tc qd show</span></span><br><span class="line">qdisc noqueue 0: dev lo root refcnt 2 </span><br><span class="line">qdisc mq 0: dev eth1 root </span><br><span class="line">qdisc pfifo_fast 0: dev eth1 parent :2 bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1</span><br><span class="line">qdisc pfifo_fast 0: dev eth1 parent :1 bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1</span><br><span class="line">qdisc noqueue 0: dev docker0 root refcnt 2 </span><br></pre></td></tr></table></figure>
<p>目前系统中对外的网卡是<code>eth1</code>，使用的队列规则是<code>pfifo_fast</code>。</p>
<h4 id="fifo-amp-pfifo-fast队列"><a href="#fifo-amp-pfifo-fast队列" class="headerlink" title="fifo &amp; pfifo_fast队列"></a>fifo &amp; pfifo_fast队列</h4><p><code>pfifo_fast</code>的原理比较简单，内核维护了三个优先级队列，每个数据包根据自己的情况选择一个队列，每个队列内都是使用FIFO进行调度，队列间根据优先级，先处理优先级高的队列。<br><img src="/linux%E5%86%85%E6%A0%B8.resources/pfifo_fast.png" alt="pfifo_fast"><br>可以看<code>priomap</code>参数，其中有16位，这对应了IP报文中的TOS字段，TOS字段8位中的4位分别是用来标识最小延时、最大吞吐量、最大可靠性和最小消费四种数据包类型的，这4位有16种组合方式，也就对应了<code>priomap</code>的16位，每一位的数字对应这种数据包入哪个队列。（对于FIFO的算法原理这里不做赘述）</p>
<p>这种队列规则会引入<code>bufferbloat</code>问题，试想如下场景：<br>前端一次性传来10000个请求，这些请求进入队列后，服务器的处理速度跟不上请求的速度，这就会导致在队列后半部分中的请求超时，而超时后可能再进行重试，同时前端还在源源不断的发送请求，这就会导致服务器负载很高，但是却不能正常的返回请求，因为处理的都是超时请求。因此，linux内核引入了AQM(主动队列管理)机制，来避免<code>bufferbloat</code>。</p>
<h4 id="RED"><a href="#RED" class="headerlink" title="RED"></a>RED</h4><p><code>RED</code>算法通过监控队列长度来探测是否有拥塞，一旦发现开始拥塞，就会以某种概率从队列中开始丢弃请求。<br>其中有几个关键参数：</p>
<ul>
<li>min：最小队列长度；</li>
<li>max：最大队列长度；</li>
<li>probability：可能性，百分数；</li>
</ul>
<p>其工作原理如下：<br>RED对目前的队列状态计算平均队列长度</p>
<ol>
<li>队列长度小于min时，队列无压力，正常处理；</li>
<li>队列长度小于max时，队列开始有压力，根据<code>P = probability * (平均队列长度 － min)/(max － min)</code>根据可能性P对数据包进行丢弃；</li>
<li>队列长度大于max时，新入队的数据包也会被丢弃；</li>
</ol>
<p>配置方式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qd add dev eth1 root red <span class="built_in">limit</span> 200000 min 20000 max 40000 avpkt 1000 burst 1000 ecn adaptive bandwidth 5Mbit</span><br></pre></td></tr></table></figure>
<p>对其中的参数进行解析：</p>
<ul>
<li><code>limit</code>:此队列的字节数硬限制，一般limit的长度不小于max + burst</li>
<li><code>min</code>:最小队列长度；</li>
<li><code>max</code>:最大队列长度；</li>
<li><code>avpkt</code>:平均包长度，根据这个参数计算平均队列长度，一般建议设置成1000；</li>
<li><code>burst</code>:可以容纳的爆发流量，这个值设置的越高，那么平均队列长度的计算敏感度就约小，变化速度将会变慢，反之变快；</li>
<li><code>ecn</code>:当RED检测到拥塞都是通过标记数据包的ecn字段来通知数据源端减少数据发送量，并且在实际队列长度达到limit限制之前丢不会丢弃数据包；</li>
<li><code>adaptive</code>:开启智能probability参数选择，当平均队列长度超过(max-min)&#x2F;2时，RED会动态的根据情况让probability的值在1%到50%之间变化；</li>
<li><code>bandwidth</code>:用于在网络空闲的时候计算平均队列长度的参数，应配置成网络的实际带宽大小；</li>
</ul>
<h4 id="CoDel-amp-fq-codel队列"><a href="#CoDel-amp-fq-codel队列" class="headerlink" title="CoDel &amp; fq_codel队列"></a>CoDel &amp; fq_codel队列</h4><h5 id="CoDel算法"><a href="#CoDel算法" class="headerlink" title="CoDel算法"></a>CoDel算法</h5><p>与RED算法不同，CoDel是通过数据包在队列中的驻留时间来进行控制。<br>首先来介绍两个参数：</p>
<ul>
<li><code>target time</code>：数据包驻留在队列中的目标时间，即目前队列中有5个数据包，处理一个需要1ms，那么新进入队列的数据包的驻留时间就是5ms；</li>
<li><code>interval time</code>：服务要求的最长响应时间；</li>
</ul>
<p>CoDel算法的原理如下：<br>当新数据包出队时，先判断对头的请求驻留时间是否大于<code>target time</code>，若不大于直接出队，若大于<code>target time</code>的请求维持了<code>interval time</code>这么长时间，则开始丢包，丢包的时间通过如下公式计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t（第一次取now，以后取上次的值） + interval / sqrt(count)）</span><br></pre></td></tr></table></figure>
<ul>
<li>其中count是丢包数量；</li>
</ul>
<p>配置方式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev eth1 root codel <span class="built_in">limit</span> 100 target 4ms interval 30ms ecn</span><br></pre></td></tr></table></figure>
<ul>
<li><code>limit</code>:队列长度上限，若超过这个长度，数据包将直接被丢弃；</li>
</ul>
<h5 id="fq-codel队列"><a href="#fq-codel队列" class="headerlink" title="fq_codel队列"></a>fq_codel队列</h5><p><code>fq_codel队列</code>会为每个需要使用网络的flow建立一个队列（默认1024个），队列间通过DRR算法进行调度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flow:根据源地址、源端口、目的地址、目的端口、协议类型的五元组，将一个远端的连接划分成唯一的flow</span><br></pre></td></tr></table></figure>
<p>介绍其调度过程前，先来讨论一个概念<code>deficit</code>，<code>deficit</code>的单位是字节数，可以理解为是一个关于该flow是否可以发送的阈值判断，除非有大于0的<code>deficit</code>，否则这个flow缓存的数据不能够发送。<br>其调度过程如下：<br>假设现在有A、B、C三个flow，<code>deficit</code>的初始值是300；</p>
<ol>
<li>开始A在队头，发送一次需要400字节，则此时的<code>deficit</code>变成-100；</li>
<li>接下来B、C发送一次需要200字节，则此时的<code>deficit</code>变成100；</li>
<li>接下来又来调度A，但此时<code>deficit</code>小于0，则不进行发送，<code>deficit</code>增加300，变成200；</li>
<li>调度B、C，发送数据，<code>deficit</code>变成-100；</li>
<li>调度A，现在可以发送数据了，<code>deficit</code>变成-200；<br>…..</li>
</ol>
<h4 id="SFQ随机公平队列"><a href="#SFQ随机公平队列" class="headerlink" title="SFQ随机公平队列"></a>SFQ随机公平队列</h4><p>SFQ使用将每个会话散列到有限的FIFO队列中，然后使用轮询的方式调度队列，以实现公平调度，同时会定时更改使用的散列算法来保证公平。</p>
<p>参数配置：</p>
<ul>
<li><code>perturb</code>:多少秒后重新配置一次散列算法。如果取消设置，散列算法将永远不会重新配置（不建议这样做）。10 秒应该是一个合适的值。</li>
<li><code>quantum</code>:一个流至少要传输多少字节后才切换到下一个队列。却省设置为一个最大包的长度(MTU 的大小)。不要设置这个数值低于 MTU！</li>
<li><code>redflowlimit</code>:用来限制在RED模式下的SFQ的每个队列的字节数上限。</li>
<li><code>depth</code>:限制每一个队列的深度（长度），默认值127，只能减少，单位包个数</li>
</ul>
<p>一般将SFQ随机公平队列和RED搭配使用，使用RED来调度单个队列中的请求，来避免bufferbloat，队列间使用SFQ随机公平队列进行调度，来保证公平，SFQ随机公平队列和RED的对应关系更像是前面介绍的CoDel算法和fq_codel队列。<br><img src="/linux%E5%86%85%E6%A0%B8.resources/sfq.png" alt="sfq"></p>
<h4 id="TBF队列"><a href="#TBF队列" class="headerlink" title="TBF队列"></a>TBF队列</h4><p>使用TBF队列可以实现限流，其使用令牌桶进行限流。<br><img src="/linux%E5%86%85%E6%A0%B8.resources/tbf.png" alt="tbf"></p>
<p>按照固定速率，向token队列中写入虚拟数据，当数据包到来时，若token队列中有元素，则删除一个元素同时处理一个数据包，对于数据包的到来和虚拟数据的产生速率有以下三种对应关系：</p>
<ol>
<li>数据包到来的速率等于虚拟数据的产生速率，则无延时，直接对数据进行处理；</li>
<li>数据包到来的速率小于虚拟数据的产生速率，token队列中的元素会进行累积，可以应对短暂的流量突增；</li>
<li>数据包到来的速率大于虚拟数据的产生速率，数据包会在队列中等待，等待令牌到来时才能继续处理，若数据包队列满了还有数据到来，会导致丢包；</li>
</ol>
<h4 id="HTB队列"><a href="#HTB队列" class="headerlink" title="HTB队列"></a>HTB队列</h4><p>在有如下需求时，使用HTB的层级化方式进行配置很适用：</p>
<ul>
<li>有一个固定总带宽，想将其分割成几个部分，分别用作不同目的</li>
<li>每个部分的带宽是有保证的（guaranteed bandwidth）</li>
<li>还可以指定每个部分向其他部分借带宽</li>
</ul>
<p>其配置过程需要使用到两个概念：</p>
<ul>
<li><code>class</code>：对数据包进行分类；</li>
<li><code>filter</code>：使用过滤器将数据包放入设定好的类内；</li>
</ul>
<p><img src="/linux%E5%86%85%E6%A0%B8.resources/htb.png" alt="htb"></p>
<p>其配置过程如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tc qd del dev eth1 root</span><br><span class="line">tc qd add dev eth1 root handle 1: htb default 20</span><br><span class="line">tc cl add dev eth1 parent 1: classid 1:1 htb rate 3000mbit burst 20k</span><br><span class="line">tc cl add dev eth1 parent 1:1 classid 1:10 htb rate 1000mbit burst 20k</span><br><span class="line">tc cl add dev eth1 parent 1:1 classid 1:10 htb rate 3000mbit burst 20k</span><br><span class="line"><span class="comment"># tc qd add dev eth1 parent 1:10 handle 10: netem delay 200ms loss random 1</span></span><br><span class="line">tc qd add dev eth1 parent 1:10 handle 10: netem delay 10ms</span><br><span class="line"><span class="comment"># tc qd add dev eth1 parent 1:10 handle 10: fq_codel</span></span><br><span class="line">tc qd add dev eth1 parent 1:20 handle 20: fq_codel</span><br><span class="line"><span class="comment"># tc qd add dev eth1 parent 1:20 handle 20: netem delay 5ms</span></span><br><span class="line">tc <span class="keyword">fi</span> add dev eth1 protocol ip parent 1:0 prio 1 u32 match ip sport 80 0Xffff flowid 1:10</span><br></pre></td></tr></table></figure>
<p>可以通过如上的指令来模拟一些网络延迟的场景。</p>
<h3 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h3><p>在之前的文章中已经讨论了关于tcp的一些基础概念<a target="_blank" rel="noopener" href="http://localhost:4000/2023/06/06/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/#more">《网络编程的一些思考》</a>，我们再来串一下思路。<br>先来看<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">TCP</a>的定义，一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<ul>
<li>面向连接：在一个连接中传输的数据是有关系状态的，比如需要确定传输的对端正处在等待发送或接收的状态上。</li>
<li>可靠：数据在传输过程中不会被损坏或者丢失，保证数据可以正确到达。</li>
</ul>
<p><strong>面向连接的实现</strong><br>通过建立连接、传输数据、断开连接来维护一个长期的数据传输机制。<br>这时就需要<code>seq</code>来实现数据包的按序接收，通过<code>syn</code>、<code>ack</code>、<code>fin</code>、<code>rst</code>来实现特殊包的标记。<br><strong>可靠性的实现</strong><br>通过基于<code>ack</code>的停止等待协议来保证数据包的可靠，但是由于引入了停止等待协议，可能会引起带宽的利用不充分。因此，tcp又引入了滑动窗口和窗口确认机制。<br><strong>滑动窗口</strong><br>发送方：</p>
<ul>
<li>窗口左边界：已发送且收到确认ack的偏移量；</li>
<li>窗口右边界：已发送但未收到确认ack的偏移量；</li>
</ul>
<p>接收方：（给发送方回复ack时，ack中会有接收方的窗口大小，方便发送方调整窗口大小）</p>
<ul>
<li>窗口左边界：已接收并确认的偏移量；</li>
<li>窗口右边界：接收后会保存的窗口大小；</li>
</ul>
<p>引入滑动窗口后带宽得到了充分的利用，但是由于网络环境的波动，可能会导致数据包的堵塞，因此，引入了拥塞控制。<br><strong>拥塞控制</strong><br>拥塞控制本质上就是通过调整滑动窗口的大小来实现的。在接受端引入一个新的变量叫做cwnd：拥塞窗口，来反应当前网络的传输能力，而之前的接收窗口可以表示为awnd。此时发送端实际可用的窗口为cwnd和awnd的较小者。</p>
<p>下面我们从tcp建立连接到断开连接，按照时间顺序讨论一下各个环节。</p>
<h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p>连接：在一个连接中传输的数据是有关系状态的，比如需要确定传输的对端正处在等待发送或接收的状态上。需要维护传输数据的关系，比如数据流的顺序。典型的例子就是打电话。</p>
<p>无连接：不用关心对端是否在线。每一个数据段的发送都是独立的一个数据个体，数据和数据之间没有关系，无需维护其之间的关系。典型的例子就是发短信。<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="tcp三次握手"></p>
<h5 id="三次握手的作用"><a href="#三次握手的作用" class="headerlink" title="三次握手的作用"></a>三次握手的作用</h5><p>三次握手的作用如下：</p>
<ol>
<li>确认对方是否可以正常提供服务；</li>
<li>协商传输数据的起始编号</li>
</ol>
<p>首先来看一个抓包数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos /data/home/bankren]<span class="comment"># tcpdump -i eth1 -nn port 8888</span></span><br><span class="line">20:50:58.424187 IP 10.78.28.27.53907 &gt; 9.134.236.124.8888: Flags [S], <span class="built_in">seq</span> 1417591877, win 65535, options [mss 1250,nop,wscale 6,nop,nop,TS val 873400179 ecr 0,sackOK,eol], length 0</span><br><span class="line">20:50:58.424227 IP 9.134.236.124.8888 &gt; 10.78.28.27.53907: Flags [S.], <span class="built_in">seq</span> 1665603211, ack 1417591878, win 65160, options [mss 1460,sackOK,TS val 4144792010 ecr 873400179,nop,wscale 7], length 0</span><br><span class="line">20:50:58.468466 IP 10.78.28.27.53907 &gt; 9.134.236.124.8888: Flags [.], ack 1, win 2050, options [nop,nop,TS val 873400224 ecr 4144792010]</span><br></pre></td></tr></table></figure>
<p>这是一次完整的三次握手，其中：</p>
<ul>
<li>Flags [S]：该数据包是SYN；</li>
<li>seq 1417591877：seq序列号1417591877；</li>
<li>win 65535：接收窗口大小65535；</li>
<li>mss 1250：mss，最大报文长度1250；</li>
<li>wscale 6：窗口缩放因子 6，表示发送方可以发送多少数据而不需要等待确认；</li>
<li>S val 873400179 ecr 0：时间戳；</li>
</ul>
<p>这里有一个经典的问题，如果服务端A，在收到客户端B发来的syn之后，并且回复了syn+ack之后，收到了从另一个客户端C发来的ack包，请问此时服务端A会跟C建立后续的ESTABLISHED连接吗？</p>
<p>答案是不会的，当接收到tcp数据包时，内核会先在established中进行查找，若查找到则进行数据接收，若没查到则去listener中进行查询，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *__<span class="title">inet_lookup</span>(<span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>,</span></span><br><span class="line"><span class="class">					 <span class="keyword">struct</span> <span class="title">inet_hashinfo</span> *<span class="title">hashinfo</span>,</span></span><br><span class="line"><span class="class">					 <span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>, <span class="title">int</span> <span class="title">doff</span>,</span></span><br><span class="line"><span class="class">					 <span class="title">const</span> __<span class="title">be32</span> <span class="title">saddr</span>, <span class="title">const</span> __<span class="title">be16</span> <span class="title">sport</span>,</span></span><br><span class="line"><span class="class">					 <span class="title">const</span> __<span class="title">be32</span> <span class="title">daddr</span>, <span class="title">const</span> __<span class="title">be16</span> <span class="title">dport</span>,</span></span><br><span class="line"><span class="class">					 <span class="title">const</span> <span class="title">int</span> <span class="title">dif</span>, <span class="title">const</span> <span class="title">int</span> <span class="title">sdif</span>,</span></span><br><span class="line"><span class="class">					 <span class="title">bool</span> *<span class="title">refcounted</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	u16 hnum = ntohs(dport);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span></span><br><span class="line"></span><br><span class="line">	sk = __inet_lookup_established(net, hashinfo, saddr, sport,</span><br><span class="line">				       daddr, hnum, dif, sdif);</span><br><span class="line">	*refcounted = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (sk)</span><br><span class="line">		<span class="keyword">return</span> sk;</span><br><span class="line">	*refcounted = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> __inet_lookup_listener(net, hashinfo, skb, doff, saddr,</span><br><span class="line">				      sport, daddr, hnum, dif, sdif);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看下listener中的查找过程，可以看到是通过源地址、源端口、目的地址、目的端口来进行查找的，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *__<span class="title">inet_lookup_listener</span>(<span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>,</span></span><br><span class="line"><span class="class">				    <span class="keyword">struct</span> <span class="title">inet_hashinfo</span> *<span class="title">hashinfo</span>,</span></span><br><span class="line"><span class="class">				    <span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>, <span class="title">int</span> <span class="title">doff</span>,</span></span><br><span class="line"><span class="class">				    <span class="title">const</span> __<span class="title">be32</span> <span class="title">saddr</span>, __<span class="title">be16</span> <span class="title">sport</span>,</span></span><br><span class="line"><span class="class">				    <span class="title">const</span> __<span class="title">be32</span> <span class="title">daddr</span>, <span class="title">const</span> <span class="title">unsigned</span> <span class="title">short</span> <span class="title">hnum</span>,</span></span><br><span class="line"><span class="class">				    <span class="title">const</span> <span class="title">int</span> <span class="title">dif</span>, <span class="title">const</span> <span class="title">int</span> <span class="title">sdif</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_listen_hashbucket</span> *<span class="title">ilb2</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">result</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> hash2;</span><br><span class="line"></span><br><span class="line">	hash2 = ipv4_portaddr_hash(net, daddr, hnum);</span><br><span class="line">	ilb2 = inet_lhash2_bucket(hashinfo, hash2);</span><br><span class="line"></span><br><span class="line">	result = inet_lhash2_lookup(net, ilb2, skb, doff,</span><br><span class="line">				    saddr, sport, daddr, hnum,</span><br><span class="line">				    dif, sdif);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Lookup lhash2 with INADDR_ANY */</span></span><br><span class="line">	hash2 = ipv4_portaddr_hash(net, htonl(INADDR_ANY), hnum);</span><br><span class="line">	ilb2 = inet_lhash2_bucket(hashinfo, hash2);</span><br><span class="line"></span><br><span class="line">	result = inet_lhash2_lookup(net, ilb2, skb, doff,</span><br><span class="line">				    saddr, sport, htonl(INADDR_ANY), hnum,</span><br><span class="line">				    dif, sdif);</span><br><span class="line">done:</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(result))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端在SYN RECVED的状态下，要在缓存中纪录客户端syn包中的内容，以便在收包的过程中进行查找，也就是说服务端通过源地址、源端口、目的地址、目的端口的四元组来缓存客户端的半连接信息，这个缓存是有上限的，可以通过如下文件查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_max_syn_backlog</span><br></pre></td></tr></table></figure>
<p>当这个半连接队列剩余长度小于最大长度的1&#x2F;4后，就不再处理新的请求了，这也就是stnflood攻击的原理，可以通过synccookie来解决这个问题。</p>
<h5 id="syncookie"><a href="#syncookie" class="headerlink" title="syncookie"></a>syncookie</h5><p><code>syncookie</code>默认是打开的，可以通过如下指令进行配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_syncookies</span><br></pre></td></tr></table></figure>
<ul>
<li>0:关闭syncookie</li>
<li>1:默认值，代表打开syncookie功能，此时在tcp_max_syn_backlog上限被耗尽之后，新建的连接才会使用syncookie；</li>
<li>2:忽略tcp_max_syn_backlog半连接队列，直接使用syncookie</li>
</ul>
<p>syncflood攻击的原理是耗尽服务端的半连接队列，那把第一次握手得到的信息放到回包里，让客户端在第三次握手的时候再把这个信息带回来，然后我们拿到第三次握手的四元组信息和其中记录的信息做验证就可以解决这个问题了。<br>具体的做法是服务端将四元组信息和当前时间计算hash值，发送给客户端，客户端在第三次握手的时候将数据包带回来，然后服务端根据包中的四元组信息和带回来的hash信息进行对比，来判读是否是客户端的第三次握手。</p>
<h5 id="listen-backlog"><a href="#listen-backlog" class="headerlink" title="listen backlog"></a>listen backlog</h5><p>之前介绍<code>socket</code>时，有个第二个参数限制如果服务端处在LISTEN状态，并且有客户端建立连接，但是如果服务端没有及时accept新建连接的话，那么这种还未accpet的请求队列是多大。<br>官方解释如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 2 listen</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The backlog argument defines the maximum length to which the queue of pending connections for sockfd may grow.  If  a  connec‐tion  request  arrives  when  the queue is full, the client may receive an error with an indication of ECONNREFUSED or, if the underlying protocol supports retransmission, the request may be ignored so that a later reattempt at connection succeeds.</span><br></pre></td></tr></table></figure>
<p>这个值在内核中的上限配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内核中的上限</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/net/core/somaxconn </span><br></pre></td></tr></table></figure>
<p>下面我们来做个实验，研究一下<code>backlog</code>的影响，使用我们之前的<a target="_blank" rel="noopener" href="https://github.com/rh670892215/net_work/blob/main/tcp/hello_server.c">server</a>程序，在listen和accept之间加入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pause();</span><br></pre></td></tr></table></figure>
<p>阻塞住accept，客户端使用<code>telnet</code>进行连接。<br>首次连接可以看到可以正常的接受三次握手：<br><img src="/linux%E5%86%85%E6%A0%B8.resources/listenblock1.png" alt="listenblock1"><br>接着多建立几个连接：<br><img src="/linux%E5%86%85%E6%A0%B8.resources/listenblock2.png" alt="listenblock2"><br>可以看到前6个连接都可以正常握手，那再增加连接会如何呢？<br><img src="/linux%E5%86%85%E6%A0%B8.resources/listenblock3.png" alt="listenblock3"><br>通过抓包可以看到，这时客户端发送第一次握手，但是服务端已经拒绝服务了，可以看到客户端重试了5次，最后返回失败。<br>虽然我们可以通过<code>/proc/sys/net/core/somaxconn</code>来增加这个队列的上限，但是一般不建议调大这个值，如果因为这个值导致系统的性能出现瓶颈，应该扩容，而不是调大这个值，在这种情况下，有时甚至我们应该调小这个队列，并把客户端的syn重试次数减少，以便能够让客户端更快速的失败，防止连接积累过多导致雪崩。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意这里维护的“队列”，并不是前面说的半连接队列，这个通过抓包的数据可以看出来（前面列举的抓包例子就是这里建立连接的过程），可以看到这里已经成功完成了三次握手。而accept是将已经建立连接的socket转换成fd方便后续的数据读取和写入。</span><br></pre></td></tr></table></figure>

<p>可以通过如下的指令查看系统中的established队列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目前系统打开fd的情况；已经打开数、正在打开数、上限</span></span><br><span class="line">[root@VM-236-124-centos /var/www/html]<span class="comment"># cat /proc/sys/fs/file-nr </span></span><br><span class="line">2144    0       1608792</span><br><span class="line"><span class="comment"># 整个系统中打开的fd上限</span></span><br><span class="line">[root@VM-236-124-centos /var/www/html]<span class="comment"># cat /proc/sys/fs/file-max</span></span><br><span class="line">1608792</span><br></pre></td></tr></table></figure>

<h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><p>前面我们介绍过tcp的拥塞控制，而慢启动时tcp的一种拥塞控制算法，慢启动算法的目的是在TCP连接建立时逐渐增加发送窗口的大小，以便在网络拥塞时避免过多的数据包丢失。同时，慢启动也会给系统的性能产生影响，下面我们来看一个例子：</p>
<p>首先准备下服务端的服务器和数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos /var/www/html]<span class="comment"># pwd</span></span><br><span class="line">/var/www/html</span><br><span class="line">[root@VM-236-124-centos /var/www/html]<span class="comment"># ls</span></span><br><span class="line">output</span><br><span class="line"><span class="comment"># 这里准备500k的数据，传输测试使用</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=output bs=1M count=10</span><br></pre></td></tr></table></figure>
<p>启动服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos /var/www/html]<span class="comment"># service httpd start</span></span><br><span class="line">Redirecting to /bin/systemctl start httpd.service</span><br><span class="line">[root@VM-236-124-centos /var/www/html]<span class="comment"># ss -antp</span></span><br><span class="line">State       Recv-Q Send-Q                       Local Address:Port                                      Peer Address:Port              </span><br><span class="line">LISTEN      0      100                              127.0.0.1:42222                                                *:*                   <span class="built_in">users</span>:((&quot;TsysAgent&quot;,pid=<span class="number">8299</span>,fd=<span class="number">4</span>))</span><br><span class="line">LISTEN      0      128                                      *:36000                                                *:*                   <span class="built_in">users</span>:((&quot;sshd&quot;,pid=<span class="number">12541</span>,fd=<span class="number">3</span>))</span><br><span class="line">LISTEN      0      4096                                     *:48369                                                *:*                   <span class="built_in">users</span>:((&quot;TsysProxy&quot;,pid=<span class="number">18394</span>,fd=<span class="number">5</span>))</span><br><span class="line">ESTAB       0      0                            9.134.236.124:55148                                      9.151.52.38:9988                <span class="built_in">users</span>:((&quot;secu-tcs-agent&quot;,pid=<span class="number">31920</span>,fd=<span class="number">9</span>))</span><br><span class="line">ESTAB       0      0                            9.134.236.124:60578                                      9.134.205.9:9922                <span class="built_in">users</span>:((&quot;agent&quot;,pid=<span class="number">8823</span>,fd=<span class="number">3</span>))</span><br><span class="line">ESTAB       0      256                          9.134.236.124:36000                                      10.78.28.27:58449               <span class="built_in">users</span>:((&quot;sshd&quot;,pid=<span class="number">27014</span>,fd=<span class="number">3</span>),(&quot;sshd&quot;,pid=<span class="number">26975</span>,fd=<span class="number">3</span>))</span><br><span class="line">LISTEN      0      4096                                  [::]:8011                                              [::]:*                   <span class="built_in">users</span>:((&quot;rrnet_reciever&quot;,pid=<span class="number">17986</span>,fd=<span class="number">3</span>))</span><br><span class="line">LISTEN      0      4096                                  [::]:8013                                              [::]:*                   <span class="built_in">users</span>:((&quot;rrnet_reciever&quot;,pid=<span class="number">1686</span>,fd=<span class="number">3</span>))</span><br><span class="line">LISTEN      0      511                                   [::]:80                                                [::]:*                   <span class="built_in">users</span>:((&quot;httpd&quot;,pid=<span class="number">15186</span>,fd=<span class="number">4</span>),(&quot;httpd&quot;,pid=<span class="number">2987</span>,fd=<span class="number">4</span>),(&quot;httpd&quot;,pid=<span class="number">2675</span>,fd=<span class="number">4</span>),(&quot;httpd&quot;,pid=<span class="number">2674</span>,fd=<span class="number">4</span>),(&quot;httpd&quot;,pid=<span class="number">2673</span>,fd=<span class="number">4</span>),</span><br><span class="line">(&quot;httpd&quot;,pid=<span class="number">2672</span>,fd=<span class="number">4</span>),(&quot;httpd&quot;,pid=<span class="number">2671</span>,fd=<span class="number">4</span>),(&quot;httpd&quot;,pid=<span class="number">1453</span>,fd=<span class="number">4</span>),(&quot;httpd&quot;,pid=<span class="number">1402</span>,fd=<span class="number">4</span>))</span><br><span class="line">LISTEN      0      4096                                  [::]:9011                                              [::]:*                   <span class="built_in">users</span>:((&quot;rrnet_reciever&quot;,pid=<span class="number">17986</span>,fd=<span class="number">7</span>))</span><br><span class="line">LISTEN      0      4096                                  [::]:9013                                              [::]:*                   <span class="built_in">users</span>:((&quot;rrnet_reciever&quot;,pid=<span class="number">1686</span>,fd=<span class="number">7</span>))</span><br></pre></td></tr></table></figure>
<p>可以看到服务端有一个80端口的监听。<br>先来看一下两台机器之间的网络延时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ping 9.134.236.124</span><br><span class="line">PING 9.134.236.124 (9.134.236.124): 56 data bytes</span><br><span class="line">64 bytes from 9.134.236.124: icmp_seq=0 ttl=64 time=47.127 ms</span><br><span class="line">64 bytes from 9.134.236.124: icmp_seq=1 ttl=64 time=44.375 ms</span><br><span class="line">64 bytes from 9.134.236.124: icmp_seq=2 ttl=64 time=53.520 ms</span><br><span class="line">64 bytes from 9.134.236.124: icmp_seq=3 ttl=64 time=43.210 ms</span><br><span class="line">64 bytes from 9.134.236.124: icmp_seq=4 ttl=64 time=43.969 ms</span><br><span class="line">^C</span><br><span class="line">--- 9.134.236.124 ping statistics ---</span><br><span class="line">5 packets transmitted, 5 packets received, 0.0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 43.210/46.440/53.520/3.779 ms</span><br></pre></td></tr></table></figure>
<p>正常情况下，下载这个10MB文件需要1.5s至2s的时间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  tets_output wget http://9.134.236.124:80/output</span><br><span class="line">--2023-07-25 17:44:46--  http://9.134.236.124/output</span><br><span class="line">正在连接 9.134.236.124:80... 已连接。</span><br><span class="line">已发出 HTTP 请求，正在等待回应... 200 OK</span><br><span class="line">长度：10485760 (10M)</span><br><span class="line">正在保存至: “output.22”</span><br><span class="line"></span><br><span class="line">output.22           100%[===================&gt;]  10.00M  6.47MB/s  用时 1.5s    </span><br><span class="line"></span><br><span class="line">2023-07-25 17:44:47 (6.47 MB/s) - 已保存 “output.22” [10485760/10485760])</span><br><span class="line"></span><br><span class="line">➜  tets_output wget http://9.134.236.124:80/output</span><br><span class="line">--2023-07-25 17:44:49--  http://9.134.236.124/output</span><br><span class="line">正在连接 9.134.236.124:80... 已连接。</span><br><span class="line">已发出 HTTP 请求，正在等待回应... 200 OK</span><br><span class="line">长度：10485760 (10M)</span><br><span class="line">正在保存至: “output.23”</span><br><span class="line"></span><br><span class="line">output.23           100%[===================&gt;]  10.00M  5.58MB/s  用时 1.8s    </span><br><span class="line"></span><br><span class="line">2023-07-25 17:44:51 (5.58 MB/s) - 已保存 “output.23” [10485760/10485760])</span><br></pre></td></tr></table></figure>
<p>接下来在服务端添加一个200ms的延时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qd add dev eth1 root netem delay 200ms</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  tets_output wget http://9.134.236.124:80/output</span><br><span class="line">--2023-07-25 17:45:37--  http://9.134.236.124/output</span><br><span class="line">正在连接 9.134.236.124:80... 已连接。</span><br><span class="line">已发出 HTTP 请求，正在等待回应... 200 OK</span><br><span class="line">长度：10485760 (10M)</span><br><span class="line">正在保存至: “output.25”</span><br><span class="line"></span><br><span class="line">output.25           100%[===================&gt;]  10.00M  2.91MB/s  用时 3.4s    </span><br><span class="line"></span><br><span class="line">2023-07-25 17:45:41 (2.91 MB/s) - 已保存 “output.25” [10485760/10485760])</span><br><span class="line"></span><br><span class="line">➜  tets_output wget http://9.134.236.124:80/output</span><br><span class="line">--2023-07-25 17:45:49--  http://9.134.236.124/output</span><br><span class="line">正在连接 9.134.236.124:80... 已连接。</span><br><span class="line">已发出 HTTP 请求，正在等待回应... 200 OK</span><br><span class="line">长度：10485760 (10M)</span><br><span class="line">正在保存至: “output.26”</span><br><span class="line"></span><br><span class="line">output.26           100%[===================&gt;]  10.00M  2.71MB/s  用时 3.7s    </span><br><span class="line"></span><br><span class="line">2023-07-25 17:45:53 (2.71 MB/s) - 已保存 “output.26” [10485760/10485760])</span><br></pre></td></tr></table></figure>
<p>可以看到，增加200ms延时后，下载时间增加了1倍，不仅仅是单纯的增加了200ms的延时。<br>我们来抓包查看一下数据传输的过程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">18:06:32.905293 IP 10.99.131.29.40764 &gt; 9.134.236.124.80: Flags [S], <span class="built_in">seq</span> 2630578275, win 64240, options [mss 1424,sackOK,TS val 1518953416 ecr 0,nop,wscale 7], length 0</span><br><span class="line">18:06:32.905313 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [S.], <span class="built_in">seq</span> 3361084710, ack 2630578276, win 65160, options [mss 1460,sackOK,TS val 1729617360 ecr 1518953416,nop,wscale 7], length 0</span><br><span class="line">18:06:32.958079 IP 10.99.131.29.40764 &gt; 9.134.236.124.80: Flags [.], ack 1, win 502, options [nop,nop,TS val 1518953469 ecr 1729617360], length 0</span><br><span class="line"><span class="comment"># 三次握手结束，建立连接</span></span><br><span class="line">18:06:32.959831 IP 10.99.131.29.40764 &gt; 9.134.236.124.80: Flags [P.], <span class="built_in">seq</span> 1:981, ack 1, win 502, options [nop,nop,TS val 1518953471 ecr 1729617360], length 980: HTTP: GET /output HTTP/1.1</span><br><span class="line">18:06:32.959850 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], ack 981, win 502, options [nop,nop,TS val 1729617414 ecr 1518953471], length 0</span><br><span class="line">18:06:32.960038 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 1:1413, ack 981, win 502, options [nop,nop,TS val 1729617414 ecr 1518953471], length 1412: HTTP: HTTP/1.1 200 OK</span><br><span class="line">18:06:32.960043 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 1413:2825, ack 981, win 502, options [nop,nop,TS val 1729617414 ecr 1518953471], length 1412: HTTP</span><br><span class="line">18:06:32.960058 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 2825:4237, ack 981, win 502, options [nop,nop,TS val 1729617414 ecr 1518953471], length 1412: HTTP</span><br><span class="line">18:06:32.960064 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 4237:5649, ack 981, win 502, options [nop,nop,TS val 1729617414 ecr 1518953471], length 1412: HTTP</span><br><span class="line">18:06:32.960119 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 5649:7061, ack 981, win 502, options [nop,nop,TS val 1729617415 ecr 1518953471], length 1412: HTTP</span><br><span class="line">18:06:32.960123 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 7061:8473, ack 981, win 502, options [nop,nop,TS val 1729617415 ecr 1518953471], length 1412: HTTP</span><br><span class="line">18:06:32.960144 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 8473:9885, ack 981, win 502, options [nop,nop,TS val 1729617415 ecr 1518953471], length 1412: HTTP</span><br><span class="line">18:06:32.960151 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 9885:11297, ack 981, win 502, options [nop,nop,TS val 1729617415 ecr 1518953471], length 1412: HTTP</span><br><span class="line">18:06:32.960155 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 11297:12709, ack 981, win 502, options [nop,nop,TS val 1729617415 ecr 1518953471], length 1412: HTTP</span><br><span class="line">18:06:32.960162 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 12709:14121, ack 981, win 502, options [nop,nop,TS val 1729617415 ecr 1518953471], length 1412: HTTP</span><br><span class="line">18:06:33.012699 IP 10.99.131.29.40764 &gt; 9.134.236.124.80: Flags [.], ack 1413, win 501, options [nop,nop,TS val 1518953524 ecr 1729617414], length 0</span><br><span class="line"><span class="comment"># 等待ack，已传输数据：12708</span></span><br><span class="line">18:06:33.012710 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 14121:15533, ack 981, win 502, options [nop,nop,TS val 1729617467 ecr 1518953524], length 1412: HTTP</span><br><span class="line">18:06:33.012714 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 15533:16945, ack 981, win 502, options [nop,nop,TS val 1729617467 ecr 1518953524], length 1412: HTTP</span><br><span class="line">18:06:33.012737 IP 10.99.131.29.40764 &gt; 9.134.236.124.80: Flags [.], ack 2825, win 494, options [nop,nop,TS val 1518953524 ecr 1729617414], length 0</span><br><span class="line"><span class="comment"># 等待ack，已传输数据：15532</span></span><br><span class="line">18:06:33.012741 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 16945:18357, ack 981, win 502, options [nop,nop,TS val 1729617467 ecr 1518953524], length 1412: HTTP</span><br><span class="line">18:06:33.012749 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 18357:19769, ack 981, win 502, options [nop,nop,TS val 1729617467 ecr 1518953524], length 1412: HTTP</span><br><span class="line">18:06:33.012858 IP 10.99.131.29.40764 &gt; 9.134.236.124.80: Flags [.], ack 5649, win 494, options [nop,nop,TS val 1518953524 ecr 1729617414], length 0</span><br><span class="line"><span class="comment"># 等待ack，已传输数据：16944</span></span><br><span class="line">18:06:33.012869 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 19769:21181, ack 981, win 502, options [nop,nop,TS val 1729617467 ecr 1518953524], length 1412: HTTP</span><br><span class="line">18:06:33.012873 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 21181:22593, ack 981, win 502, options [nop,nop,TS val 1729617467 ecr 1518953524], length 1412: HTTP</span><br><span class="line">18:06:33.012880 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 22593:24005, ack 981, win 502, options [nop,nop,TS val 1729617467 ecr 1518953524], length 1412: HTTP</span><br><span class="line">18:06:33.012892 IP 10.99.131.29.40764 &gt; 9.134.236.124.80: Flags [.], ack 14121, win 440, options [nop,nop,TS val 1518953524 ecr 1729617415], length 0</span><br><span class="line"><span class="comment"># 等待ack，已传输数据：18356</span></span><br><span class="line">18:06:33.012902 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [P.], <span class="built_in">seq</span> 24005:25417, ack 981, win 502, options [nop,nop,TS val 1729617467 ecr 1518953524], length 1412: HTTP</span><br><span class="line">18:06:33.012919 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 25417:26829, ack 981, win 502, options [nop,nop,TS val 1729617467 ecr 1518953524], length 1412: HTTP</span><br><span class="line">18:06:33.012922 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 26829:28241, ack 981, win 502, options [nop,nop,TS val 1729617467 ecr 1518953524], length 1412: HTTP</span><br><span class="line">18:06:33.012936 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 28241:29653, ack 981, win 502, options [nop,nop,TS val 1729617467 ecr 1518953524], length 1412: HTTP</span><br><span class="line">18:06:33.012946 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 29653:31065, ack 981, win 502, options [nop,nop,TS val 1729617467 ecr 1518953524], length 1412: HTTP</span><br><span class="line">18:06:33.012954 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 31065:32477, ack 981, win 502, options [nop,nop,TS val 1729617467 ecr 1518953524], length 1412: HTTP</span><br><span class="line">18:06:33.012968 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 32477:33039, ack 981, win 502, options [nop,nop,TS val 1729617467 ecr 1518953524], length 562: HTTP</span><br><span class="line">18:06:33.012973 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 33039:34451, ack 981, win 502, options [nop,nop,TS val 1729617467 ecr 1518953524], length 1412: HTTP</span><br><span class="line">18:06:33.012980 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 34451:35863, ack 981, win 502, options [nop,nop,TS val 1729617467 ecr 1518953524], length 1412: HTTP</span><br><span class="line">18:06:33.012995 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 35863:37135, ack 981, win 502, options [nop,nop,TS val 1729617467 ecr 1518953524], length 1272: HTTP</span><br><span class="line">18:06:33.012999 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 37135:38547, ack 981, win 502, options [nop,nop,TS val 1729617467 ecr 1518953524], length 1412: HTTP</span><br><span class="line">18:06:33.013010 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 38547:39959, ack 981, win 502, options [nop,nop,TS val 1729617467 ecr 1518953524], length 1412: HTTP</span><br><span class="line">18:06:33.013019 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], <span class="built_in">seq</span> 39959:41371, ack 981, win 502, options [nop,nop,TS val 1729617467 ecr 1518953524], length 1412: HTTP</span><br><span class="line"><span class="comment"># 等待ack，已传输数据：27250</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>可以看到tcp慢启动的过程，每次连续发送数据的长度是以2的指数倍数增长的，而每次等待ack的时候就会因为网络延时而等待一段时间，也正是这个慢启动的过程导致了文件的实际传输时间远远大于我们之前设置的网络延时时间。<br>对于这个窗口的大小是两方进行协商确定的，双方会根据自己服务器的状态来通告自己的接受窗口长度给对方，这个值叫做rwnd。但是对于一个刚刚开始的TCP来说，可能还来不及跟对方协商窗口长度就需要发送数据，所以TCP会选择以一个比较小的发送窗口来开始数据传输，并且根据数据的发送和确认状态来动态增长这个窗口，这个一开始确定的窗口长度叫做cwnd。<br>那么这个cwnd的初始值是多少呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__u32 <span class="title function_">tcp_init_cwnd</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tcp_sock *tp, <span class="type">const</span> <span class="keyword">struct</span> dst_entry *dst)</span></span><br><span class="line">&#123;</span><br><span class="line">	__u32 cwnd = (dst ? dst_metric(dst, RTAX_INITCWND) : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cwnd)</span><br><span class="line">		cwnd = TCP_INIT_CWND;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">min_t</span>(__u32, cwnd, tp-&gt;snd_cwnd_clamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* TCP initial congestion window as per rfc6928 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_INIT_CWND		10</span></span><br></pre></td></tr></table></figure>
<p>通过上面的源码可以看到初始大小是10，这也叫对应了抓包中的数据，一次性传输了10个数据包的数据。</p>
<p>可以通过调大两端的起始cwnd窗口大小来避免这个问题，窗口的大小存储在下面这个文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_init_cwnd</span><br></pre></td></tr></table></figure>
<p>可以接着思考一下这个问题，当数据包很小，一个数据包即可传输完毕，小于1412字节，那么不会有上述的问题，同时若数据包很大几百M或几G的文件传输，同样慢启动的过程不会成为性能瓶颈，此时的瓶颈同样是网络延时，只有当数据包不大不小的时候才会有这种问题。</p>
<p>同样，慢启动的问题也会影响tcp的长连接。Linux默认对于一个空闲的tcp连接会重置其窗口长度。就是说，如果你的tcp连接曾经传过数据，窗口已经自适应到比较大了，这时如果连接空闲下来，不传数据，那么后续再传数据就会重新进行slowstart的过程。其开关如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tcp长连接慢启动开关，若打开，tcp连接在200ms内若没有数据首发就判定成是空闲的，下一次再进行收发数据则重新开始慢启动</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_slow_start_after_idle</span><br><span class="line"><span class="comment"># 默认是1，默认打开</span></span><br></pre></td></tr></table></figure>
<h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>首先来讨论一下什么是socket的缓存。<br>发送端的缓存通常称为<code>发送缓存（Send Buffer）</code>，用于存储待发送的数据。当应用程序向TCP发送数据时，TCP会将这些数据存储在发送缓存中，并逐个将数据发送出去。如果发送缓存已满，则TCP会阻塞应用程序，直到有足够的空间来存储新的数据。<br>接收端的缓存通常称为<code>接收缓存（Receive Buffer）</code>，用于存储接收到的数据。当TCP接收到数据时，会将这些数据存储在接收缓存中，并通知应用程序有新的数据到达。如果接收缓存已满，则TCP会丢弃一部分数据，以确保接收缓存不会溢出。<br>再来看下发送缓存和滑动窗口的关系：<br><img src="/linux%E5%86%85%E6%A0%B8.resources/%E5%8F%91%E9%80%81%E7%BC%93%E5%AD%98.png" alt="发送缓存"><br>接收缓存和滑动窗口的关系：<br><img src="/linux%E5%86%85%E6%A0%B8.resources/%E6%8E%A5%E6%94%B6%E7%BC%93%E5%AD%98.png" alt="接收缓存"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-236-124-centos /var/www/html]<span class="comment"># cat /proc/sys/net/ipv4/tcp_mem </span></span><br><span class="line">187995  250661  375990</span><br><span class="line">[root@VM-236-124-centos /var/www/html]<span class="comment"># cat /proc/sys/net/ipv4/tcp_rmem </span></span><br><span class="line">4096    131072  6291456</span><br><span class="line">[root@VM-236-124-centos /var/www/html]<span class="comment"># cat /proc/sys/net/ipv4/tcp_wmem </span></span><br><span class="line">4096    16384   4194304</span><br></pre></td></tr></table></figure>
<p>文件中的三个值分别是：</p>
<ul>
<li>min：tcp socket buffer的最小长度；</li>
<li>default：默认长度；</li>
<li>max：最大长度；</li>
</ul>
<p>在一个tcp链接中，对应的buffer长度将在min和max之间变化。导致变化的主要因素是当前内存压力。如果使用setsockopt设置了对应buffer长度的话，这个值将被忽略。相当于关闭了tcp buffer的动态调整，使用 setsockopt 设置对应buffer长度的时候，实际生效的值将是设置值的2倍。</p>
<p>在延时比较大的网络环境中，缓存对传输性能会产生影响。当网络延时大时，发送方发送的数据得不到及时的ack，而接受端的读缓存会收到发送端剩余写缓存的影响，由于长时间收不到ack，发送端的写缓存会缩小，这也就导致接收端的缓存同步减小，从而带宽得不到充分的利用。<br>那么我们要解决的问题是如何充分利用网络带宽，其实就是在等待对方返回ack前，尽可能错的发送数据，使用数据将等待网络延时这段时间填满，中间不会出现等待ack而发送端不发送数据的情况。<br>这样发送端的写缓存大小可以配置成<code>带宽 * 延时</code>的值，如带宽1000Mbit&#x2F;s，rtt（往返延时）时间400ms，那么缓存应该调整成大约50Mbyte左右。<br>但是这种调整方式仅仅是适用于延时大但丢包不明显的情况，当丢包比较频繁时，性能的瓶颈就不再只受缓存的影响了，同时也受到丢包后的快速恢复和慢启动过程，这时就需要调整拥塞控制算法来调整系统的性能。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看内核支持哪些拥塞避免算法</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_available_congestion_control</span><br><span class="line"><span class="comment"># 查看使用哪种拥塞避免算法</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_congestion_control</span><br></pre></td></tr></table></figure>
<p>我们可以使用bbr拥塞避免算法，其原理是： 不再试探窗口大小，而是直接进行计算，<code>管道容量=带宽 * RTT</code>, 动态根据带宽与延时计算窗口, 在大延时网络性能更好。</p>
<h4 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h4><p>tcp4次挥手<br><img src="/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.resources/tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="tcp四次挥手"><br>有一个经典的问题，tcp一定要四次挥手吗？先来看下面的抓包数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">18:06:38.829883 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [F.], <span class="built_in">seq</span> 10486031, ack 981, win 502, options [nop,nop,TS val 1729623284 ecr 1518954677], length 0</span><br><span class="line">18:06:38.882206 IP 10.99.131.29.40764 &gt; 9.134.236.124.80: Flags [F.], <span class="built_in">seq</span> 981, ack 10486032, win 23086, options [nop,nop,TS val 1518959393 ecr 1729623284], length 0</span><br><span class="line">18:06:38.882219 IP 9.134.236.124.80 &gt; 10.99.131.29.40764: Flags [.], ack 982, win 502, options [nop,nop,TS val 1729623337 ecr 1518959393], length 0</span><br></pre></td></tr></table></figure>
<p>可以看到这里只进行了三次挥手，中间两步的ack和FIN被合并成了一步，linux内核有延迟发送ack的机制，在接收关闭信号并确认没有数据要发往对方时，会将ack和FIN合并进行发送，具体的合并时机和机制需要进一步的进行研究。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/dog250/article/details/52664508">传送门</a><br>这里只说结论，内核有一个机制可以自动识别当前是否是pingpong场景（完全交互场景），从而依据这个判断来自动开启或关闭delay ack。<br>也就是说，当内核检测到两方正在进行数据交互，会将ack和数据发送合并成一个数据包，一并发给对方。如果tcp接受端在收到数据的ATO内检测到自身也发送了数据，那么就会讲pingpong设置成1，后续就可以走delay ack的逻辑了。反之若tcp接受端发现超过ATO都没有发送数据，就会将pingpong设置成0。ATO默认时间是40ms，会动态调整。<br>此外，不仅是在上述场景的时候才需要delay ack，有时就算pingpong是0，已经判定成非交互模式，同样需要启用delay ack。<br>当接受端内存吃紧的时候，会希望发送端慢一点发送数据，这种情况下需要启用delay ack。<br>linux内核为delay ack维护了一个计数器QUICK，pingpong&#x3D;0时，当QUICK持有配额（不等于0）时，该即时ack才会发送出去，否则该ack会delay。<br>QUICK计数器的增加情况如下：</p>
<ol>
<li>连接初始化时，第一次接收数据，为照顾慢启动，将QUICK配额增加到最多16个段；</li>
<li>当自动上一次接收到数据到现在又接收到数据间隔较久时，将QUICK配额增加到最多16个段；</li>
<li>当接受端窗口缩减时，将QUICK的配额清零；</li>
<li>当接受端窗口小于接受端缓存一半时，将QUICK的配额清零；</li>
</ol>
<p>下面对各个阶段的状态分别进行讨论。</p>
<h5 id="FIN-WAIT1"><a href="#FIN-WAIT1" class="headerlink" title="FIN_WAIT1"></a>FIN_WAIT1</h5><p>主动关闭连接的一方在发送FIN后会进入FIN_WAIT1状态，一般情况下，这个状态会维持一个rtt左右，但是若对方出现bug或恶意攻击未及时回传ack，可能会导致这个状态维持比较久的时间。这时，重启应用程序并不能解决问题，因为此时应用程序已经认为tcp已经关闭连接，后续的处理过程是内核行为，不关联应用程序。而内核维护这种tcp连接需要消耗内存，因此如果这种状态的连接多了会产生针对内存的Dos攻击。</p>
<p>可以通过下面的文件查看内核中维护FIN_WAIT1状态的上限，这个值一般是内核根据内存动态调整的，一般不需要修改。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看内核中维护FIN_WAIT1状态的上限</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_max_orphans</span><br></pre></td></tr></table></figure>
<p>FIN_WAIT1的等待时长与FIN的重试次数有关，内核中可以通过下面的文件进行配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_orphan_retries</span><br></pre></td></tr></table></figure>
<p>默认值是0，若使用默认值，内核会重试8次，间隔时间会以<code>TCP_RTO_MIN</code>为单位以2的指数增长，<code>TCP_RTO_MIN</code>在内核中被设置成200ms。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_RTO_MIN	((unsigned)(HZ/5))</span></span><br></pre></td></tr></table></figure>
<p>每次重试间隔如下：<br>第一次重试：200 X 2^0 &#x3D; 200ms<br>第二次重试：200 X 2^1 &#x3D; 400ms<br>第三次重试：200 X 2^2 &#x3D; 800ms<br>第四次重试：200 X 2^3 &#x3D; 1600ms<br>…</p>
<h5 id="FIN-WAIT2"><a href="#FIN-WAIT2" class="headerlink" title="FIN_WAIT2"></a>FIN_WAIT2</h5><p>主动关闭方在接受到FIN的ack后会进入FIN_WAIT2状态，等待对方发送的FIN，接收到FIN并恢复ack后进入TIME_WAIT状态。在FIN_WAIT2状态下不会发送数据，但是会接收数据，FIN_WAIT2状态也有超时限制，通过如下文件查看，默认是60s：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_fin_timeout</span><br></pre></td></tr></table></figure>
<p>进一步研究：<a target="_blank" rel="noopener" href="https://blog.csdn.net/dog250/article/details/81256550">传送门</a><br>这里只说结论，FIN_WAIT2状态超时后，主动关闭方不会给对方传递任何消息，不会发送reset，也不会进入TIME_WAIT状态，连接直接消失。</p>
<h5 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h5><p>这个状态的目的是为了保证对方可以收到最后的ack，可以接受fin重传ack。<br>一般这个状态的时间是2MSL（一个数据分片在网络中能够生存的最长时间），谁先close谁就会先进入TIME_WAIT状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_TIMEWAIT_LEN (60*HZ) <span class="comment">/* how long to wait to destroy TIME-WAIT</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                  * state, about 60 seconds     */</span></span></span><br></pre></td></tr></table></figure>
<p>linux内核中这个状态的时间设置成60s。如果服务器上的TIME_WAIT状态过多会耗尽端口号、消耗内存、消耗cpu。端口号的上限是65525.<br>可以通过如下几种方式解决这个问题：</p>
<ol>
<li>重用端口；</li>
<li>限制TIME_WAIT状态的最大连接数；</li>
<li>直接发送reset断开连接；</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重用TIME_WITE状态的端口</span></span><br><span class="line"><span class="comment"># 0:关闭重用； 1:开启重用； 2:仅在loopback(回环地址)上重用</span></span><br><span class="line">[root@VM-236-124-centos /var/www/html]<span class="comment"># cat /proc/sys/net/ipv4/tcp_tw_reuse </span></span><br><span class="line">1</span><br><span class="line"><span class="comment"># 系统中维护TIME_WITE状态的最大连接个数，不建议设的太大</span></span><br><span class="line">[root@VM-236-124-centos /var/www/html]<span class="comment"># cat /proc/sys/net/ipv4/tcp_max_tw_buckets </span></span><br><span class="line">524288</span><br></pre></td></tr></table></figure>
<p>也可以通过<code>setsockopt</code>函数，对tcp的socket开启<code>SO_LINGER</code>选项，那么close这个连接的时候将会从标准的四次握手转成直接发送rst断开连接，越过所有状态。</p>
<h5 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h5><p>被关闭方在接收到FIN后会回复ack，之后会进入CLOSE_WAIT状态，直到确认没有数据需要发送，并发送FIN前都会维持这个状态。<br>若在业务中发现出现大量的CLOSE_WAIT状态，可能是应用层的代码有bug，tcp通知应用层对方已经关闭，但应用层确没反应，也就是说被动关闭方没有正确处理socket事件。</p>
<h5 id="LAST-ACK"><a href="#LAST-ACK" class="headerlink" title="LAST_ACK"></a>LAST_ACK</h5><p>被关闭方在发出要与对方关闭连接的FIN后，会进入LAST_ACK状态，等待对方发送的ack。<br>这个状态的超时时间也是有重试次数与间隔时间决定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_orphan_retries</span><br></pre></td></tr></table></figure>
<p>默认值是0，若使用默认值，内核会重试8次，间隔时间会以<code>TCP_RTO_MIN</code>为单位以2的指数增长，<code>TCP_RTO_MIN</code>在内核中被设置成200ms。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当你厌恶你身边的人，表达厌恶最好的方式不是和他们争吵，而是自己勤快点儿，加把劲离开他们，那样，他们就永远从你的生活中消失，和死了差不多。</span><br><span class="line">------罗翔</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">bank</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/11/linux%E5%86%85%E6%A0%B8%E7%AD%96%E7%95%A5/">http://example.com/2023/07/11/linux%E5%86%85%E6%A0%B8%E7%AD%96%E7%95%A5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">bank blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94/" title="消息队列对比"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">消息队列对比</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/30/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl,%E4%BC%9A%E7%BB%8F%E5%8E%86%E5%93%AA%E4%BA%9B%E8%BF%87%E7%A8%8B/" title="在浏览器中输入url，会经历哪些过程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">在浏览器中输入url，会经历哪些过程</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">bank</div><div class="author-info__description">行至水穷处,坐看云起时</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#linux%E5%86%85%E6%A0%B8"><span class="toc-number">1.</span> <span class="toc-text">linux内核</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU"><span class="toc-number">1.1.</span> <span class="toc-text">CPU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.1.</span> <span class="toc-text">系统指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#top"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">top</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sar"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">sar</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mpstat"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">mpstat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#perf"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">perf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pidstat"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">pidstat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cat-x2F-proc-x2F-cpuinfo"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">cat &#x2F;proc&#x2F;cpuinfo</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NUMA"><span class="toc-number">1.1.2.</span> <span class="toc-text">NUMA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">1.1.3.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text">调度器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB"><span class="toc-number">1.1.5.</span> <span class="toc-text">资源隔离</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO"><span class="toc-number">1.2.</span> <span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A4-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">系统指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#iotop"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">iotop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iostat"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">iostat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strace"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">strace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lsof"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">lsof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stat"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">stat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#open"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">open</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync"><span class="toc-number">1.2.1.7.</span> <span class="toc-text">sync</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mount"><span class="toc-number">1.2.1.8.</span> <span class="toc-text">mount</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux-IO%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">linux IO体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ext4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">ext4文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">xfs文件系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux-IO%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.3.</span> <span class="toc-text">linux IO调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CFQ"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">CFQ</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.3.1.0.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4"><span class="toc-number">1.2.3.1.0.2.</span> <span class="toc-text">参数调整</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DEADLINE"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">DEADLINE</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4-1"><span class="toc-number">1.2.3.2.2.</span> <span class="toc-text">参数调整</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BFQ"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">BFQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kyber"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">kyber</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB-1"><span class="toc-number">1.2.4.</span> <span class="toc-text">资源隔离</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%EF%BC%9A"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">实验：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">1.3.</span> <span class="toc-text">内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A4-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">系统指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#top-1"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">top</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#free"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">free</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sar-1"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">sar</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ps"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">ps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vmstat"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">vmstat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cat-x2F-proc-x2F-meminfo"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">cat &#x2F;proc&#x2F;meminfo</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">1.3.2.</span> <span class="toc-text">内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7"><span class="toc-number">1.3.3.</span> <span class="toc-text">内存申请</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.4.</span> <span class="toc-text">物理内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.5.</span> <span class="toc-text">内存分配系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#buddy%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">buddy系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slab%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">slab系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">1.4.</span> <span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4"><span class="toc-number">1.4.1.</span> <span class="toc-text">系统命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#netstat"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">netstat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ss"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">ss</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ifconfig"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">ifconfig</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sar-2"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">sar</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcpdump"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">tcpdump</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#traffic-control-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">traffic control 流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fifo-amp-pfifo-fast%E9%98%9F%E5%88%97"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">fifo &amp; pfifo_fast队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RED"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">RED</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CoDel-amp-fq-codel%E9%98%9F%E5%88%97"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">CoDel &amp; fq_codel队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CoDel%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.2.3.1.</span> <span class="toc-text">CoDel算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fq-codel%E9%98%9F%E5%88%97"><span class="toc-number">1.4.2.3.2.</span> <span class="toc-text">fq_codel队列</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SFQ%E9%9A%8F%E6%9C%BA%E5%85%AC%E5%B9%B3%E9%98%9F%E5%88%97"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">SFQ随机公平队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TBF%E9%98%9F%E5%88%97"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">TBF队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTB%E9%98%9F%E5%88%97"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">HTB队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp"><span class="toc-number">1.4.3.</span> <span class="toc-text">tcp</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">建立连接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.4.3.1.1.</span> <span class="toc-text">三次握手的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#syncookie"><span class="toc-number">1.4.3.1.2.</span> <span class="toc-text">syncookie</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#listen-backlog"><span class="toc-number">1.4.3.1.3.</span> <span class="toc-text">listen backlog</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">数据传输</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="toc-number">1.4.3.2.1.</span> <span class="toc-text">慢启动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">1.4.3.2.2.</span> <span class="toc-text">缓存</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">断开连接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#FIN-WAIT1"><span class="toc-number">1.4.3.3.1.</span> <span class="toc-text">FIN_WAIT1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FIN-WAIT2"><span class="toc-number">1.4.3.3.2.</span> <span class="toc-text">FIN_WAIT2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TIME-WAIT"><span class="toc-number">1.4.3.3.3.</span> <span class="toc-text">TIME_WAIT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CLOSE-WAIT"><span class="toc-number">1.4.3.3.4.</span> <span class="toc-text">CLOSE_WAIT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LAST-ACK"><span class="toc-number">1.4.3.3.5.</span> <span class="toc-text">LAST_ACK</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/04/antlr4%E5%AD%A6%E4%B9%A0/" title="antlr4学习">antlr4学习</a><time datetime="2023-08-04T07:06:13.885Z" title="发表于 2023-08-04 15:06:13">2023-08-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/04/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AD%A6%E4%B9%A0/" title="分布式锁学习">分布式锁学习</a><time datetime="2023-08-04T05:13:24.058Z" title="发表于 2023-08-04 13:13:24">2023-08-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/30/redis%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" title="redis的设计与实现">redis的设计与实现</a><time datetime="2023-07-30T07:35:59.103Z" title="发表于 2023-07-30 15:35:59">2023-07-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94/" title="消息队列对比">消息队列对比</a><time datetime="2023-07-30T06:18:18.328Z" title="发表于 2023-07-30 14:18:18">2023-07-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/11/linux%E5%86%85%E6%A0%B8%E7%AD%96%E7%95%A5/" title="linux内核">linux内核</a><time datetime="2023-07-11T13:23:19.933Z" title="发表于 2023-07-11 21:23:19">2023-07-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By bank</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>